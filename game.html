<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Disciple Run â€“ Game</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    :root {
      --hud-bg: rgba(255, 248, 235, 0.9);
      --hud-border: #3a2513;
      --accent: #c47a3f;
      --accent-dark: #8b4f26;
      --panel-bg: #fdfaf2;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
      font-family: "Pretendard", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    /* ------------ ê²Œì„ ì˜ì—­ ------------ */
    #gameArea {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(#88c6ff 0%, #b7e3ff 45%, #f7f0d9 45%, #f0e0b0 100%);
    }

    /* ------------ íŒ¨ëŸ´ë™ìŠ¤ ë°°ê²½ ------------ */
    #bgLayer1, #bgLayer2, #bgLayer3 {
      position: absolute;
      left: 0; top: 0;
      width: 200%; height: 100%;
      background-repeat: repeat-x;
      image-rendering: pixelated;
      pointer-events: none;
    }
    #bgLayer1 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_sky.png");
      z-index: 1; background-size: auto 100%; background-position: bottom left;
    }
    #bgLayer2 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_mountain.png");
      z-index: 2; background-size: auto 100%; background-position: bottom left;
    }
    #bgLayer3 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_forest.png");
      z-index: 3; background-size: auto 60%; background-position: bottom left;
    }

    /* ë°”ë‹¥ ìˆ¨ê¹€ */
    #ground { display: none; }

    /* í”Œë ˆì´ì–´ */
    #player {
      position: absolute;
      z-index: 12;
      left: 120px; bottom: 40px;
      width: 60px; height: 60px;
      background: url("disciple.png") center/contain no-repeat;
      image-rendering: pixelated;
      transition: opacity 0.2s;
    }

    /* ì¥ì• ë¬¼ */
    .obstacle {
      position: absolute;
      z-index: 10;
      width: 60px;
      background: #8c6239;
      image-rendering: pixelated;
    }

    /* ì•„ì´í…œ */
    .item {
      position: absolute;
      z-index: 11;
      width: 48px; height: 48px;
      image-rendering: pixelated;
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
    }

    /* ------------ HUD (ì™¼ìª½ ìƒë‹¨) ------------ */
    #hud {
      position: absolute;
      z-index: 20;
      top: 12px; left: 12px;
      color: #3a2513;
      font-size: 18px; font-weight: 700;
      background: var(--hud-bg);
      border-radius: 10px;
      padding: 8px 12px;
      border: 3px solid var(--hud-border);
    }
    #hud span { display: inline-block; min-width: 60px; }

    /* ------------ [ì‹ ê·œ] ë²„í”„ ìƒíƒœì°½ (ì˜¤ë¥¸ìª½ ìƒë‹¨) ------------ */
    #buffArea {
      position: absolute;
      z-index: 20;
      top: 12px; right: 12px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .buff-tag {
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 700;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes popIn {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    /* ------------ [ì‹ ê·œ] í„°ë³´ ëª¨ë“œ ìŠ¤í”¼ë“œ ë¼ì¸ íš¨ê³¼ ------------ */
    #speedLines {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 15; /* í”Œë ˆì´ì–´ë³´ë‹¤ ìœ„, HUDë³´ë‹¤ ì•„ë˜ */
      background: radial-gradient(circle, transparent 40%, rgba(255, 255, 255, 0.8) 90%);
      mix-blend-mode: overlay;
      pointer-events: none;
      animation: speedShake 0.1s infinite;
    }
    @keyframes speedShake {
      0% { transform: translate(0, 0); }
      25% { transform: translate(-2px, 2px); }
      50% { transform: translate(2px, -2px); }
      75% { transform: translate(-2px, -2px); }
      100% { transform: translate(0, 0); }
    }

    /* ------------ [ì‹ ê·œ] íšë“ ì´í™íŠ¸ (ë‘¥ì‹¤ ë– ì˜¤ë¥´ëŠ” ê¸€ì) ------------ */
    .float-text {
      position: absolute;
      color: #ffe24f;
      font-weight: 900;
      font-size: 20px;
      text-shadow: 2px 2px 0 #3a2513;
      z-index: 99;
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
    }
    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-60px) scale(1.2); opacity: 0; }
    }

    /* ------------ ì½¤ë³´ / ì •ë‹µ ì´í™íŠ¸ ------------ */
    #comboEffect, #correctEffect {
      position: fixed;
      left: 50%; transform: translateX(-50%);
      z-index: 9999;
      display: none;
      pointer-events: none;
    }
    #comboEffect {
      top: 20%; font-size: 40px; font-weight: 900;
      color: #ffe24f; text-shadow: 3px 3px #8b4f26;
    }
    #correctEffect {
      top: 40%; font-size: 48px; font-weight: 900;
      color: #00ffcc; text-shadow: 3px 3px #006644;
    }

    /* ------------ ê³µí†µ ëª¨ë‹¬ ------------ */
    .modal-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      justify-content: center; align-items: center;
      padding: 16px;
      z-index: 9999;
    }
    .modal-box {
      width: 90%; max-width: 420px;
      background: var(--panel-bg);
      border-radius: 14px;
      border: 4px solid #3a2513;
      padding: 28px 24px;
      box-shadow: 0 0 0 4px #fff, 0 10px 0 #b79b76;
      text-align: center;
    }
    .modal-title { font-size: 28px; font-weight: 800; margin-bottom: 18px; }
    .modal-desc { font-size: 17px; margin-bottom: 22px; line-height: 1.45; white-space: pre-line; }
    
    .choice-btn, .action-btn, .start-btn {
      width: 100%; padding: 14px; margin: 8px 0;
      background: var(--accent); border: 0; border-radius: 10px;
      color: #fff; font-size: 18px; font-weight: 700;
      box-shadow: 0 4px 0 var(--accent-dark); cursor: pointer;
    }
    .choice-btn:active, .action-btn:active, .start-btn:active {
      transform: translateY(2px); box-shadow: 0 2px 0 var(--accent-dark);
    }
    .action-btn:disabled { background: #999; cursor: not-allowed; box-shadow: none; }
    
    .modal-input {
      width: 85%; max-width: 320px;
      padding: 12px; font-size: 16px;
      border-radius: 8px; border: 2px solid #b8a792;
      margin: 8px auto 18px; display: block;
    }

    #loadingQuiz {
      display: none; position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      justify-content: center; align-items: center;
      color: #fff; font-size: 22px; font-weight: 700;
      backdrop-filter: blur(2px); z-index: 9999;
    }
  </style>
</head>

<body>
<div id="gameArea">
  <div id="startGuide" class="modal-bg" style="display:flex;">
    <div class="modal-box">
      <div class="modal-title">ê²Œì„ ë°©ë²• / How to Play</div>
      <div class="modal-desc" style="text-align:left; font-size:15px;">
â€¢ <b>Space</b> ë˜ëŠ” í™”ë©´ í„°ì¹˜ë¡œ ì í”„
â€¢ ì¥ì• ë¬¼ì„ í”¼í•´ <b>ì‹ ì•™ ì ìˆ˜(Faith)</b> íšë“
â€¢ ìƒì ì—ì„œ ë¯¼ì²©/ìƒëª…ë ¥/ëœë¤ ë½‘ê¸° êµí™˜

[ì•„ì´í…œ íš¨ê³¼]
âœï¸ <b>ì‹­ìê°€:</b> ë¬´ì  (10ì´ˆ)
ğŸ•Šï¸ <b>ë‚ ê°œ:</b> í„°ë³´ ëª¨ë“œ (ì´ˆê³ ì† ë¹„í–‰)
ğŸƒ <b>ë°”ëŒ:</b> ì†ë„ ê°ì†Œ
ğŸ“˜ <b>ì„±ê²½:</b> Faith +10
      </div>
      <button class="start-btn" onclick="startGameNow()">â–¶ ì‹œì‘í•˜ê¸° / Start</button>
    </div>
  </div>

  <div id="bgLayer1"></div>
  <div id="bgLayer2"></div>
  <div id="bgLayer3"></div>

  <div id="speedLines"></div>

  <div id="ground"></div>
  <div id="player"></div>

  <div id="hud">
    â¤ï¸ <span id="lifeText"></span>
    ğŸ“ <span id="distanceText">0m</span>
    âœ <span id="faithText"></span>
  </div>

  <div id="buffArea"></div>
</div>

<div id="comboEffect">COMBO +1!</div>
<div id="correctEffect">+5 Faith!</div>

<div id="quizModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">ì„±ê²½ í€´ì¦ˆ</div>
    <div class="modal-desc" id="quizQuestion"></div>
    <button class="choice-btn" onclick="answerQuiz('A')" id="btnA"></button>
    <button class="choice-btn" onclick="answerQuiz('B')" id="btnB"></button>
    <button class="choice-btn" onclick="answerQuiz('C')" id="btnC"></button>
  </div>
</div>

<div id="gameOverModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">GAME OVER</div>
    <div class="modal-desc">
      <b><span id="finalDist"></span>m</b> ë‹¬ë ¸ìŠµë‹ˆë‹¤!
    </div>
    <input id="rankMsg" class="modal-input" type="text" placeholder="ì†Œê° ì…ë ¥(ì„ íƒ)" />
    <button class="action-btn" onclick="confirmRanking()">[ìˆœìœ„ë“±ë¡]</button>
  </div>
</div>

<div id="loadingQuiz">â³ ì„±ê²½ ë¬¸ì œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>

<script>
  const API_URL = "https://script.google.com/macros/s/AKfycbzA10H2TuXRDXBXcttvHHR0Q1sOu8zGpYmrdGhfH-wBsl623k2ydwUkwL7wR8F90mC5Pg/exec";

  let id = localStorage.getItem("run_id");
  let name = localStorage.getItem("run_name");
  let saveData = JSON.parse(localStorage.getItem("run_save") || "{}");

  if (!id) {
    alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
    window.location.href = "/TrapGame/index.html";
  }

  let daily = JSON.parse(localStorage.getItem("dailyMission") || "{}");
  function initDailyMission() {
    return { date: new Date().toDateString(), run200: false, quiz3: 0, faith20: 0 };
  }
  if (!daily.date || daily.date !== new Date().toDateString()) {
    daily = initDailyMission();
    localStorage.setItem("dailyMission", JSON.stringify(daily));
  }

  let life  = 3 + (saveData.extraLife || 0);
  let faith = saveData.faith || 0;

  document.getElementById("lifeText").innerText  = life;
  document.getElementById("faithText").innerText = faith;

  const gameArea = document.getElementById("gameArea");
  const player   = document.getElementById("player");
  const buffArea = document.getElementById("buffArea");
  const speedLines = document.getElementById("speedLines");

  let playerY  = 40;
  let velocity = 0;
  let gravity  = -0.25; 

  let agility   = saveData.agility || 0;
  let jumpPower = 6.5 - agility * 0.05;
  jumpPower     = Math.max(3, jumpPower);

  let distance  = 0;
  let obstacles = [];
  let running   = false;
  let invincible = false; // ê¸°ë³¸ í”¼ê²© ë¬´ì 

  const BASE_SPEED = 170; 
  let gameSpeed    = BASE_SPEED;

  let lastTime            = performance.now();
  let quizTimer           = 0;
  let nextFaithMilestone  = 100;

  let obstacleTimer   = 0;
  let nextObstacleTime = 2.0; 

  let bg1X = 0, bg2X = 0, bg3X = 0;
  const BG1_SPEED = 20; const BG2_SPEED = 40; const BG3_SPEED = 60;

  let items        = [];
  let itemTimer    = 0;
  let nextItemTime = 8;

  let combo = 0;
  let obstacleSurviveCount = 0;
  let rankingSaved = false;

  /* --- [ì‹ ê·œ] í™œì„±í™”ëœ ë²„í”„ ê´€ë¦¬ ê°ì²´ --- */
  let activeEffects = {
    turbo: 0,      // ë‚ ê°œ(í„°ë³´) ë‚¨ì€ ì‹œê°„
    invincible: 0, // ì‹­ìê°€(ë¬´ì ) ë‚¨ì€ ì‹œê°„
    slow: 0        // ë°”ëŒ(ê°ì†) ë‚¨ì€ ì‹œê°„
  };

  function getDifficulty(dist) {
    if (dist < 150) return 1;
    if (dist < 300) return 2;
    return 3;
  }
  function randBetween(min, max) { return Math.random() * (max - min) + min; }

  function jump() {
    // í„°ë³´ ëª¨ë“œì¼ ë•ŒëŠ” ì í”„ ë¶ˆê°€ (ìë™ ë¹„í–‰)
    if (!running || activeEffects.turbo > 0) return;
    velocity = jumpPower;
  }
  document.body.addEventListener("keydown", e => {
    if (e.code === "Space" || e.code === "ArrowUp") { e.preventDefault(); jump(); }
  });
  document.body.addEventListener("touchstart", jump);

  function scheduleNextObstacle() {
    // í„°ë³´ ëª¨ë“œì¼ ë•ŒëŠ” ì¥ì• ë¬¼ ìƒì„± ì•ˆ í•¨ (ì•ˆì „í•˜ê²Œ)
    if (activeEffects.turbo > 0) return;

    const d = getDifficulty(distance);
    if (d === 1) nextObstacleTime = randBetween(1.8, 2.5);
    else if (d === 2) nextObstacleTime = randBetween(1.4, 2.0);
    else nextObstacleTime = randBetween(1.1, 1.7);
  }

  function spawnObstacle() {
    if (!running) return;
    // í„°ë³´ ëª¨ë“œ ì¤‘ì—” ì¥ì• ë¬¼ ìƒì„± ì¤‘ë‹¨
    if (activeEffects.turbo > 0) return;

    const difficulty = getDifficulty(distance);
    const randi = (min, max) => Math.floor(Math.random() * (max - min)) + min;
    let pattern;
    const useGroundBox = Math.random() < 0.5;

    if (useGroundBox) {
      let minH = difficulty === 1 ? 90 : (difficulty === 2 ? 120 : 150);
      let maxH = difficulty === 1 ? 140 : (difficulty === 2 ? 180 : 220);
      pattern = { groundBox: true, height: randi(minH, maxH) };
    } else {
      let topRangeMin, topRangeMax, gapBase, gapVar;
      if (difficulty === 1) {
        topRangeMin = 120; topRangeMax = 220; gapBase = 200; gapVar = 25;
      } else if (difficulty === 2) {
        topRangeMin = 150; topRangeMax = 260; gapBase = 170; gapVar = 25;
      } else {
        topRangeMin = 180; topRangeMax = 320; gapBase = 145; gapVar = 20;
      }
      pattern = { groundBox: false, top: randi(topRangeMin, topRangeMax), gap: randi(gapBase - gapVar, gapBase + gapVar) };
    }

    const screenH = window.innerHeight;
    const startX  = window.innerWidth + 80;

    if (pattern.groundBox) {
      const box = document.createElement("div");
      box.classList.add("obstacle");
      box.style.height = pattern.height + "px";
      box.style.left = startX + "px";
      box.style.bottom = "0";
      gameArea.appendChild(box);
      obstacles.push(box);
      return;
    }
    const topHeight = pattern.top;
    const gap = pattern.gap;
    const bottomHeight = Math.max(80, screenH - topHeight - gap);

    const topObs = document.createElement("div");
    topObs.classList.add("obstacle");
    topObs.style.height = topHeight + "px";
    topObs.style.left = startX + "px";
    topObs.style.top = "0";
    gameArea.appendChild(topObs);

    const bottomObs = document.createElement("div");
    bottomObs.classList.add("obstacle");
    bottomObs.style.height = bottomHeight + "px";
    bottomObs.style.left = startX + "px";
    bottomObs.style.bottom = "0";
    gameArea.appendChild(bottomObs);
    obstacles.push(topObs, bottomObs);
  }

  function spawnItem() {
    const types = ["cross", "wings", "wind", "bible"];
    const type  = types[Math.floor(Math.random() * types.length)];
    const item  = document.createElement("div");
    item.classList.add("item");
    item.dataset.type = type;
    item.style.left   = window.innerWidth + "px";
    item.style.bottom = (Math.random() * 250 + 120) + "px";
    item.style.backgroundImage = `url('https://antiochapp.github.io/TrapGame/item_${type}.png')`;
    gameArea.appendChild(item);
    items.push(item);
  }

  /* ------------ [ì‹ ê·œ] íšë“ ì´í™íŠ¸ í‘œì‹œ í•¨ìˆ˜ ------------ */
  function showFloatText(text) {
    const rect = player.getBoundingClientRect();
    const el = document.createElement("div");
    el.classList.add("float-text");
    el.innerText = text;
    // í”Œë ˆì´ì–´ ë¨¸ë¦¬ ìœ„
    el.style.left = (rect.left + 10) + "px";
    el.style.top  = (rect.top - 20) + "px";
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1000);
  }

  /* ------------ [ìˆ˜ì •] ì•„ì´í…œ íš¨ê³¼ ì ìš© ------------ */
  function activateItem(type) {
    if (type === "cross") {
      activeEffects.invincible = 10; // 10ì´ˆ
      showFloatText("ğŸ›¡ï¸ ë¬´ì !");
    }
    else if (type === "wings") {
      activeEffects.turbo = 5; // 5ì´ˆê°„ í„°ë³´
      showFloatText("ğŸš€ í„°ë³´ ëª¨ë“œ!");
    }
    else if (type === "wind") {
      activeEffects.slow = 10; // 10ì´ˆê°„ ê°ì†
      showFloatText("ğŸƒ ì†ë„ ê°ì†Œ");
    }
    else if (type === "bible") {
      faith += 10;
      saveData.faith = faith;
      document.getElementById("faithText").innerText = faith;
      showFloatText("âœ Faith +10");
      saveProgress();
    }
  }

  /* ------------ [ì‹ ê·œ] ë²„í”„ ìƒíƒœì°½ UI ì—…ë°ì´íŠ¸ ------------ */
  function updateBuffUI(delta) {
    // ì‹œê°„ ê°ì†Œ
    if (activeEffects.turbo > 0) activeEffects.turbo -= delta;
    if (activeEffects.invincible > 0) activeEffects.invincible -= delta;
    if (activeEffects.slow > 0) activeEffects.slow -= delta;

    // UI ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    let html = "";
    if (activeEffects.turbo > 0) {
      html += `<div class="buff-tag" style="color:#00ffff">ğŸš€ í„°ë³´ ëª¨ë“œ: ${Math.ceil(activeEffects.turbo)}s</div>`;
    }
    if (activeEffects.invincible > 0) {
      html += `<div class="buff-tag" style="color:#ffe24f">ğŸ›¡ï¸ ë¬´ì  ìƒíƒœ: ${Math.ceil(activeEffects.invincible)}s</div>`;
    }
    if (activeEffects.slow > 0) {
      html += `<div class="buff-tag" style="color:#aaffaa">ğŸƒ ì†ë„ ê°ì†Œ: ${Math.ceil(activeEffects.slow)}s</div>`;
    }
    buffArea.innerHTML = html;
  }

  function gameLoop(now) {
    if (!running) return;
    const delta = (now - lastTime) / 1000;
    lastTime = now;

    // ë²„í”„ íƒ€ì´ë¨¸ ë° UI ê°±ì‹ 
    updateBuffUI(delta);

    if (!daily.run200 && distance >= 200) daily.run200 = true;
    daily.faith20 = faith;
    localStorage.setItem("dailyMission", JSON.stringify(daily));

    // í„°ë³´ ëª¨ë“œë©´ ê±°ë¦¬ê°€ ì—„ì²­ ë¹¨ë¦¬ ëŠ˜ì–´ë‚¨
    let distMultiplier = (activeEffects.turbo > 0) ? 4 : 1;
    distance += delta * 1 * distMultiplier;
    document.getElementById("distanceText").innerText = Math.floor(distance) + "m";

    /* --- [ìˆ˜ì •] ì†ë„ ê³„ì‚° --- */
    // 1. ê¸°ë³¸ ì†ë„
    let currentSpeed = BASE_SPEED * (1 + (getDifficulty(distance) - 1) * 0.25);
    
    // 2. ë²„í”„ ì ìš©
    if (activeEffects.slow > 0) currentSpeed *= 0.5; // ê°ì†
    if (activeEffects.turbo > 0) currentSpeed *= 3.5; // í„°ë³´ (3.5ë°°)

    gameSpeed = currentSpeed;

    // Faith íšë“
    if (distance >= nextFaithMilestone) {
      faith++; saveData.faith = faith;
      nextFaithMilestone += 100;
      document.getElementById("faithText").innerText = faith;
      saveProgress();
    }

    quizTimer += delta;
    const quizSoon = (quizTimer >= 27 && quizTimer < 30);

    if (!quizSoon) {
      obstacleTimer += delta;
      if (obstacleTimer >= nextObstacleTime) {
        spawnObstacle();
        obstacleTimer = 0;
        scheduleNextObstacle();
      }
    }

    /* --- [ìˆ˜ì •] í”Œë ˆì´ì–´ ì›€ì§ì„ --- */
    if (activeEffects.turbo > 0) {
      // í„°ë³´ ëª¨ë“œ: í”Œë ˆì´ì–´ë¥¼ í™”ë©´ ì¤‘ì•™ìœ¼ë¡œ ê³ ì •ì‹œí‚¤ê³  ì¤‘ë ¥ ë¬´ì‹œ
      // ë¶€ë“œëŸ½ê²Œ ì¤‘ì•™(200px ì •ë„)ìœ¼ë¡œ ì´ë™
      let targetY = 200;
      playerY += (targetY - playerY) * 0.1; 
      velocity = 0; // ì¤‘ë ¥ ì˜í–¥ X
      
      // ìŠ¤í”¼ë“œ ë¼ì¸ ì¼œê¸°
      speedLines.style.display = "block";
    } else {
      // ì¼ë°˜ ëª¨ë“œ
      velocity += gravity;
      playerY += velocity;
      // ìŠ¤í”¼ë“œ ë¼ì¸ ë„ê¸°
      speedLines.style.display = "none";
    }

    if (playerY < 0) playerY = 0;
    if (playerY > window.innerHeight - 110) playerY = window.innerHeight - 110;
    player.style.bottom = playerY + "px";

    // ì¥ì• ë¬¼ ì´ë™ + ì¶©ëŒ
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs  = obstacles[i];
      let left   = parseFloat(obs.style.left) || 0;
      left      -= gameSpeed * delta;
      obs.style.left = left + "px";

      if (left + 60 < 0) {
        obs.remove();
        obstacles.splice(i, 1);
        obstacleSurviveCount++;
        if (obstacleSurviveCount >= 5) {
          combo++; faith++; saveData.faith = faith;
          document.getElementById("faithText").innerText = faith;
          const ce = document.getElementById("comboEffect");
          ce.style.display = "block"; ce.innerText = `COMBO +${combo}!`;
          setTimeout(() => ce.style.display = "none", 1000);
          obstacleSurviveCount = 0; saveProgress();
        }
        continue;
      }

      // ì¶©ëŒ ì²´í¬
      // í„°ë³´ ëª¨ë“œì´ê±°ë‚˜ ë¬´ì  ë²„í”„ ì¤‘ì´ë©´ ì¶©ëŒ ë¬´ì‹œ
      if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible) {
        // ë¬´ì  ìƒíƒœì´ë¯€ë¡œ ê·¸ëƒ¥ ì§€ë‚˜ê°
        continue;
      }

      const rectP = player.getBoundingClientRect();
      const rectO = obs.getBoundingClientRect();
      const buffer = 10;
      if (
        rectP.left + buffer < rectO.right - buffer &&
        rectP.right - buffer > rectO.left + buffer &&
        rectP.top + buffer < rectO.bottom - buffer &&
        rectP.bottom - buffer > rectO.top + buffer
      ) {
        damageLife();
        break;
      }
    }

    // ì•„ì´í…œ ì´ë™
    itemTimer += delta;
    if (itemTimer >= nextItemTime) {
      spawnItem();
      nextItemTime = Math.random() * 6 + 6;
      itemTimer = 0;
    }

    for (let i = items.length - 1; i >= 0; i--) {
      let it   = items[i];
      let left = parseFloat(it.style.left) || 0;
      left    -= gameSpeed * delta;
      it.style.left = left + "px";

      if (left < -60) {
        it.remove(); items.splice(i, 1); continue;
      }

      const rectP = player.getBoundingClientRect();
      const rectI = it.getBoundingClientRect();
      if (
        rectP.left < rectI.right && rectP.right > rectI.left &&
        rectP.top < rectI.bottom && rectP.bottom > rectI.top
      ) {
        activateItem(it.dataset.type);
        it.remove(); items.splice(i, 1); continue;
      }
    }

    // ë°°ê²½ íŒ¨ëŸ´ë™ìŠ¤ (ì†ë„ì— ë¹„ë¡€)
    let speedMult = (gameSpeed / BASE_SPEED); 
    bg1X = (bg1X - BG1_SPEED * speedMult * delta) % window.innerWidth;
    bg2X = (bg2X - BG2_SPEED * speedMult * delta) % window.innerWidth;
    bg3X = (bg3X - BG3_SPEED * speedMult * delta) % window.innerWidth;

    bg1.style.backgroundPosition = `${bg1X}px 0`;
    bg2.style.backgroundPosition = `${bg2X}px bottom`;
    bg3.style.backgroundPosition = `${bg3X}px bottom`;

    if (quizTimer >= 30) {
      quizTimer = 0; pauseForQuiz(); return;
    }
    requestAnimationFrame(gameLoop);
  }

  function damageLife() {
    if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible || !running) return;
    life--;
    document.getElementById("lifeText").innerText = life;
    invincible = true;
    player.style.opacity = "0.4";
    setTimeout(() => { invincible = false; player.style.opacity = "1"; }, 800);
    if (life <= 0) gameOver();
  }

  async function pauseForQuiz() {
    if (!running) return;
    running = false;
    document.getElementById("loadingQuiz").style.display = "flex";
    try {
      const res = await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "getQuiz" }) });
      const txt = await res.text();
      document.getElementById("loadingQuiz").style.display = "none";
      if (txt === "noquiz") { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); return; }
      const quiz = JSON.parse(txt);
      document.getElementById("quizQuestion").innerText = quiz.question;
      document.getElementById("btnA").innerText = "A) " + quiz.A;
      document.getElementById("btnB").innerText = "B) " + quiz.B;
      document.getElementById("btnC").innerText = "C) " + quiz.C;
      window.correctAnswer = quiz.answer;
      document.getElementById("quizModal").style.display = "flex";
    } catch (err) {
      document.getElementById("loadingQuiz").style.display = "none";
      running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
    }
  }

  function answerQuiz(sel) {
    document.getElementById("quizModal").style.display = "none";
    if (sel === window.correctAnswer) {
      const ef = document.getElementById("correctEffect");
      ef.style.display = "block"; setTimeout(() => (ef.style.display = "none"), 800);
      faith += 5; saveData.faith = faith; document.getElementById("faithText").innerText = faith;
      daily.quiz3++; localStorage.setItem("dailyMission", JSON.stringify(daily)); saveProgress();
    } else { damageLife(); }
    if (life > 0) { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); }
  }

  async function saveProgress() {
    try { await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "save", id, saveData }) }); } catch (e) {}
    localStorage.setItem("run_save", JSON.stringify(saveData));
  }

  function startGameNow() {
    document.getElementById("startGuide").style.display = "none";
    running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
  }

  async function gameOver() {
    if (rankingSaved) return;
    running = false; invincible = true; player.style.opacity = "0.4";
    const dist = Math.floor(distance);
    document.getElementById("finalDist").innerText = dist;
    document.getElementById("gameOverModal").style.display = "flex";
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateRanking", id, name, distance: dist, message: "" })
      });
    } catch (e) {}
    rankingSaved = true;
  }

  async function confirmRanking() {
    const btn = document.querySelector(".action-btn");
    const msgInput = document.getElementById("rankMsg");
    const msg = msgInput.value.trim();
    if (!msg) { window.location.href = "/TrapGame/menu.html"; return; }
    btn.innerText = "ì „ì†¡ ì¤‘..."; btn.disabled = true;
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateComment", id: id, message: msg })
      });
      alert("ì†Œê°ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!"); window.location.href = "/TrapGame/menu.html";
    } catch (e) {
      alert("ì „ì†¡ ì˜¤ë¥˜ê°€ ë‚¬ì§€ë§Œ ë©”ë‰´ë¡œ ì´ë™í•©ë‹ˆë‹¤."); window.location.href = "/TrapGame/menu.html";
    }
  }

  let lastTouch = 0;
  document.addEventListener("touchend", e => {
    const now = Date.now(); if (now - lastTouch < 300) e.preventDefault(); lastTouch = now;
  }, { passive: false });
</script>
</body>
</html>
