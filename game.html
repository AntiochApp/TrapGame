<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Disciple Run â€“ Game</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    :root {
      --hud-bg: rgba(255, 248, 235, 0.9);
      --hud-border: #3a2513;
      --accent: #c47a3f;
      --accent-dark: #8b4f26;
      --panel-bg: #fdfaf2;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
      font-family: "Pretendard", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    /* ------------ ê²Œì„ ì˜ì—­ ------------ */
    #gameArea {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(#88c6ff 0%, #b7e3ff 45%, #f7f0d9 45%, #f0e0b0 100%);
    }

    /* ------------ íŒ¨ëŸ´ë™ìŠ¤ ë°°ê²½ ------------ */
    #bgLayer1, #bgLayer2, #bgLayer3 {
      position: absolute;
      left: 0; top: 0;
      width: 200%; height: 100%;
      background-repeat: repeat-x;
      image-rendering: pixelated;
      pointer-events: none;
    }
    #bgLayer1 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_sky.png");
      z-index: 1; background-size: auto 100%; background-position: bottom left;
    }
    #bgLayer2 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_mountain.png");
      z-index: 2; background-size: auto 100%; background-position: bottom left;
    }
    #bgLayer3 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_forest.png");
      z-index: 3; background-size: auto 60%; background-position: bottom left;
    }

    /* ë°”ë‹¥ ìˆ¨ê¹€ */
    #ground { display: none; }

    /* í”Œë ˆì´ì–´ */
    #player {
      position: absolute;
      z-index: 12;
      left: 120px; bottom: 40px;
      width: 60px; height: 60px;
      background: url("disciple.png") center/contain no-repeat;
      image-rendering: pixelated;
      transition: opacity 0.2s;
      filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.2)); /* ê·¸ë¦¼ì */
    }

    /* ------------ [ë””ìì¸ ìˆ˜ì •] CSSë¡œ ê·¸ë¦° í†µë‚˜ë¬´ ì¥ì• ë¬¼ ------------ */
    .obstacle {
      position: absolute;
      z-index: 10;
      width: 60px; /* ë‘ê»˜ */
      
      /* í†µë‚˜ë¬´ ì§ˆê° (CSS íŒ¨í„´) */
      background-color: #8D6E63; /* ê¸°ë³¸ ê°ˆìƒ‰ */
      background-image: 
        linear-gradient(90deg, rgba(0,0,0,0.05) 50%, transparent 50%),
        linear-gradient(rgba(0,0,0,0.05) 50%, transparent 50%);
      background-size: 8px 8px; /* í”½ì…€ ëŠë‚Œ íŒ¨í„´ */
      
      /* ë‚˜ë¬´ í…Œë‘ë¦¬ */
      border-left: 4px solid #5D4037;
      border-right: 4px solid #5D4037;
      
      box-shadow: 4px 4px 0 rgba(0,0,0,0.2); /* ê·¸ë¦¼ì */
    }

    /* í’€ ë®ê°œ (ê°€ìƒ ìš”ì†Œë¡œ ê·¸ë¦¼) */
    .obs-cap::after {
        content: '';
        position: absolute;
        left: -10%; width: 120%; height: 24px; /* í†µë‚˜ë¬´ë³´ë‹¤ ì•½ê°„ ë„“ê²Œ */
        background-color: #66BB6A; /* í’€ìƒ‰ */
        border: 4px solid #1B5E20; /* ì§™ì€ ë…¹ìƒ‰ í…Œë‘ë¦¬ */
        box-sizing: border-box;
        border-radius: 4px;
        background-image: linear-gradient(45deg, transparent 80%, rgba(255,255,255,0.3) 80%); /* í•˜ì´ë¼ì´íŠ¸ */
    }

    /* ë°”ë‹¥ ê¸°ë‘¥ (í’€ì´ ìœ„ì— ìˆìŒ) */
    .obs-ground.obs-cap::after { top: -12px; }

    /* ì²œì¥ ê¸°ë‘¥ (í’€ì´ ì•„ë˜ì— ìˆìŒ) */
    .obs-ceil.obs-cap::after { bottom: -12px; }


    /* ì•„ì´í…œ */
    .item {
      position: absolute;
      z-index: 11;
      width: 48px; height: 48px;
      image-rendering: pixelated;
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
      animation: itemFloat 1.5s ease-in-out infinite alternate;
    }
    @keyframes itemFloat {
        from { transform: translateY(0); }
        to { transform: translateY(-8px); }
    }

    /* ------------ HUD ------------ */
    #hud {
      position: absolute;
      z-index: 20;
      top: 12px; left: 12px;
      color: #3a2513;
      font-size: 18px; font-weight: 700;
      background: var(--hud-bg);
      border-radius: 10px;
      padding: 8px 12px;
      border: 3px solid var(--hud-border);
    }
    #hud span { display: inline-block; min-width: 60px; }

    /* ë²„í”„ ìƒíƒœì°½ */
    #buffArea {
      position: absolute;
      z-index: 20;
      top: 12px; right: 12px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .buff-tag {
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 700;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes popIn {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    /* í„°ë³´ ìŠ¤í”¼ë“œ ë¼ì¸ */
    #speedLines {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 15;
      background: radial-gradient(circle, transparent 40%, rgba(255, 255, 255, 0.8) 90%);
      mix-blend-mode: overlay;
      pointer-events: none;
      animation: speedShake 0.1s infinite;
    }
    @keyframes speedShake {
      0% { transform: translate(0, 0); }
      25% { transform: translate(-2px, 2px); }
      50% { transform: translate(2px, -2px); }
      75% { transform: translate(-2px, -2px); }
      100% { transform: translate(0, 0); }
    }

    /* íšë“ ì´í™íŠ¸ í…ìŠ¤íŠ¸ */
    .float-text {
      position: absolute;
      color: #ffe24f;
      font-weight: 900;
      font-size: 20px;
      text-shadow: 2px 2px 0 #3a2513;
      z-index: 99;
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
    }
    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-60px) scale(1.2); opacity: 0; }
    }

    /* ì½¤ë³´ / ì •ë‹µ ì´í™íŠ¸ */
    #comboEffect, #correctEffect {
      position: fixed;
      left: 50%; transform: translateX(-50%);
      z-index: 9999;
      display: none;
      pointer-events: none;
    }
    #comboEffect {
      top: 20%; font-size: 40px; font-weight: 900;
      color: #ffe24f; text-shadow: 3px 3px #8b4f26;
    }
    #correctEffect {
      top: 40%; font-size: 48px; font-weight: 900;
      color: #00ffcc; text-shadow: 3px 3px #006644;
    }

    /* ê³µí†µ ëª¨ë‹¬ */
    .modal-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      justify-content: center; align-items: center;
      padding: 16px;
      z-index: 9999;
    }
    .modal-box {
      width: 90%; max-width: 420px;
      background: var(--panel-bg);
      border-radius: 14px;
      border: 4px solid #3a2513;
      padding: 28px 24px;
      box-shadow: 0 0 0 4px #fff, 0 10px 0 #b79b76;
      text-align: center;
    }
    .modal-title { font-size: 28px; font-weight: 800; margin-bottom: 18px; }
    .modal-desc { font-size: 17px; margin-bottom: 22px; line-height: 1.45; white-space: pre-line; }
    
    .choice-btn, .action-btn, .start-btn {
      width: 100%; padding: 14px; margin: 8px 0;
      background: var(--accent); border: 0; border-radius: 10px;
      color: #fff; font-size: 18px; font-weight: 700;
      box-shadow: 0 4px 0 var(--accent-dark); cursor: pointer;
    }
    .choice-btn:active, .action-btn:active, .start-btn:active {
      transform: translateY(2px); box-shadow: 0 2px 0 var(--accent-dark);
    }
    .action-btn:disabled { background: #999; cursor: not-allowed; box-shadow: none; }
    
    .modal-input {
      width: 85%; max-width: 320px;
      padding: 12px; font-size: 16px;
      border-radius: 8px; border: 2px solid #b8a792;
      margin: 8px auto 18px; display: block;
    }

    #loadingQuiz {
      display: none; position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      justify-content: center; align-items: center;
      color: #fff; font-size: 22px; font-weight: 700;
      backdrop-filter: blur(2px); z-index: 9999;
    }
  </style>
</head>

<body>
<div id="gameArea">
  <div id="startGuide" class="modal-bg" style="display:flex;">
    <div class="modal-box">
      <div class="modal-title">ê²Œì„ ë°©ë²• / How to Play</div>
      <div class="modal-desc" style="text-align:left; font-size:15px;">
â€¢ <b>Space</b> ë˜ëŠ” í™”ë©´ í„°ì¹˜ë¡œ ì í”„
â€¢ ì¥ì• ë¬¼ì„ í”¼í•´ <b>ì‹ ì•™ ì ìˆ˜(Faith)</b> íšë“
â€¢ ìƒì ì—ì„œ ë¯¼ì²©/ìƒëª…ë ¥/ëœë¤ ë½‘ê¸° êµí™˜

[ì•„ì´í…œ íš¨ê³¼]
âœï¸ <b>ì‹­ìê°€:</b> ë¬´ì  (10ì´ˆ)
ğŸ•Šï¸ <b>ë‚ ê°œ:</b> í„°ë³´ ëª¨ë“œ (ì´ˆê³ ì† ë¹„í–‰)
ğŸƒ <b>ë°”ëŒ:</b> ì†ë„ ê°ì†Œ
ğŸ“˜ <b>ì„±ê²½:</b> Faith +10
      </div>
      <button class="start-btn" onclick="startGameNow()">â–¶ ì‹œì‘í•˜ê¸° / Start</button>
    </div>
  </div>

  <div id="bgLayer1"></div>
  <div id="bgLayer2"></div>
  <div id="bgLayer3"></div>

  <div id="speedLines"></div>

  <div id="ground"></div>
  <div id="player"></div>

  <div id="hud">
    â¤ï¸ <span id="lifeText"></span>
    ğŸ“ <span id="distanceText">0m</span>
    âœ <span id="faithText"></span>
  </div>

  <div id="buffArea"></div>
</div>

<div id="comboEffect">COMBO +1!</div>
<div id="correctEffect">+5 Faith!</div>

<div id="quizModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">ì„±ê²½ í€´ì¦ˆ</div>
    <div class="modal-desc" id="quizQuestion"></div>
    <button class="choice-btn" onclick="answerQuiz('A')" id="btnA"></button>
    <button class="choice-btn" onclick="answerQuiz('B')" id="btnB"></button>
    <button class="choice-btn" onclick="answerQuiz('C')" id="btnC"></button>
  </div>
</div>

<div id="gameOverModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">GAME OVER</div>
    <div class="modal-desc">
      <b><span id="finalDist"></span>m</b> ë‹¬ë ¸ìŠµë‹ˆë‹¤!
    </div>
    <input id="rankMsg" class="modal-input" type="text" placeholder="ì†Œê° ì…ë ¥(ì„ íƒ)" />
    <button class="action-btn" onclick="confirmRanking()">[ìˆœìœ„ë“±ë¡]</button>
  </div>
</div>

<div id="loadingQuiz">â³ ì„±ê²½ ë¬¸ì œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>

<script>
  const API_URL = "https://script.google.com/macros/s/AKfycbzA10H2TuXRDXBXcttvHHR0Q1sOu8zGpYmrdGhfH-wBsl623k2ydwUkwL7wR8F90mC5Pg/exec";

  let id = localStorage.getItem("run_id");
  let name = localStorage.getItem("run_name");
  let saveData = JSON.parse(localStorage.getItem("run_save") || "{}");

  if (!id) {
    alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
    window.location.href = "/TrapGame/index.html";
  }

  let daily = JSON.parse(localStorage.getItem("dailyMission") || "{}");
  function initDailyMission() {
    return { date: new Date().toDateString(), run200: false, quiz3: 0, faith20: 0 };
  }
  if (!daily.date || daily.date !== new Date().toDateString()) {
    daily = initDailyMission();
    localStorage.setItem("dailyMission", JSON.stringify(daily));
  }

  let life  = 3 + (saveData.extraLife || 0);
  let faith = saveData.faith || 0;

  document.getElementById("lifeText").innerText  = life;
  document.getElementById("faithText").innerText = faith;

  const gameArea = document.getElementById("gameArea");
  const player   = document.getElementById("player");
  const buffArea = document.getElementById("buffArea");
  const speedLines = document.getElementById("speedLines");

  let playerY  = 40;
  let velocity = 0;
  let gravity  = -0.25; 

  let agility   = saveData.agility || 0;
  let jumpPower = 6.5 - agility * 0.05;
  jumpPower     = Math.max(3, jumpPower);

  let distance  = 0;
  let obstacles = [];
  let running   = false;
  let invincible = false;

  const BASE_SPEED = 170; 
  let gameSpeed    = BASE_SPEED;

  let lastTime            = performance.now();
  let quizTimer           = 0;
  let nextFaithMilestone  = 100;

  let obstacleTimer   = 0;
  let nextObstacleTime = 2.0; 

  let bg1X = 0, bg2X = 0, bg3X = 0;
  const BG1_SPEED = 20; const BG2_SPEED = 40; const BG3_SPEED = 60;

  let items        = [];
  let itemTimer    = 0;
  let nextItemTime = 8;

  let combo = 0;
  let obstacleSurviveCount = 0;
  let rankingSaved = false;

  let activeEffects = { turbo: 0, invincible: 0, slow: 0 };

  function getDifficulty(dist) {
    if (dist < 150) return 1;
    if (dist < 300) return 2;
    return 3;
  }
  function randBetween(min, max) { return Math.random() * (max - min) + min; }

  function jump() {
    if (!running || activeEffects.turbo > 0) return;
    velocity = jumpPower;
  }
  document.body.addEventListener("keydown", e => {
    if (e.code === "Space" || e.code === "ArrowUp") { e.preventDefault(); jump(); }
  });
  document.body.addEventListener("touchstart", jump);

  function scheduleNextObstacle() {
    if (activeEffects.turbo > 0) return;
    const d = getDifficulty(distance);
    if (d === 1) nextObstacleTime = randBetween(1.8, 2.5);
    else if (d === 2) nextObstacleTime = randBetween(1.4, 2.0);
    else nextObstacleTime = randBetween(1.1, 1.7);
  }

  function spawnObstacle() {
    if (!running) return;
    if (activeEffects.turbo > 0) return;

    const difficulty = getDifficulty(distance);
    const randi = (min, max) => Math.floor(Math.random() * (max - min)) + min;
    let pattern;
    const useGroundBox = Math.random() < 0.5;

    if (useGroundBox) {
      let minH = difficulty === 1 ? 90 : (difficulty === 2 ? 120 : 150);
      let maxH = difficulty === 1 ? 140 : (difficulty === 2 ? 180 : 220);
      pattern = { groundBox: true, height: randi(minH, maxH) };
    } else {
      let topRangeMin, topRangeMax, gapBase, gapVar;
      if (difficulty === 1) {
        topRangeMin = 120; topRangeMax = 220; gapBase = 200; gapVar = 25;
      } else if (difficulty === 2) {
        topRangeMin = 150; topRangeMax = 260; gapBase = 170; gapVar = 25;
      } else {
        topRangeMin = 180; topRangeMax = 320; gapBase = 145; gapVar = 20;
      }
      pattern = { groundBox: false, top: randi(topRangeMin, topRangeMax), gap: randi(gapBase - gapVar, gapBase + gapVar) };
    }

    const screenH = window.innerHeight;
    const startX  = window.innerWidth + 80;

    if (pattern.groundBox) {
      const box = document.createElement("div");
      // [ìˆ˜ì •] í´ë˜ìŠ¤ ì¶”ê°€: ê¸°ë³¸, ëšœê»‘, ë°”ë‹¥í˜•
      box.classList.add("obstacle", "obs-cap", "obs-ground");
      box.style.height = pattern.height + "px";
      box.style.left = startX + "px";
      box.style.bottom = "0";
      gameArea.appendChild(box);
      obstacles.push(box);
      return;
    }

    const topHeight = pattern.top;
    const gap = pattern.gap;
    const bottomHeight = Math.max(80, screenH - topHeight - gap);

    const topObs = document.createElement("div");
    // [ìˆ˜ì •] í´ë˜ìŠ¤ ì¶”ê°€: ê¸°ë³¸, ëšœê»‘, ì²œì¥í˜•
    topObs.classList.add("obstacle", "obs-cap", "obs-ceil");
    topObs.style.height = topHeight + "px";
    topObs.style.left = startX + "px";
    topObs.style.top = "0";
    gameArea.appendChild(topObs);

    const bottomObs = document.createElement("div");
    // [ìˆ˜ì •] í´ë˜ìŠ¤ ì¶”ê°€: ê¸°ë³¸, ëšœê»‘, ë°”ë‹¥í˜•
    bottomObs.classList.add("obstacle", "obs-cap", "obs-ground");
    bottomObs.style.height = bottomHeight + "px";
    bottomObs.style.left = startX + "px";
    bottomObs.style.bottom = "0";
    gameArea.appendChild(bottomObs);
    obstacles.push(topObs, bottomObs);
  }

  function spawnItem() {
    const types = ["cross", "wings", "wind", "bible"];
    const type  = types[Math.floor(Math.random() * types.length)];
    const item  = document.createElement("div");
    item.classList.add("item");
    item.dataset.type = type;
    item.style.left   = window.innerWidth + "px";
    item.style.bottom = (Math.random() * 250 + 120) + "px";
    item.style.backgroundImage = `url('https://antiochapp.github.io/TrapGame/item_${type}.png')`;
    gameArea.appendChild(item);
    items.push(item);
  }

  function showFloatText(text) {
    const rect = player.getBoundingClientRect();
    const el = document.createElement("div");
    el.classList.add("float-text");
    el.innerText = text;
    el.style.left = (rect.left + 10) + "px";
    el.style.top  = (rect.top - 20) + "px";
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1000);
  }

  function activateItem(type) {
    if (type === "cross") {
      activeEffects.invincible = 10; showFloatText("ğŸ›¡ï¸ ë¬´ì !");
    } else if (type === "wings") {
      activeEffects.turbo = 5; showFloatText("ğŸš€ í„°ë³´ ëª¨ë“œ!");
    } else if (type === "wind") {
      activeEffects.slow = 10; showFloatText("ğŸƒ ì†ë„ ê°ì†Œ");
    } else if (type === "bible") {
      faith += 10; saveData.faith = faith; document.getElementById("faithText").innerText = faith;
      showFloatText("âœ Faith +10"); saveProgress();
    }
  }

  function updateBuffUI(delta) {
    if (activeEffects.turbo > 0) activeEffects.turbo -= delta;
    if (activeEffects.invincible > 0) activeEffects.invincible -= delta;
    if (activeEffects.slow > 0) activeEffects.slow -= delta;

    let html = "";
    if (activeEffects.turbo > 0) html += `<div class="buff-tag" style="color:#00ffff">ğŸš€ í„°ë³´ ëª¨ë“œ: ${Math.ceil(activeEffects.turbo)}s</div>`;
    if (activeEffects.invincible > 0) html += `<div class="buff-tag" style="color:#ffe24f">ğŸ›¡ï¸ ë¬´ì  ìƒíƒœ: ${Math.ceil(activeEffects.invincible)}s</div>`;
    if (activeEffects.slow > 0) html += `<div class="buff-tag" style="color:#aaffaa">ğŸƒ ì†ë„ ê°ì†Œ: ${Math.ceil(activeEffects.slow)}s</div>`;
    buffArea.innerHTML = html;
  }

  function gameLoop(now) {
    if (!running) return;
    const delta = (now - lastTime) / 1000;
    lastTime = now;

    updateBuffUI(delta);

    if (!daily.run200 && distance >= 200) daily.run200 = true;
    daily.faith20 = faith;
    localStorage.setItem("dailyMission", JSON.stringify(daily));

    let distMultiplier = (activeEffects.turbo > 0) ? 4 : 1;
    distance += delta * 1 * distMultiplier;
    document.getElementById("distanceText").innerText = Math.floor(distance) + "m";

    let currentSpeed = BASE_SPEED * (1 + (getDifficulty(distance) - 1) * 0.25);
    if (activeEffects.slow > 0) currentSpeed *= 0.5;
    if (activeEffects.turbo > 0) currentSpeed *= 3.5;
    gameSpeed = currentSpeed;

    if (distance >= nextFaithMilestone) {
      faith++; saveData.faith = faith; nextFaithMilestone += 100;
      document.getElementById("faithText").innerText = faith; saveProgress();
    }

    quizTimer += delta;
    const quizSoon = (quizTimer >= 27 && quizTimer < 30);
    if (!quizSoon) {
      obstacleTimer += delta;
      if (obstacleTimer >= nextObstacleTime) {
        spawnObstacle(); obstacleTimer = 0; scheduleNextObstacle();
      }
    }

    if (activeEffects.turbo > 0) {
      let targetY = 200; playerY += (targetY - playerY) * 0.1; velocity = 0;
      speedLines.style.display = "block";
    } else {
      velocity += gravity; playerY += velocity;
      speedLines.style.display = "none";
    }

    if (playerY < 0) playerY = 0;
    if (playerY > window.innerHeight - 110) playerY = window.innerHeight - 110;
    player.style.bottom = playerY + "px";

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs  = obstacles[i];
      let left   = parseFloat(obs.style.left) || 0;
      left      -= gameSpeed * delta;
      obs.style.left = left + "px";

      if (left + 60 < 0) {
        obs.remove(); obstacles.splice(i, 1);
        obstacleSurviveCount++;
        if (obstacleSurviveCount >= 5) {
          combo++; faith++; saveData.faith = faith;
          document.getElementById("faithText").innerText = faith;
          const ce = document.getElementById("comboEffect");
          ce.style.display = "block"; ce.innerText = `COMBO +${combo}!`;
          setTimeout(() => ce.style.display = "none", 1000);
          obstacleSurviveCount = 0; saveProgress();
        }
        continue;
      }

      if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible) continue;

      const rectP = player.getBoundingClientRect();
      const rectO = obs.getBoundingClientRect();
      const buffer = 10;
      if (
        rectP.left + buffer < rectO.right - buffer &&
        rectP.right - buffer > rectO.left + buffer &&
        rectP.top + buffer < rectO.bottom - buffer &&
        rectP.bottom - buffer > rectO.top + buffer
      ) {
        damageLife(); break;
      }
    }

    itemTimer += delta;
    if (itemTimer >= nextItemTime) {
      spawnItem(); nextItemTime = Math.random() * 6 + 6; itemTimer = 0;
    }

    for (let i = items.length - 1; i >= 0; i--) {
      let it   = items[i];
      let left = parseFloat(it.style.left) || 0;
      left    -= gameSpeed * delta;
      it.style.left = left + "px";
      if (left < -60) { it.remove(); items.splice(i, 1); continue; }
      const rectP = player.getBoundingClientRect();
      const rectI = it.getBoundingClientRect();
      if (
        rectP.left < rectI.right && rectP.right > rectI.left &&
        rectP.top < rectI.bottom && rectP.bottom > rectI.top
      ) {
        activateItem(it.dataset.type); it.remove(); items.splice(i, 1); continue;
      }
    }

    let speedMult = (gameSpeed / BASE_SPEED); 
    bg1X = (bg1X - BG1_SPEED * speedMult * delta) % window.innerWidth;
    bg2X = (bg2X - BG2_SPEED * speedMult * delta) % window.innerWidth;
    bg3X = (bg3X - BG3_SPEED * speedMult * delta) % window.innerWidth;
    bg1.style.backgroundPosition = `${bg1X}px 0`;
    bg2.style.backgroundPosition = `${bg2X}px bottom`;
    bg3.style.backgroundPosition = `${bg3X}px bottom`;

    if (quizTimer >= 30) { quizTimer = 0; pauseForQuiz(); return; }
    requestAnimationFrame(gameLoop);
  }

  function damageLife() {
    if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible || !running) return;
    life--; document.getElementById("lifeText").innerText = life;
    invincible = true; player.style.opacity = "0.4";
    setTimeout(() => { invincible = false; player.style.opacity = "1"; }, 800);
    if (life <= 0) gameOver();
  }

  async function pauseForQuiz() {
    if (!running) return;
    running = false; document.getElementById("loadingQuiz").style.display = "flex";
    try {
      const res = await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "getQuiz" }) });
      const txt = await res.text();
      document.getElementById("loadingQuiz").style.display = "none";
      if (txt === "noquiz") { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); return; }
      const quiz = JSON.parse(txt);
      document.getElementById("quizQuestion").innerText = quiz.question;
      document.getElementById("btnA").innerText = "A) " + quiz.A;
      document.getElementById("btnB").innerText = "B) " + quiz.B;
      document.getElementById("btnC").innerText = "C) " + quiz.C;
      window.correctAnswer = quiz.answer;
      document.getElementById("quizModal").style.display = "flex";
    } catch (err) {
      document.getElementById("loadingQuiz").style.display = "none";
      running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
    }
  }

  function answerQuiz(sel) {
    document.getElementById("quizModal").style.display = "none";
    if (sel === window.correctAnswer) {
      const ef = document.getElementById("correctEffect");
      ef.style.display = "block"; setTimeout(() => (ef.style.display = "none"), 800);
      faith += 5; saveData.faith = faith; document.getElementById("faithText").innerText = faith;
      daily.quiz3++; localStorage.setItem("dailyMission", JSON.stringify(daily)); saveProgress();
    } else { damageLife(); }
    if (life > 0) { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); }
  }

  async function saveProgress() {
    try { await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "save", id, saveData }) }); } catch (e) {}
    localStorage.setItem("run_save", JSON.stringify(saveData));
  }

  function startGameNow() {
    document.getElementById("startGuide").style.display = "none";
    running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
  }

  async function gameOver() {
    if (rankingSaved) return;
    running = false; invincible = true; player.style.opacity = "0.4";
    const dist = Math.floor(distance);
    document.getElementById("finalDist").innerText = dist;
    document.getElementById("gameOverModal").style.display = "flex";
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateRanking", id, name, distance: dist, message: "" })
      });
    } catch (e) {}
    rankingSaved = true;
  }

  async function confirmRanking() {
    const btn = document.querySelector(".action-btn");
    const msgInput = document.getElementById("rankMsg");
    const msg = msgInput.value.trim();
    if (!msg) { window.location.href = "/TrapGame/menu.html"; return; }
    btn.innerText = "ì „ì†¡ ì¤‘..."; btn.disabled = true;
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateComment", id: id, message: msg })
      });
      alert("ì†Œê°ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!"); window.location.href = "/TrapGame/menu.html";
    } catch (e) {
      alert("ì „ì†¡ ì˜¤ë¥˜ê°€ ë‚¬ì§€ë§Œ ë©”ë‰´ë¡œ ì´ë™í•©ë‹ˆë‹¤."); window.location.href = "/TrapGame/menu.html";
    }
  }

  let lastTouch = 0;
  document.addEventListener("touchend", e => {
    const now = Date.now(); if (now - lastTouch < 300) e.preventDefault(); lastTouch = now;
  }, { passive: false });
</script>
</body>
</html>
