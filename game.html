<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Disciple Run â€“ Game</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    :root {
      --hud-bg: rgba(255, 248, 235, 0.9);
      --hud-border: #3a2513;
      --accent: #c47a3f;
      --accent-dark: #8b4f26;
      --panel-bg: #fdfaf2;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
      font-family: "Pretendard", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    #gameArea {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(#88c6ff 0%, #b7e3ff 45%, #f7f0d9 45%, #f0e0b0 100%);
    }

    /* ë°°ê²½ */
    #bgLayer1, #bgLayer2, #bgLayer3 {
      position: absolute;
      left: 0; top: 0;
      width: 200%; height: 100%;
      background-repeat: repeat-x;
      image-rendering: pixelated;
      pointer-events: none;
      will-change: background-position;
    }
    #bgLayer1 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_sky.png");
      z-index: 1; background-size: auto 100%; background-position: 0 bottom;
    }
    #bgLayer2 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_mountain.png");
      z-index: 2; background-size: auto 100%; background-position: 0 bottom;
    }
    #bgLayer3 {
      background-image: url("https://antiochapp.github.io/TrapGame/bg_forest.png");
      z-index: 3; background-size: auto 60%; background-position: 0 bottom;
    }

    #ground { display: none; }

    #player {
      position: absolute;
      z-index: 50; 
      left: 120px; bottom: 40px;
      width: 60px; height: 60px;
      background: url("disciple.png") center/contain no-repeat;
      image-rendering: pixelated;
      transition: opacity 0.2s;
      filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.2)); 
    }

    /* ------------ ì¥ì• ë¬¼ ê³µí†µ ------------ */
    .obstacle {
      position: absolute;
      z-index: 40;
      background-size: 8px 8px; 
      box-shadow: 4px 4px 0 rgba(0,0,0,0.2); 
    }
    .obs-cap::after {
        content: '';
        position: absolute;
        left: -10%; width: 120%; height: 24px; 
        box-sizing: border-box;
        border-radius: 4px;
    }
    .obs-ground.obs-cap::after { top: -12px; }
    .obs-ceil.obs-cap::after { bottom: -12px; }

    /* [íƒ€ì… 1] ì„¸ë¡œ í†µë‚˜ë¬´ */
    .obs-log {
      width: 60px; 
      background-color: #8D6E63;
      background-image: 
        linear-gradient(90deg, rgba(0,0,0,0.05) 50%, transparent 50%),
        linear-gradient(rgba(0,0,0,0.05) 50%, transparent 50%);
      border-left: 4px solid #5D4037;
      border-right: 4px solid #5D4037;
    }
    .obs-log.obs-cap::after {
        background-color: #66BB6A; 
        border: 4px solid #1B5E20; 
        background-image: linear-gradient(45deg, transparent 80%, rgba(255,255,255,0.3) 80%);
    }

    /* [íƒ€ì… 2] ëŒê¸°ë‘¥ */
    .obs-rock {
      width: 60px;
      background-color: #9E9E9E; 
      background-image: 
        radial-gradient(circle, rgba(0,0,0,0.1) 20%, transparent 20%),
        radial-gradient(circle, rgba(255,255,255,0.1) 20%, transparent 20%);
      background-size: 16px 16px;
      border-left: 4px solid #616161;
      border-right: 4px solid #616161;
    }
    .obs-rock.obs-cap::after {
        background-color: #BDBDBD; 
        border: 4px solid #424242; 
    }

    /* [íƒ€ì… 3] ê°€ë¡œ ê¸´ í†µë‚˜ë¬´ */
    .obs-long {
      width: 110px;  
      height: 40px;  
      background-color: #5D4037; 
      background-image: 
        linear-gradient(0deg, rgba(0,0,0,0.1) 50%, transparent 50%); 
      background-size: 100% 8px;
      border: 4px solid #3E2723;
      border-radius: 8px;
    }

    /* ------------ ìš´ì„ ------------ */
    .meteor {
      position: absolute;
      z-index: 60; 
      width: 40px; height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffeb3b, #ff5722);
      box-shadow: 0 0 10px #ff9800;
      animation: spinMeteor 1s linear infinite;
    }
    .meteor::before {
      content: '';
      position: absolute;
      top: -30px; right: -30px;
      width: 80px; height: 80px;
      background: linear-gradient(45deg, transparent 60%, rgba(255,87,34,0.8));
      transform: rotate(45deg);
      z-index: -1;
      border-radius: 50%;
      filter: blur(4px);
    }
    @keyframes spinMeteor {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* ì•„ì´í…œ */
    .item {
      position: absolute;
      z-index: 45;
      width: 48px; height: 48px;
      image-rendering: pixelated;
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
      animation: itemFloat 1.5s ease-in-out infinite alternate;
    }
    @keyframes itemFloat {
        from { transform: translateY(0); }
        to { transform: translateY(-8px); }
    }

    /* HUD */
    #hud {
      position: fixed;
      z-index: 900;
      top: 12px; left: 12px;
      color: #3a2513;
      font-size: 18px; font-weight: 700;
      background: var(--hud-bg);
      border-radius: 10px;
      padding: 8px 12px;
      border: 3px solid var(--hud-border);
    }
    #hud span { display: inline-block; min-width: 60px; }

    /* ë²„í”„ ìƒíƒœì°½ (í™”ë©´ ê³ ì •) */
    #buffArea {
      position: fixed;
      z-index: 2147483647; 
      bottom: 20px; 
      right: 15px;
      display: flex;
      flex-direction: column-reverse;
      align-items: flex-end;
      gap: 8px;
      pointer-events: none;
      transform: translateZ(0); 
      -webkit-transform: translateZ(0);
    }
    .buff-tag {
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 700;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      border-left: 5px solid;
    }
    @keyframes popIn {
      from { transform: scale(0.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    /* ìŠ¤í”¼ë“œ ë¼ì¸ */
    #speedLines {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 80;
      background: radial-gradient(circle, transparent 40%, rgba(255, 255, 255, 0.8) 90%);
      mix-blend-mode: overlay;
      pointer-events: none;
      animation: speedShake 0.1s infinite;
    }
    @keyframes speedShake {
      0% { transform: translate(0, 0); }
      25% { transform: translate(-2px, 2px); }
      50% { transform: translate(2px, -2px); }
      75% { transform: translate(-2px, -2px); }
      100% { transform: translate(0, 0); }
    }

    .float-text {
      position: absolute;
      color: #ffe24f;
      font-weight: 900;
      font-size: 20px;
      text-shadow: 2px 2px 0 #3a2513;
      z-index: 1000;
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
    }
    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-60px) scale(1.2); opacity: 0; }
    }

    #comboEffect, #correctEffect {
      position: fixed;
      left: 50%; transform: translateX(-50%);
      z-index: 1000;
      display: none;
      pointer-events: none;
    }
    #comboEffect { top: 20%; font-size: 40px; font-weight: 900; color: #ffe24f; text-shadow: 3px 3px #8b4f26; }
    #correctEffect { top: 40%; font-size: 48px; font-weight: 900; color: #00ffcc; text-shadow: 3px 3px #006644; }

    .modal-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      justify-content: center; align-items: center;
      padding: 16px;
      z-index: 20000; 
    }
    .modal-box {
      width: 90%; max-width: 420px;
      background: var(--panel-bg);
      border-radius: 14px;
      border: 4px solid #3a2513;
      padding: 28px 24px;
      box-shadow: 0 0 0 4px #fff, 0 10px 0 #b79b76;
      text-align: center;
    }
    .modal-title { font-size: 28px; font-weight: 800; margin-bottom: 18px; }
    .modal-desc { font-size: 17px; margin-bottom: 22px; line-height: 1.45; white-space: pre-line; }
    
    .choice-btn, .action-btn, .start-btn {
      width: 100%; padding: 14px; margin: 8px 0;
      background: var(--accent); border: 0; border-radius: 10px;
      color: #fff; font-size: 18px; font-weight: 700;
      box-shadow: 0 4px 0 var(--accent-dark); cursor: pointer;
    }
    .choice-btn:active, .action-btn:active, .start-btn:active {
      transform: translateY(2px); box-shadow: 0 2px 0 var(--accent-dark);
    }
    .action-btn:disabled { background: #999; cursor: not-allowed; box-shadow: none; }
    
    .modal-input {
      width: 85%; max-width: 320px;
      padding: 12px; font-size: 16px;
      border-radius: 8px; border: 2px solid #b8a792;
      margin: 8px auto 18px; display: block;
    }

    #loadingQuiz {
      display: none; position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      justify-content: center; align-items: center;
      color: #fff; font-size: 22px; font-weight: 700;
      backdrop-filter: blur(2px); z-index: 20001;
    }
  </style>
</head>

<body>
<div id="gameArea">
  <div id="startGuide" class="modal-bg" style="display:flex;">
    <div class="modal-box">
      <div class="modal-title">ê²Œì„ ë°©ë²• / How to Play</div>
      <div class="modal-desc" style="text-align:left; font-size:15px;">
â€¢ <b>Space</b> ë˜ëŠ” í™”ë©´ í„°ì¹˜ë¡œ ì í”„
â€¢ ì¥ì• ë¬¼ì„ í”¼í•´ <b>ì‹ ì•™ ì ìˆ˜(Faith)</b> íšë“
â€¢ ìƒì ì—ì„œ ë¯¼ì²©/ìƒëª…ë ¥/ëœë¤ ë½‘ê¸° êµí™˜

[ì•„ì´í…œ íš¨ê³¼]
âœï¸ <b>ì‹­ìê°€:</b> ë¬´ì  (ê¸°ë³¸ 10ì´ˆ + ê°•í™”)
ğŸ•Šï¸ <b>ë‚ ê°œ:</b> í„°ë³´ ëª¨ë“œ (ê¸°ë³¸ 5ì´ˆ + ê°•í™”)
ğŸƒ <b>ë°”ëŒ:</b> ì†ë„ ê°ì†Œ (ê¸°ë³¸ 10ì´ˆ + ê°•í™”)
ğŸ“˜ <b>ì„±ê²½:</b> Faith +10
      </div>
      <button class="start-btn" onclick="startGameNow()">â–¶ ì‹œì‘í•˜ê¸° / Start</button>
    </div>
  </div>

  <div id="bgLayer1"></div>
  <div id="bgLayer2"></div>
  <div id="bgLayer3"></div>

  <div id="speedLines"></div>

  <div id="ground"></div>
  <div id="player"></div>

  <div id="hud">
    â¤ï¸ <span id="lifeText"></span>
    ğŸ“ <span id="distanceText">0m</span>
    âœ <span id="faithText"></span>
  </div>
</div>

<div id="buffArea"></div>

<div id="comboEffect">COMBO +1!</div>
<div id="correctEffect">+5 Faith!</div>

<div id="quizModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">ì„±ê²½ í€´ì¦ˆ</div>
    <div class="modal-desc" id="quizQuestion"></div>
    <button class="choice-btn" onclick="answerQuiz('A')" id="btnA"></button>
    <button class="choice-btn" onclick="answerQuiz('B')" id="btnB"></button>
    <button class="choice-btn" onclick="answerQuiz('C')" id="btnC"></button>
  </div>
</div>

<div id="gameOverModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">GAME OVER</div>
    <div class="modal-desc">
      <b><span id="finalDist"></span>m</b> ë‹¬ë ¸ìŠµë‹ˆë‹¤!
    </div>
    <input id="rankMsg" class="modal-input" type="text" placeholder="ì†Œê° ì…ë ¥(ì„ íƒ)" />
    
    <button class="action-btn" style="background:#5d4037;" onclick="location.reload()">ğŸ”„ ë‹¤ì‹œí•˜ê¸°</button>
    <button class="action-btn" onclick="confirmRanking()">[ìˆœìœ„ë“±ë¡]</button>
  </div>
</div>

<div id="loadingQuiz">â³ ì„±ê²½ ë¬¸ì œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>

<script>
  const API_URL = "https://script.google.com/macros/s/AKfycbzA10H2TuXRDXBXcttvHHR0Q1sOu8zGpYmrdGhfH-wBsl623k2ydwUkwL7wR8F90mC5Pg/exec";

  let id = localStorage.getItem("run_id");
  let name = localStorage.getItem("run_name");
  let saveData = JSON.parse(localStorage.getItem("run_save") || "{}");

  if (!id) {
    alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
    window.location.href = "/TrapGame/index.html";
  }

  let daily = JSON.parse(localStorage.getItem("dailyMission") || "{}");
  function initDailyMission() {
    return { date: new Date().toDateString(), run200: false, quiz3: 0, faith20: 0 };
  }
  if (!daily.date || daily.date !== new Date().toDateString()) {
    daily = initDailyMission();
    localStorage.setItem("dailyMission", JSON.stringify(daily));
  }

  /* ------------ ì—…ê·¸ë ˆì´ë“œ ë ˆë²¨ ë¶ˆëŸ¬ì˜¤ê¸° ------------ */
  let life  = 3 + (saveData.extraLife || 0);
  let faith = saveData.faith || 0;
  
  // ì¶”ê°€ëœ ì—…ê·¸ë ˆì´ë“œ ìŠ¤íƒ¯ ë¡œë”©
  let lvlInvincible = saveData.up_invincible || 0;
  let lvlTurbo      = saveData.up_turbo || 0;
  let lvlSlow       = saveData.up_slow || 0;

  document.getElementById("lifeText").innerText  = life;
  document.getElementById("faithText").innerText = faith;

  const gameArea = document.getElementById("gameArea");
  const player   = document.getElementById("player");
  
  const bg1 = document.getElementById("bgLayer1");
  const bg2 = document.getElementById("bgLayer2");
  const bg3 = document.getElementById("bgLayer3");

  let buffArea = document.getElementById("buffArea");
  if (!buffArea) {
    buffArea = document.createElement("div");
    buffArea.id = "buffArea";
    document.body.appendChild(buffArea);
  }

  let speedLines = document.getElementById("speedLines");
  if (!speedLines) {
    speedLines = document.createElement("div");
    speedLines.id = "speedLines";
    gameArea.insertBefore(speedLines, document.getElementById("player"));
  }

  let playerY  = 40;
  let velocity = 0;
  let gravity  = -0.25; 

  let agility   = saveData.agility || 0;
  let jumpPower = 6.5 - agility * 0.05;
  jumpPower     = Math.max(3, jumpPower);

  let distance  = 0;
  let obstacles = [];
  let meteors   = [];
  let running   = false;
  let invincible = false;

  const BASE_SPEED = 170; 
  let gameSpeed    = BASE_SPEED;

  let lastTime            = performance.now();
  let quizTimer           = 0;
  let nextFaithMilestone  = 100;

  let obstacleTimer   = 0;
  let nextObstacleTime = 2.0;
  
  let meteorTimer     = 0; 
  let nextMeteorTime  = 4.0; 

  let bg1X = 0, bg2X = 0, bg3X = 0;
  const BG1_SPEED = 20; const BG2_SPEED = 40; const BG3_SPEED = 60;

  let items        = [];
  let itemTimer    = 0;
  let nextItemTime = 8;

  let combo = 0;
  let obstacleSurviveCount = 0;
  let rankingSaved = false;

  let activeEffects = { turbo: 0, invincible: 0, slow: 0 };

  function randBetween(min, max) { return Math.random() * (max - min) + min; }

  function jump() {
    if (!running || activeEffects.turbo > 0) return;
    velocity = jumpPower;
  }
  document.body.addEventListener("keydown", e => {
    if (e.code === "Space" || e.code === "ArrowUp") { e.preventDefault(); jump(); }
  });
  document.body.addEventListener("touchstart", jump);

  function scheduleNextObstacle(speedMultiplier) {
    if (activeEffects.turbo > 0) return;
    let baseTime = randBetween(1.8, 2.6);
    nextObstacleTime = baseTime / (1 + (speedMultiplier - 1) * 0.6); 
    if (nextObstacleTime < 0.2) nextObstacleTime = 0.2;
  }

  function spawnObstacle() {
    if (!running) return;
    if (activeEffects.turbo > 0) return;

    const randi = (min, max) => Math.floor(Math.random() * (max - min)) + min;
    let pattern;
    
    // 100m ì´ìƒì¼ ë•Œ ê°€ë¡œ ì¥ì• ë¬¼(Bar) 20% í™•ë¥  ë“±ì¥
    let spawnHorizontal = (distance > 100) && (Math.random() < 0.20);

    if (spawnHorizontal) {
        const box = document.createElement("div");
        box.classList.add("obstacle", "obs-long");
        const isFlying = Math.random() < 0.5;
        box.style.left = (window.innerWidth + 80) + "px";
        box.style.bottom = isFlying ? "50px" : "0px"; 
        gameArea.appendChild(box);
        obstacles.push(box);
        return;
    }

    const useGroundBox = Math.random() < 0.5;
    const obsTypeClass = (Math.random() < 0.5) ? 'obs-log' : 'obs-rock';

    if (useGroundBox) {
      pattern = { groundBox: true, height: randi(90, 220) };
    } else {
      pattern = { groundBox: false, top: randi(120, 260), gap: randi(160, 220) };
    }

    const startX  = window.innerWidth + 80;

    if (pattern.groundBox) {
      const box = document.createElement("div");
      box.classList.add("obstacle", "obs-cap", "obs-ground", obsTypeClass);
      box.style.height = pattern.height + "px";
      box.style.left = startX + "px";
      box.style.bottom = "0";
      gameArea.appendChild(box);
      obstacles.push(box);
      return;
    }

    const topHeight = pattern.top;
    const gap = pattern.gap;
    const screenH = window.innerHeight;
    const bottomHeight = Math.max(80, screenH - topHeight - gap);

    const topObs = document.createElement("div");
    topObs.classList.add("obstacle", "obs-cap", "obs-ceil", obsTypeClass);
    topObs.style.height = topHeight + "px";
    topObs.style.left = startX + "px";
    topObs.style.top = "0";
    gameArea.appendChild(topObs);

    const bottomObs = document.createElement("div");
    bottomObs.classList.add("obstacle", "obs-cap", "obs-ground", obsTypeClass);
    bottomObs.style.height = bottomHeight + "px";
    bottomObs.style.left = startX + "px";
    bottomObs.style.bottom = "0";
    gameArea.appendChild(bottomObs);
    obstacles.push(topObs, bottomObs);
  }

  function spawnMeteor(speedMultiplier) {
    const meteor = document.createElement("div");
    meteor.classList.add("meteor");
    const startX = window.innerWidth + Math.random() * 200;
    const startY = -100; 
    meteor.style.left = startX + "px";
    meteor.style.top = startY + "px";
    meteor.dataset.x = startX;
    meteor.dataset.y = startY;
    meteor.dataset.speed = 150 * speedMultiplier; 
    gameArea.appendChild(meteor);
    meteors.push(meteor);
  }

  function spawnItem() {
    const types = ["cross", "wings", "wind", "bible"];
    const type  = types[Math.floor(Math.random() * types.length)];
    const item  = document.createElement("div");
    item.classList.add("item");
    item.dataset.type = type;
    item.style.left   = window.innerWidth + "px";
    item.style.bottom = (Math.random() * 250 + 120) + "px";
    item.style.backgroundImage = `url('https://antiochapp.github.io/TrapGame/item_${type}.png')`;
    gameArea.appendChild(item);
    items.push(item);
  }

  function showFloatText(text) {
    const rect = player.getBoundingClientRect();
    const el = document.createElement("div");
    el.classList.add("float-text");
    el.innerText = text;
    el.style.left = (rect.left + 10) + "px";
    el.style.top  = (rect.top - 20) + "px";
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1000);
  }

  /* ------------ [ìˆ˜ì •ë¨] ì•„ì´í…œ íš¨ê³¼ (ì—…ê·¸ë ˆì´ë“œ ë°˜ì˜) ------------ */
  function activateItem(type) {
    if (type === "cross") {
      // ê¸°ë³¸ 10ì´ˆ + ë ˆë²¨ë‹¹ 1ì´ˆ
      let duration = 10 + lvlInvincible;
      activeEffects.invincible = duration; 
      showFloatText(`ğŸ›¡ï¸ ë¬´ì ! (${duration}s)`);
    } else if (type === "wings") {
      // ê¸°ë³¸ 5ì´ˆ + ë ˆë²¨ë‹¹ 1ì´ˆ
      let duration = 5 + lvlTurbo;
      activeEffects.turbo = duration; 
      showFloatText(`ğŸš€ í„°ë³´ ëª¨ë“œ! (${duration}s)`);
    } else if (type === "wind") {
      // ê¸°ë³¸ 10ì´ˆ + ë ˆë²¨ë‹¹ 1ì´ˆ
      let duration = 10 + lvlSlow;
      activeEffects.slow = duration; 
      showFloatText(`ğŸƒ ì†ë„ ê°ì†Œ (${duration}s)`);
    } else if (type === "bible") {
      faith += 10; saveData.faith = faith; document.getElementById("faithText").innerText = faith;
      showFloatText("âœ Faith +10"); saveProgress();
    }
  }

  function updateBuffUI(delta) {
    if (activeEffects.turbo > 0) activeEffects.turbo -= delta;
    if (activeEffects.invincible > 0) activeEffects.invincible -= delta;
    if (activeEffects.slow > 0) activeEffects.slow -= delta;

    let html = "";
    if (activeEffects.turbo > 0) html += `<div class="buff-tag" style="color:#00ffff; border-color:#00ffff">ğŸš€ í„°ë³´ ëª¨ë“œ: ${Math.ceil(activeEffects.turbo)}s</div>`;
    if (activeEffects.invincible > 0) html += `<div class="buff-tag" style="color:#ffe24f; border-color:#ffe24f">ğŸ›¡ï¸ ë¬´ì  ìƒíƒœ: ${Math.ceil(activeEffects.invincible)}s</div>`;
    if (activeEffects.slow > 0) html += `<div class="buff-tag" style="color:#aaffaa; border-color:#aaffaa">ğŸƒ ì†ë„ ê°ì†Œ: ${Math.ceil(activeEffects.slow)}s</div>`;
    
    if(buffArea) buffArea.innerHTML = html;
  }

  function gameLoop(now) {
    if (!running) return;
    const delta = (now - lastTime) / 1000;
    lastTime = now;

    try { updateBuffUI(delta); } catch(e) {}

    if (!daily.run200 && distance >= 200) daily.run200 = true;
    daily.faith20 = faith;
    localStorage.setItem("dailyMission", JSON.stringify(daily));

    let distMultiplier = (activeEffects.turbo > 0) ? 4 : 1;
    distance += delta * 1 * distMultiplier;
    document.getElementById("distanceText").innerText = Math.floor(distance) + "m";

    /* ------------ ê±°ë¦¬ ë¹„ë¡€ ì†ë„ (3000m -> 15ë°°) ------------ */
    let progress = Math.min(distance / 3000, 1);
    let speedMultiplier = 1 + (progress * 14); 
    
    let currentSpeed = BASE_SPEED * speedMultiplier;

    if (activeEffects.slow > 0) currentSpeed *= 0.5;
    if (activeEffects.turbo > 0) currentSpeed *= 2.0; 

    gameSpeed = currentSpeed;

    if (distance >= nextFaithMilestone) {
      faith++; saveData.faith = faith; nextFaithMilestone += 100;
      document.getElementById("faithText").innerText = faith; saveProgress();
    }

    quizTimer += delta;
    const quizSoon = (quizTimer >= 27 && quizTimer < 30);
    if (!quizSoon) {
      obstacleTimer += delta;
      if (obstacleTimer >= nextObstacleTime) {
        spawnObstacle(); 
        obstacleTimer = 0; 
        scheduleNextObstacle(speedMultiplier); 
      }
    }

    if (distance > 200 && activeEffects.turbo <= 0) {
        meteorTimer += delta;
        let meteorSpawnRate = 3.0 / speedMultiplier;
        if (meteorSpawnRate < 0.2) meteorSpawnRate = 0.2;
        if (meteorTimer > meteorSpawnRate) {
            spawnMeteor(speedMultiplier);
            meteorTimer = 0;
        }
    }

    for (let i = meteors.length - 1; i >= 0; i--) {
        let m = meteors[i];
        let x = parseFloat(m.dataset.x);
        let y = parseFloat(m.dataset.y);
        let mSpeed = parseFloat(m.dataset.speed);

        x -= mSpeed * delta * 0.8; 
        y += mSpeed * delta * 1.0; 

        m.style.left = x + "px";
        m.style.top = y + "px";
        m.dataset.x = x;
        m.dataset.y = y;

        if (x < -100 || y > window.innerHeight + 100) {
            m.remove(); meteors.splice(i, 1); continue;
        }

        if (!activeEffects.invincible && !invincible) {
            const rectP = player.getBoundingClientRect();
            const rectM = m.getBoundingClientRect();
            const buffer = 15;
            if (
                rectP.left + buffer < rectM.right - buffer &&
                rectP.right - buffer > rectM.left + buffer &&
                rectP.top + buffer < rectM.bottom - buffer &&
                rectP.bottom - buffer > rectM.top + buffer
            ) {
                damageLife();
                m.remove(); meteors.splice(i, 1);
            }
        }
    }

    if (activeEffects.turbo > 0) {
      let targetY = 200; playerY += (targetY - playerY) * 0.1; velocity = 0;
      if(speedLines) speedLines.style.display = "block";
    } else {
      velocity += gravity; playerY += velocity;
      if(speedLines) speedLines.style.display = "none";
    }

    if (playerY < 0) playerY = 0;
    if (playerY > window.innerHeight - 110) playerY = window.innerHeight - 110;
    player.style.bottom = playerY + "px";

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs  = obstacles[i];
      let left   = parseFloat(obs.style.left) || 0;
      left      -= gameSpeed * delta;
      obs.style.left = left + "px";

      if (left + 60 < 0) {
        obs.remove(); obstacles.splice(i, 1);
        obstacleSurviveCount++;
        if (obstacleSurviveCount >= 5) {
          combo++; faith++; saveData.faith = faith;
          document.getElementById("faithText").innerText = faith;
          const ce = document.getElementById("comboEffect");
          ce.style.display = "block"; ce.innerText = `COMBO +${combo}!`;
          setTimeout(() => ce.style.display = "none", 1000);
          obstacleSurviveCount = 0; saveProgress();
        }
        continue;
      }

      if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible) continue;

      const rectP = player.getBoundingClientRect();
      const rectO = obs.getBoundingClientRect();
      const buffer = 10;
      if (
        rectP.left + buffer < rectO.right - buffer &&
        rectP.right - buffer > rectO.left + buffer &&
        rectP.top + buffer < rectO.bottom - buffer &&
        rectP.bottom - buffer > rectO.top + buffer
      ) {
        damageLife(); break;
      }
    }

    itemTimer += delta;
    if (itemTimer >= nextItemTime) {
      spawnItem(); nextItemTime = Math.random() * 6 + 6; itemTimer = 0;
    }

    for (let i = items.length - 1; i >= 0; i--) {
      let it   = items[i];
      let left = parseFloat(it.style.left) || 0;
      left    -= gameSpeed * delta;
      it.style.left = left + "px";
      if (left < -60) { it.remove(); items.splice(i, 1); continue; }
      const rectP = player.getBoundingClientRect();
      const rectI = it.getBoundingClientRect();
      if (
        rectP.left < rectI.right && rectP.right > rectI.left &&
        rectP.top < rectI.bottom && rectP.bottom > rectI.top
      ) {
        activateItem(it.dataset.type); it.remove(); items.splice(i, 1); continue;
      }
    }

    let speedMult = (gameSpeed / BASE_SPEED); 
    bg1X -= BG1_SPEED * speedMult * delta;
    bg2X -= BG2_SPEED * speedMult * delta;
    bg3X -= BG3_SPEED * speedMult * delta;

    bg1.style.backgroundPosition = `${bg1X}px 0`;
    bg2.style.backgroundPosition = `${bg2X}px bottom`;
    bg3.style.backgroundPosition = `${bg3X}px bottom`;

    if (quizTimer >= 30) { quizTimer = 0; pauseForQuiz(); return; }
    requestAnimationFrame(gameLoop);
  }

  function damageLife() {
    if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible || !running) return;
    life--; document.getElementById("lifeText").innerText = life;
    invincible = true; player.style.opacity = "0.4";
    setTimeout(() => { invincible = false; player.style.opacity = "1"; }, 800);
    if (life <= 0) gameOver();
  }

  async function pauseForQuiz() {
    if (!running) return;
    running = false; document.getElementById("loadingQuiz").style.display = "flex";
    try {
      const res = await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "getQuiz" }) });
      const txt = await res.text();
      document.getElementById("loadingQuiz").style.display = "none";
      if (txt === "noquiz") { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); return; }
      const quiz = JSON.parse(txt);
      document.getElementById("quizQuestion").innerText = quiz.question;
      document.getElementById("btnA").innerText = "A) " + quiz.A;
      document.getElementById("btnB").innerText = "B) " + quiz.B;
      document.getElementById("btnC").innerText = "C) " + quiz.C;
      window.correctAnswer = quiz.answer;
      document.getElementById("quizModal").style.display = "flex";
    } catch (err) {
      document.getElementById("loadingQuiz").style.display = "none";
      running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
    }
  }

  function answerQuiz(sel) {
    document.getElementById("quizModal").style.display = "none";
    if (sel === window.correctAnswer) {
      const ef = document.getElementById("correctEffect");
      ef.style.display = "block"; setTimeout(() => (ef.style.display = "none"), 800);
      faith += 5; saveData.faith = faith; document.getElementById("faithText").innerText = faith;
      daily.quiz3++; localStorage.setItem("dailyMission", JSON.stringify(daily)); saveProgress();
    } else { damageLife(); }
    if (life > 0) { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); }
  }

  async function saveProgress() {
    try { await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "save", id, saveData }) }); } catch (e) {}
    localStorage.setItem("run_save", JSON.stringify(saveData));
  }

  function startGameNow() {
    document.getElementById("startGuide").style.display = "none";
    running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
  }

  async function gameOver() {
    if (rankingSaved) return;
    running = false; invincible = true; player.style.opacity = "0.4";
    const dist = Math.floor(distance);
    document.getElementById("finalDist").innerText = dist;
    document.getElementById("gameOverModal").style.display = "flex";
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateRanking", id, name, distance: dist, message: "" })
      });
    } catch (e) {}
    rankingSaved = true;
  }

  async function confirmRanking() {
    const btn = document.querySelector(".action-btn:last-child");
    const msgInput = document.getElementById("rankMsg");
    const msg = msgInput.value.trim();
    if (!msg) { window.location.href = "/TrapGame/menu.html"; return; }
    btn.innerText = "ì „ì†¡ ì¤‘..."; btn.disabled = true;
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateComment", id: id, message: msg })
      });
      alert("ì†Œê°ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!"); window.location.href = "/TrapGame/menu.html";
    } catch (e) {
      alert("ì „ì†¡ ì˜¤ë¥˜ê°€ ë‚¬ì§€ë§Œ ë©”ë‰´ë¡œ ì´ë™í•©ë‹ˆë‹¤."); window.location.href = "/TrapGame/menu.html";
    }
  }

  let lastTouch = 0;
  document.addEventListener("touchend", e => {
    const now = Date.now(); if (now - lastTouch < 300) e.preventDefault(); lastTouch = now;
  }, { passive: false });
</script>
</body>
</html>
