<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Disciple Run ‚Äì Ultimate Boss Ver</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    :root { --hud-bg: rgba(255, 248, 235, 0.9); --hud-border: #3a2513; --accent: #c47a3f; --panel-bg: #fdfaf2; }
    * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; touch-action: none; font-family: "Pretendard", sans-serif; }
    
    /* Î∞∞Í≤ΩÏùÄ Ïñ¥Îë°Í≤å, Ï§ëÏïô Ï†ïÎ†¨ */
    body { 
        background-color: #222; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
    }

    /* Í≤åÏûÑ ÌôîÎ©¥ ÏÑ§Ï†ï */
    #gameArea {
        position: relative;
        overflow: hidden;
        background: linear-gradient(#88c6ff 0%, #b7e3ff 45%, #f7f0d9 45%, #f0e0b0 100%);
        transition: filter 0.5s;
        box-shadow: 0 0 50px rgba(0,0,0,0.5);
        width: 100%;
        height: 100%;
        border: none;
    }

    /* PC ÌôòÍ≤Ω ÏïàÏ†ÑÏû•Ïπò */
    @media (min-width: 600px) {
        #gameArea {
            width: 450px !important;
            height: 800px !important;
            margin: auto;
            border: 4px solid #333;
            transform-origin: center center; 
        }
    }
    
    /* ÌïòÌúò Ïä§ÌÇ¨ Î∞∞Í≤Ω */
    #gameArea.sand-bg { 
        background-image: url('Sand.png') !important; 
        background-repeat: repeat-x !important; 
        background-size: auto 100% !important; 
        background-position: 0 0; 
    }
    #gameArea.sand-bg .bg-layer { opacity: 0; transition: opacity 0.5s; }

    /* ÌôîÎ©¥ Ìö®Í≥º */
    #gameArea.fever-mode { filter: sepia(40%) saturate(180%) hue-rotate(-5deg); }
    #gameArea.sandstorm-mode { filter: sepia(80%) brightness(0.9); }
    
    #gameArea.shake-screen { animation: screenShake 0.2s infinite; }
    @keyframes screenShake { 0% { transform: translate(0, 0); } 25% { transform: translate(-5px, 5px); } 50% { transform: translate(5px, -5px); } 75% { transform: translate(-5px, -5px); } 100% { transform: translate(0, 0); } }

    #gameArea.gentle-shake { animation: gentleShake 0.15s infinite; }
    @keyframes gentleShake { 
        0% { transform: translate(0, 0); } 
        25% { transform: translate(-4px, 4px); } 
        50% { transform: translate(4px, -4px); } 
        75% { transform: translate(-4px, -4px); } 
        100% { transform: translate(0, 0); } 
    }

    #flashEffect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 200; transition: opacity 0.1s; }

    .zigzag-lightning { position: absolute; z-index: 89; pointer-events: none; filter: drop-shadow(0 0 10px yellow); stroke: #fff; stroke-width: 4; fill: none; opacity: 0; animation: flashLightning 0.3s forwards; }
    @keyframes flashLightning { 0% { opacity: 1; } 50% { opacity: 1; } 100% { opacity: 0; } }

    .hammer-skill { position: absolute; width: 400px; height: 400px; background: url('Hammer.png') no-repeat center/contain; z-index: 45; pointer-events: none; filter: drop-shadow(0 0 20px gold); }

    .music-note { position: absolute; font-size: 40px; font-weight: bold; z-index: 65; pointer-events: none; text-shadow: 2px 2px 0 #fff; animation: noteFloat 1s infinite ease-in-out alternate; }
    @keyframes noteFloat { from { transform: translateY(0); } to { transform: translateY(-15px); } }
    .jieun-wave-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(90deg, rgba(255,0,150,0.2), rgba(0,204,255,0.2)); z-index: 4; pointer-events: none; opacity: 0; transition: opacity 1s; }

    .noel-aura { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 140px; height: 140px; border-radius: 50%; background: radial-gradient(circle, rgba(255,215,0,0.4), transparent 70%); box-shadow: 0 0 50px gold; z-index: 49; pointer-events: none; animation: auraPulse 0.5s infinite alternate; }
    @keyframes auraPulse { from { transform: translate(-50%, -50%) scale(1); opacity: 0.6; } to { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } }

    .jihye-healer { position: absolute; width: 70px; height: 70px; background-image: url('Skill_JHA.png'); background-size: contain; background-repeat: no-repeat; z-index: 60; pointer-events: none; transition: left 1.5s ease-out, top 1.5s ease-out; filter: drop-shadow(0 0 15px gold); }
    .holy-light-pillar { position: absolute; width: 100px; height: 100vh; background: linear-gradient(to bottom, transparent, rgba(255, 255, 200, 0.6), transparent); bottom: 0; transform: translateX(-50%); z-index: 59; pointer-events: none; animation: lightPillar 2.0s ease-out forwards; }
    @keyframes lightPillar { 0% { opacity: 0; width: 0; } 20% { opacity: 1; width: 120px; } 80% { opacity: 1; width: 120px; } 100% { opacity: 0; width: 0; } }

    .infinity-stone { position: absolute; width: 24px; height: 24px; border-radius: 50%; box-shadow: 0 0 15px currentColor; z-index: 65; pointer-events: none; border: 2px solid white; }
    .sandstorm-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: url('noise.png'); background-color: rgba(194, 178, 128, 0.3); z-index: 85; pointer-events: none; opacity: 0; transition: opacity 0.5s; animation: sandMove 0.2s infinite linear; }
    @keyframes sandMove { 0% { background-position: 0 0; } 100% { background-position: 100px 50px; } }
    .dust-effect { position: absolute; width: 60px; height: 60px; background: radial-gradient(circle, #d2b48c, transparent); opacity: 0.8; border-radius: 50%; z-index: 80; animation: turnToDust 0.6s ease-out forwards; }
    @keyframes turnToDust { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(2) translateY(-20px); opacity: 0; } }

    .real-portal { position: absolute; width: 160px; height: 160px; background: radial-gradient(circle, #000, #4b0082, #00ffff); border-radius: 50%; border: 4px solid #fff; box-shadow: 0 0 40px #00ffff, inset 0 0 60px #000; z-index: 45; transform: translate(-50%, -50%) scale(0); }
    .portal-opening { animation: pOpen 0.5s forwards; }
    .portal-closing { animation: pClose 0.5s forwards; }
    @keyframes pOpen { 0% { transform: translate(-50%, -50%) scale(0); } 100% { transform: translate(-50%, -50%) scale(1); } }
    @keyframes pClose { 0% { transform: translate(-50%, -50%) scale(1); } 100% { transform: translate(-50%, -50%) scale(0); } }

    #timeTunnelBg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2900; pointer-events: none; opacity: 0; transition: opacity 0.5s; display: none; }
    .tunnel-star { position: absolute; width: 100px; height: 2px; background: #fff; box-shadow: 0 0 10px #fff; animation: warpSpeed 0.5s linear infinite; }
    @keyframes warpSpeed { from { transform: translateX(100vw); } to { transform: translateX(-100vw); } }

    #junMiniGameUI { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; flex-direction: column; justify-content: center; align-items: center; color: #fff; text-align: center; }
    .warp-btn { width: 120px; height: 120px; border-radius: 50%; background: #00ffff; color: #000; font-weight: 900; font-size: 24px; border: 5px solid #fff; box-shadow: 0 0 20px #00ffff; margin-top: 30px; display: flex; justify-content: center; align-items: center; animation: pulseBtn 0.2s infinite alternate; cursor: pointer; }
    @keyframes pulseBtn { from { transform: scale(1); } to { transform: scale(1.05); } }

    .funnel-unit { position: absolute; width: 40px; height: 40px; background: url('Panel.png') no-repeat center/contain; z-index: 60; pointer-events: none; }
    .funnel-laser { position: absolute; height: 6px; background: #ff00ff; box-shadow: 0 0 10px #ff00ff; z-index: 58; transform-origin: left center; opacity: 0; pointer-events: none; }
    .gundam-aura { position: absolute; width: 140px; height: 140px; background: radial-gradient(circle, rgba(0,100,255,0.9), rgba(0,255,255,0.4), transparent 70%); border-radius: 50%; box-shadow: 0 0 50px #0000ff, inset 0 0 20px #fff; z-index: 65; pointer-events: none; transform: translate(-50%, -50%); mix-blend-mode: screen; animation: gundamPulse 0.5s infinite alternate; opacity: 0.9; }
    @keyframes gundamPulse { from { opacity: 0.7; transform: translate(-50%, -50%) scale(1); } to { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } }

    .yejun-clone { position: absolute; width: 50px; height: 50px; background-image: url('skin_yejun.png'); background-size: contain; background-repeat: no-repeat; opacity: 0.8; z-index: 49; filter: hue-rotate(180deg) brightness(1.2); }
    .yejun-wing { position: absolute; width: 100px; height: 100px; background: url('Wings.png') no-repeat center/contain; left: -20px; top: -20px; opacity: 0.8; mix-blend-mode: screen; pointer-events: none; }

    .cake-item { position: absolute; width: 60px; height: 60px; background-size: contain; background-repeat: no-repeat; z-index: 88; filter: drop-shadow(0 5px 5px rgba(0,0,0,0.3)); }
    .heart-emit { position: absolute; font-size: 30px; color: #ff69b4; font-weight: bold; animation: heartFloat 1s forwards; z-index: 99; }
    @keyframes heartFloat { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
    .cake-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: url('CakeBack.png') repeat; opacity: 0; pointer-events: none; z-index: 5; transition: opacity 1s; }

    .jihye-transform-sphere { position: absolute; width: 100px; height: 100px; border-radius: 50%; background: radial-gradient(circle at center, #fff 20%, #ffd700 80%); box-shadow: 0 0 30px #ffd700, 0 0 60px #fff, inset 0 0 20px #fff; z-index: 52; transform: translate(-50%, -50%); animation: sphereCharge 2s ease-in forwards; mix-blend-mode: screen; }
    @keyframes sphereCharge { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 20% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; } 80% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; filter: brightness(2); } 100% { transform: translate(-50%, -50%) scale(3); opacity: 0; } }
    .jihye-unit { position: absolute; width: 50px; height: 50px; background-size: contain; background-repeat: no-repeat; z-index: 55; filter: drop-shadow(0 0 10px cyan); }
    .jihye-missile { position: absolute; width: 24px; height: 24px; background: radial-gradient(circle, #fff, #00b0ff); border-radius: 50%; box-shadow: 0 0 10px #00b0ff; z-index: 66; }

    .bg-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-repeat: repeat-x; }
    #bgLayer1 { background-image: url("bg_sky.png"); z-index: 1; background-size: auto 100%; background-position: 0 bottom; }
    #bgLayer2 { background-image: url("bg_mountain.png"); z-index: 2; background-size: auto 60%; background-position: 0 bottom; }
    #bgLayer3 { background-image: url("bg_forest.png"); z-index: 3; background-size: auto 40%; background-position: 0 bottom; }
    
    .flying-noel { position: absolute; width: 80px; height: 80px; background-image: url('skin_noel.png'); background-size: contain; background-repeat: no-repeat; z-index: 60; pointer-events: none; }
    
    .jieun-shield { position: absolute; width: 90px; height: 90px; left: -15px; bottom: -15px; border-right: 8px solid rgba(255, 255, 255, 0.8); border-radius: 50%; box-shadow: 0 0 20px rgba(255, 255, 255, 0.6); background: linear-gradient(90deg, transparent 50%, rgba(255,255,255,0.2) 100%); pointer-events: none; z-index: 55; }
    .haeun-shield { position: absolute; width: 80px; height: 80px; left: -10px; bottom: -10px; border-right: 6px solid rgba(255, 255, 255, 0.9); border-radius: 50%; box-shadow: 15px 0 20px rgba(255, 255, 255, 0.5); pointer-events: none; z-index: 55; animation: shieldBreath 2s infinite ease-in-out; }
    @keyframes shieldBreath { 0% { opacity: 0.6; transform: scale(1); } 50% { opacity: 1; transform: scale(1.05); } 100% { opacity: 0.6; transform: scale(1); } }
    
    .heal-effect-visual { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background: radial-gradient(circle, rgba(255,50,50,0) 20%, rgba(255,0,0,0.6) 60%, transparent 100%); border: 2px solid rgba(255, 100, 100, 0.8); border-radius: 50%; animation: healExpand 0.6s ease-out forwards; z-index: 95; pointer-events: none; }
    @keyframes healExpand { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2.0); opacity: 0; } }

    .noel-beam { position: absolute; left: 170px; height: 140px; width: 0; background: radial-gradient(ellipse at left, rgba(255,255,255,1) 0%, rgba(0,255,255,0.8) 30%, rgba(0,100,255,0) 80%); z-index: 89; transform-origin: left center; pointer-events: none; animation: beamFire 0.4s ease-out forwards; mix-blend-mode: screen; box-shadow: 0 0 40px cyan, 0 0 20px white; border-radius: 100px 0 0 100px; }
    .noel-beam::before { content: ''; position: absolute; left: -20px; top: 50%; transform: translateY(-50%); width: 80px; height: 80px; background: radial-gradient(circle, #fff 20%, #00ffff 80%, transparent 100%); border-radius: 50%; box-shadow: 0 0 50px #fff; opacity: 0.9; }
    @keyframes beamFire { 0% { width: 0; opacity: 0.5; transform: scaleY(0.1); } 20% { width: 50vw; opacity: 1; transform: scaleY(1.2); } 100% { width: 150vw; opacity: 0.8; transform: scaleY(1); } }

    #ground { display: none; }
    
    #player { position: absolute; z-index: 50; left: 50px; bottom: 40px; width: 60px; height: 60px; background-image: url("disciple.png"); background-position: center; background-size: contain; background-repeat: no-repeat; image-rendering: pixelated; transition: opacity 0.2s, transform 0.3s; filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.2)); }
    #player.fever-active { transform: scale(1.3); filter: drop-shadow(0 0 20px gold); }

    .obstacle { position: absolute; z-index: 40; background-size: 8px 8px; box-shadow: 4px 4px 0 rgba(0,0,0,0.2); }
    .obs-cap::after { content: ''; position: absolute; left: -10%; width: 120%; height: 24px; border-radius: 4px; }
    .obs-ground.obs-cap::after { top: -12px; } .obs-ceil.obs-cap::after { bottom: -12px; }
    .obs-log { width: 60px; background-color: #8D6E63; border-left: 4px solid #5D4037; border-right: 4px solid #5D4037; background-image: linear-gradient(90deg, rgba(0,0,0,0.05) 50%, transparent 50%); }
    .obs-log.obs-cap::after { background-color: #66BB6A; border: 4px solid #1B5E20; }
    .obs-rock { width: 60px; background-color: #9E9E9E; border-left: 4px solid #616161; border-right: 4px solid #616161; background-image: radial-gradient(circle, rgba(0,0,0,0.1) 20%, transparent 20%); }
    .obs-rock.obs-cap::after { background-color: #BDBDBD; border: 4px solid #424242; }
    .obs-long { width: 240px; height: 35px; background-color: #5D4037; background-image: linear-gradient(0deg, rgba(0,0,0,0.2) 50%, transparent 50%); border: 3px solid #3E2723; border-radius: 8px; box-shadow: 0 5px 5px rgba(0,0,0,0.3); }
    
    /* [ÏàòÏ†ï 3] Ìä∏Îû© Í∏∞Îë• (Trap Pillar) - ÎÜíÏù¥/ÏúÑÏπò Î°úÏßÅÏùÄ JSÏóêÏÑú Ï≤òÎ¶¨ */
    .obs-trap { filter: drop-shadow(0 0 5px red) sepia(50%) hue-rotate(-50deg); border: 2px solid red !important; }

    .obstacle-explosion { position: absolute; z-index: 85; width: 100px; height: 100px; background: radial-gradient(circle, #fff, orange, transparent); border-radius: 50%; animation: obsExplode 0.4s ease-out forwards; transform: translate(-50%, -50%); }
    @keyframes obsExplode { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }

    .faith-coin { position: absolute; z-index: 88; width: 24px; height: 24px; background: radial-gradient(circle at 30% 30%, #ffd700, #ff8c00); border: 2px solid #fff; border-radius: 50%; box-shadow: 0 0 10px gold; display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: bold; color: #fff; }
    .faith-coin::after { content: '‚úù'; }

    .enemy { position: absolute; z-index: 48; width: 60px; height: 60px; background-position: center; background-size: contain; background-repeat: no-repeat; }
    .item { position: absolute; z-index: 45; width: 48px; height: 48px; image-rendering: pixelated; background-position: center; background-repeat: no-repeat; background-size: contain; animation: itemFloat 1.5s ease-in-out infinite alternate; }
    @keyframes itemFloat { from { transform: translateY(0); } to { transform: translateY(-8px); } }

    .projectile { position: absolute; z-index: 60; width: 30px; height: 30px; border-radius: 50%; transition: opacity 0.2s; }
    .enemy-missile { background: radial-gradient(circle, #ff0000, #800000); box-shadow: 0 0 8px #ff0000; }
    .boss-missile { width: 40px; height: 40px; background: radial-gradient(circle at 30% 30%, #ffeb3b, #ff5722); animation: spinMeteor 1s linear infinite; }
    
    .black-hole-missile { width: 50px; height: 50px; background: #000; border: 2px solid #800080; box-shadow: 0 0 20px #800080; opacity: 0.5; }
    .black-hole-active { opacity: 1; transform: scale(1.5); background: radial-gradient(circle, #000, #330033); box-shadow: 0 0 30px #000, 0 0 10px #ff00ff; animation: blackHolePulse 0.5s infinite alternate; }
    @keyframes blackHolePulse { from { transform: scale(1.5); } to { transform: scale(1.7); } }

    .player-missile { position: absolute; width: 50px; height: 24px; background: linear-gradient(90deg, #00ffff, #0099ff); border-radius: 12px; box-shadow: 0 0 15px cyan, 0 0 5px white; z-index: 65; border: 2px solid #fff; }
    
    .explosion-area { position: absolute; border-radius: 50%; background: rgba(255, 69, 0, 0.5); border: 2px solid orange; animation: explode 0.5s forwards; z-index: 59; }
    @keyframes explode { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }

    .enemy-laser-warning { position: absolute; height: 2px; background: rgba(255,0,0,0.5); z-index: 49; }
    .enemy-laser-beam { position: absolute; height: 30px; background: linear-gradient(to bottom, transparent, red, transparent); box-shadow: 0 0 15px red; z-index: 50; }
    .reflected-missile { background: #00ff00 !important; box-shadow: 0 0 15px #00ff00; }
    @keyframes spinMeteor { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    .sniper-line { position: absolute; height: 1px; background: red; z-index: 49; transform-origin: left center; opacity: 0.8; box-shadow: 0 0 5px red; }

    .particle { position: absolute; z-index: 90; pointer-events: none; border-radius: 50%; animation: particleFade 0.8s ease-out forwards; }
    @keyframes particleFade { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0); opacity: 0; } }

    #hud { position: absolute; z-index: 900; top: 12px; left: 12px; color: #3a2513; font-size: 18px; font-weight: 700; background: var(--hud-bg); border-radius: 10px; padding: 8px 12px; border: 3px solid var(--hud-border); }
    #pauseBtn, #abilityBtn, #subActionBtn, #buffArea, #junMiniGameUI, #bossWarning, .modal-bg, #loadingQuiz, #speedLines, #timeTunnelBg { position: absolute !important; }
    #feverContainer { width: 150px; height: 12px; background: #333; border: 2px solid #3a2513; border-radius: 6px; margin-top: 5px; overflow: hidden; display: flex; }
    #feverFill { width: 0%; height: 100%; background: linear-gradient(90deg, #ffd700, #ff8c00); transition: width 0.2s; }
    
   #pauseBtn { 
        position: fixed; z-index: 900; top: 15px; right: 15px; 
        font-size: 40px; cursor: pointer; 
        filter: drop-shadow(2px 2px 0px #fff) drop-shadow(0 0 5px rgba(0,0,0,0.5));
        transition: transform 0.1s;
    }
    #pauseBtn:active { transform: scale(0.9); }

    /* [ÏàòÏ†ï 4] Î≤ÑÌîÑ UI ÏúÑÏπò: Ïò§Î•∏Ï™Ω Îß® ÏïÑÎûò */
    #buffArea { 
        position: absolute; z-index: 2147483647; 
        bottom: 20px; right: 20px; 
        display: flex; flex-direction: column-reverse; 
        align-items: flex-end; gap: 8px; pointer-events: none; 
    }
    .buff-tag { background: rgba(0, 0, 0, 0.85); color: #fff; padding: 8px 14px; border-radius: 8px; font-weight: 700; border-left: 5px solid; font-size: 14px; box-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
    .buff-tag.passive-cd { opacity: 0.7; border-color: #aaa; }

    /* [ÏàòÏ†ï 2] Ïä§ÌÇ¨ Î≤ÑÌäº Ï§ëÏïô Îß® ÏïÑÎûòÎ°ú Ïù¥Îèô */
    #abilityBtn { 
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
        width: 80px; height: 80px; background: #ff5722; color: white; border-radius: 50%; border: 4px solid #fff; font-weight: bold; font-size: 20px; display: none; justify-content: center; align-items: center; cursor: pointer; z-index: 1000; box-shadow: 0 6px 12px rgba(0,0,0,0.6); 
    }
    #abilityBtn.cooldown { filter: grayscale(1); opacity: 0.7; cursor: not-allowed; font-size: 24px; }

    /* [ÏàòÏ†ï 2] Í≥µÍ≤©/Î∞©Ïñ¥ Î≤ÑÌäº ÏôºÏ™Ω Îß® ÏïÑÎûòÎ°ú Ïù¥Îèô */
    #subActionBtn { 
        position: fixed; bottom: 20px; left: 20px; 
        width: 100px; height: 100px; border-radius: 50%; border: 4px solid #fff; color: white; font-weight: 900; font-size: 20px; text-align: center; display: none; justify-content: center; align-items: center; cursor: pointer; z-index: 1000; box-shadow: 0 6px 12px rgba(0,0,0,0.6); transition: transform 0.1s, background-color 0.2s; 
    }
    #subActionBtn:active { transform: scale(0.9); }
    #subActionBtn.cooldown { filter: grayscale(1); opacity: 0.6; cursor: not-allowed; }
    .btn-attack { background-color: #D32F2F !important; }
    .btn-defence { background-color: #1976D2 !important; }

    #bossContainer { position: absolute; right: -200px; top: 50%; width: 120px; height: 120px; z-index: 55; display: none; transition: right 1s ease-out; }
    #bossBody { width: 100%; height: 100%; background: url('boss.png') no-repeat center/contain; image-rendering: pixelated; filter: drop-shadow(0 0 10px red); animation: bossFloat 2s ease-in-out infinite; }
    .boss-charging { filter: drop-shadow(0 0 20px yellow) !important; transform: scale(1.1); }
    .boss-dashing { filter: drop-shadow(0 0 20px #ff0000) !important; }
    .boss-rage { filter: hue-rotate(-50deg) saturate(300%) !important; }

    @keyframes bossFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
    #bossHpBar { position: absolute; top: -20px; left: 0; width: 100%; height: 10px; background: #333; border: 2px solid #000; border-radius: 5px; overflow: hidden; }
    #bossHpFill { width: 100%; height: 100%; background: #d32f2f; transition: width 0.2s; }

    #bossWarning { position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 50px; font-weight: 900; color: #d32f2f; text-shadow: 3px 3px 0 #000; display: none; z-index: 2000; animation: blink 0.5s infinite; }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
    .boss-laser { position: absolute; right: 0; height: 40px; background: linear-gradient(to bottom, #ff0000, #fff, #ff0000); z-index: 58; opacity: 0.8; border-top: 2px solid #fff; border-bottom: 2px solid #fff; box-shadow: 0 0 20px #ff0000; pointer-events: none; display: none; }

    #speedLines { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 80; background: radial-gradient(circle, transparent 40%, rgba(255, 255, 255, 0.8) 90%); mix-blend-mode: overlay; pointer-events: none; animation: speedShake 0.1s infinite; }
    @keyframes speedShake { 0% { transform: translate(0, 0); } 25% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 75% { transform: translate(-2px, -2px); } 100% { transform: translate(0, 0); } }

    .float-text { position: absolute; color: #ffe24f; font-weight: 900; font-size: 20px; text-shadow: 2px 2px 0 #3a2513; z-index: 1000; pointer-events: none; animation: floatUp 1s ease-out forwards; }
    @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-60px) scale(1.2); opacity: 0; } }

    #comboEffect, #correctEffect { position: fixed; left: 50%; transform: translateX(-50%); z-index: 1000; display: none; pointer-events: none; font-weight: 900; text-shadow: 3px 3px #000; }
    #comboEffect { top: 20%; font-size: 40px; color: #ffe24f; text-shadow: 3px 3px #8b4f26; }
    #correctEffect { top: 40%; font-size: 48px; color: #00ffcc; text-shadow: 3px 3px #006644; }

    .modal-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.55); display: none; justify-content: center; align-items: center; padding: 16px; z-index: 20000; }
    .modal-box { width: 90%; max-width: 420px; background: var(--panel-bg); border-radius: 14px; border: 4px solid #3a2513; padding: 28px 24px; box-shadow: 0 0 0 4px #fff, 0 10px 0 #b79b76; text-align: center; }
    .start-btn, .choice-btn, .action-btn { width: 100%; padding: 14px; margin: 8px 0; background: var(--accent); border: 0; border-radius: 10px; color: #fff; font-size: 18px; font-weight: 700; box-shadow: 0 4px 0 var(--accent-dark); cursor: pointer; }
    .choice-btn:active, .action-btn:active, .start-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--accent-dark); }
    .action-btn:disabled { background: #999; cursor: not-allowed; box-shadow: none; }
    .modal-input { 
        width: 85%; max-width: 320px; padding: 12px; font-size: 16px; 
        border-radius: 8px; border: 2px solid #b8a792; margin: 8px auto 18px; display: block;
        touch-action: auto !important; /* ÌÑ∞Ïπò ÌóàÏö© */
        user-select: text !important;  /* ÌÖçÏä§Ìä∏ ÏÑ†ÌÉù ÌóàÏö© */
        -webkit-user-select: text !important;
        cursor: text;
    }
    #loadingQuiz { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); justify-content: center; align-items: center; color: #fff; font-size: 22px; font-weight: 700; z-index: 20001; }

    .lamb-unit { position: absolute; width: 60px; height: 60px; background: url('Lam.png') no-repeat center/contain; z-index: 51; filter: drop-shadow(2px 2px 5px rgba(0,0,0,0.3)); }
    .lamb-msg { position: absolute; top: -40px; left: 50%; transform: translateX(-50%); background: #fff; border: 3px solid #3a2513; padding: 6px 12px; border-radius: 15px; font-size: 14px; font-weight: 800; white-space: nowrap; box-shadow: 2px 2px 0 rgba(0,0,0,0.2); color: #3a2513; }
    .lamb-msg::after { content: ''; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); border-width: 10px 8px 0; border-style: solid; border-color: #3a2513 transparent; display: block; width: 0; }

    .boba-unit { position: absolute; width: 18px; height: 18px; background: radial-gradient(circle at 30% 30%, #4e342e, #212121); border: 1px solid #000; border-radius: 50%; box-shadow: 2px 2px 3px rgba(0,0,0,0.4); z-index: 65; pointer-events: none; }
    
    .angel-wing-effect { position: absolute; width: 150px; height: 150px; left: 50%; top: 50%; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; font-size: 100px; z-index: 100; text-shadow: 0 0 20px gold, 0 0 40px white; animation: wingRise 2s ease-out forwards; pointer-events: none; }
    .angel-wing-effect::after { content: 'ü™Ω'; }
    @keyframes wingRise { 0% { opacity: 0; transform: translate(-50%, -20%) scale(0.5); } 20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 80% { opacity: 1; transform: translate(-50%, -80%) scale(1.3); } 100% { opacity: 0; transform: translate(-50%, -120%) scale(1.5); } }
  
  /* [Ìå®Ïπò] ÌûàÎì† Ï∫êÎ¶≠ÌÑ∞ Ï†ÑÏö© Ïù¥ÌéôÌä∏ Ïä§ÌÉÄÏùº */
    .light-sword {
        position: absolute; width: 30px; height: 100px;
        background: url('skin_Hidden_Skin1_2.png') no-repeat center/contain;
        z-index: 88; pointer-events: none;
        filter: drop-shadow(0 0 15px gold);
        animation: swordFall 0.4s linear forwards;
    }
    @keyframes swordFall { from { transform: translateY(-100px); } to { transform: translateY(100vh); } }

    .angel-heal-unit {
        position: absolute; width: 120px; height: 120px;
        background: url('skin_Hidden_Skin1_3.png') no-repeat center/contain;
        z-index: 95; pointer-events: none;
        animation: angelFade 3s ease-out forwards;
        filter: drop-shadow(0 0 20px white);
    }
    @keyframes angelFade { 
        0% { opacity: 0; transform: translate(-50%, -20%); } 
        20% { opacity: 1; transform: translate(-50%, -50%); } 
        80% { opacity: 1; transform: translate(-50%, -60%); } 
        100% { opacity: 0; transform: translate(-50%, -80%); } 
    }

    .aeran-flower-bg {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: url('skin_Hidden_Skin2_2.png') repeat-x;
        background-size: auto 100%;
        z-index: 4; opacity: 0; transition: opacity 1s; pointer-events: none;
        animation: bgLoop 20s linear infinite;
    }
    @keyframes bgLoop { from { background-position: 0 0; } to { background-position: -2000px 0; } }

    .flower-missile {
        position: absolute; width: 40px; height: 40px;
        background-image: url('Flower.png'); 
        background-size: contain; z-index: 85; pointer-events: none;
        animation: flowerFall 2.5s linear infinite;
    }
    @keyframes flowerFall { 
        0% { transform: translateY(-50px) rotate(0deg); } 
        100% { transform: translateY(100vh) rotate(360deg); } 
    }

    .aeran-halo {
        position: absolute; width: 150px; height: 150px;
        background: url('skin_Hidden_Skin2_3.png') no-repeat center/contain;
        z-index: 49; pointer-events: none;
        left: 50%; top: 50%; transform: translate(-50%, -50%);
        animation: haloExpand 2s ease-out forwards;
        mix-blend-mode: screen;
    }
    @keyframes haloExpand { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2); opacity: 0; } }

    .jongrak-kid {
        position: absolute; width: 50px; height: 50px;
        background-size: contain; background-repeat: no-repeat;
        z-index: 55; filter: drop-shadow(0 0 5px white);
        transition: left 0.5s, top 0.5s;
    }
    .heart-missile {
        position: absolute; font-size: 24px;
        z-index: 60; animation: spinHeart 1s infinite linear;
    }
    @keyframes spinHeart { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    .jongrak-light {
        position: absolute; width: 180px; height: 180px;
        background: url('skin_Hidden_Skin3_2.png') no-repeat center/contain;
        z-index: 48; pointer-events: none;
        left: 50%; top: 50%; transform: translate(-50%, -50%);
        animation: lightBurst 2s ease-out forwards;
    }
    @keyframes lightBurst { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } 50% { opacity: 1; filter: brightness(2); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); } }

    .revive-quake { animation: quake 0.5s infinite; }
    @keyframes quake { 0% { transform: translate(0,0); } 25% { transform: translate(-10px, 10px); } 50% { transform: translate(10px, -10px); } 75% { transform: translate(-10px, -10px); } 100% { transform: translate(0,0); } }
    
    .holy-resurrection {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: white; z-index: 9999; pointer-events: none;
        opacity: 0; transition: opacity 1s;
        display: flex; justify-content: center; align-items: center;
        flex-direction: column;
    }
    .resurrection-text {
        font-size: 40px; font-weight: 900; color: #333;
        text-shadow: 0 0 20px gold; margin-bottom: 20px;
        animation: textPop 2s ease-out forwards; text-align: center;
    }
    @keyframes textPop { 0% { transform: scale(0.5); opacity: 0; } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
    
  </style>
</head>

<body oncontextmenu="return false" onselectstart="return false" ondragstart="return false">
<div id="gameArea">
    <div id="startGuide" class="modal-bg" style="display:flex;">
      <div class="modal-box">
        <div style="font-size:28px; font-weight:800; margin-bottom:18px;">Í≤åÏûÑ Î∞©Î≤ï</div>
        <div style="text-align:left; font-size:15px; line-height:1.6;">
          ‚Ä¢ <b>Ï†êÌîÑ:</b> ÌôîÎ©¥ ÌÑ∞Ïπò / Space<br>
          ‚Ä¢ <b>Ïä§ÌÇ¨:</b> AÌÇ§ / SKILL Î≤ÑÌäº (Ï§ëÏïô ÌïòÎã®)<br>
          ‚Ä¢ <b>Í≥µÍ≤©/Î∞©Ïñ¥:</b> SÌÇ§ / Attack Î≤ÑÌäº (Ï¢åÏ∏° ÌïòÎã®)<br><br>
          [Í≤åÏûÑÏïàÎÇ¥]<br>
          ‚öîÔ∏è <b>200mÍπåÏßÄÎäî Ï¥àÎ≥¥Ïûê Íµ¨Í∞ÑÏûÖÎãàÎã§<br>
          üõ°Ô∏è <b>200m Ïù¥ÌõÑÎ∂ÄÌÑ∞ Ï†ÅÎì§Ïù¥ Îì±Ïû•Ìï©ÎãàÎã§<br>
          üëø <b>500mÎßàÎã§ Í∞ïÎ†•Ìïú Î≥¥Ïä§Í∞Ä Îì±Ïû•Ìï©ÎãàÎã§!<br>
          üå™Ô∏è <b>Í±∞Î¶¨Í∞Ä Î©ÄÏñ¥ÏßàÏàòÎ°ù ÏÜçÎèÑÏôÄ ÎÇúÏù¥ÎèÑÎäî Ï¶ùÍ∞ÄÌï©ÎãàÎã§</b>
        </div>
        <button class="start-btn" onclick="startGameNow()">‚ñ∂ ÏãúÏûëÌïòÍ∏∞ / Start</button>
      </div>
    </div>
  
    <div id="bgLayer1" class="bg-layer"></div>
    <div id="bgLayer2" class="bg-layer"></div>
    <div id="bgLayer3" class="bg-layer"></div>
    <div id="speedLines"></div> 
    <div id="jieunWaveBg" class="jieun-wave-bg"></div>
    <div id="cakeBg" class="cake-bg"></div>
    <div id="sandstormOverlay" class="sandstorm-overlay"></div>
    
    <div id="timeTunnelBg">
        <div class="tunnel-star" style="top:10%"></div>
        <div class="tunnel-star" style="top:30%; animation-duration:0.3s"></div>
        <div class="tunnel-star" style="top:50%; animation-duration:0.7s"></div>
        <div class="tunnel-star" style="top:70%; animation-duration:0.4s"></div>
        <div class="tunnel-star" style="top:90%"></div>
    </div> 
    <div id="junMiniGameUI">
      <div style="font-size:30px; font-weight:900; color:#00ffff; margin-bottom:10px;">ÏãúÍ≥µÍ∞Ñ Ï¥àÏõî Ï§ë!</div>
      <div style="font-size:16px; margin-bottom:20px;">ÌôîÎ©¥ÏùÑ Ïó∞ÌÉÄÌïòÏó¨ Í±∞Î¶¨Î•º ÎäòÎ¶¨ÏÑ∏Ïöî!</div>
      <div style="font-size:50px; font-weight:bold;"><span id="warpDistance">0</span>m</div>
      <div style="font-size:20px; color:#aaa;">(Max 50m)</div>
      <div class="warp-btn" ontouchstart="junWarpTap(event)" onclick="junWarpTap(event)">TAP!</div>
      <div style="margin-top:20px; font-size:14px;">PC: SpaceBar / Mobile: Tap</div>
    </div>
  
    <div id="ground"></div> <div id="player"></div>
  
    <div id="flashEffect"></div>
  
    <div id="bossContainer">
      <div id="bossHpBar"><div id="bossHpFill"></div></div>
      <div id="bossBody"></div>
    </div>
    <div id="bossLaser" class="boss-laser"></div>
  
    <div id="hud">
      ‚ù§Ô∏è <span id="lifeText"></span> 
      üìè <span id="distanceText">0m</span> 
      ‚úù <span id="faithText"></span>
      <div style="display:flex; align-items:center; margin-top:4px;">
          <span style="font-size:14px;">üî•</span>
          <div id="feverContainer"><div id="feverFill"></div></div>
      </div>
    </div>
      
    <div id="pauseBtn" ontouchstart="togglePause(event)" onclick="togglePause(event)">‚è∏Ô∏è</div>
    <div id="abilityBtn" ontouchstart="useAbility(event)" onclick="useAbility(event)">SKILL</div>
    <div id="subActionBtn"></div>

    <div id="buffArea"></div> 

  </div> <div id="bossWarning">‚ö†Ô∏è BOSS WARNING!</div>
  <div id="comboEffect">COMBO +1!</div>
  <div id="correctEffect">+5 Faith!</div>
  
  <div id="pauseModal" class="modal-bg">
    <div class="modal-box">
      <div style="font-size:28px; font-weight:800; margin-bottom:15px;">ÏùºÏãúÏ†ïÏßÄ</div>
      <button class="action-btn" onclick="resumeGame()">‚ñ∂ Í≥ÑÏÜçÌïòÍ∏∞</button>
      <button class="action-btn" style="background:#5d4037;" onclick="exitToMenu()">üè† Î©îÎâ¥Î°ú ÎÇòÍ∞ÄÍ∏∞</button>
    </div>
  </div>
  
  <div id="quizModal" class="modal-bg">
    <div class="modal-box">
      <div style="font-size:28px; font-weight:800;">ÏÑ±Í≤Ω ÌÄ¥Ï¶à</div>
      <div id="quizQuestion" style="margin:20px 0; font-size:18px;"></div>
      <button class="choice-btn" onclick="answerQuiz('A')" id="btnA"></button>
      <button class="choice-btn" onclick="answerQuiz('B')" id="btnB"></button>
      <button class="choice-btn" onclick="answerQuiz('C')" id="btnC"></button>
    </div>
  </div>
  
  <div id="gameOverModal" class="modal-bg">
    <div class="modal-box">
      <div style="font-size:28px; font-weight:800;">GAME OVER</div>
      <div style="margin:20px 0;"><b><span id="finalDist"></span>m</b> Îã¨Î†∏ÏäµÎãàÎã§!</div>
      <input id="rankMsg" class="modal-input" type="text" placeholder="ÏÜåÍ∞ê ÏûÖÎ†•(ÏÑ†ÌÉù)" />
      <button class="action-btn" style="background:#5d4037;" onclick="location.reload()">üîÑ Îã§ÏãúÌïòÍ∏∞</button>
      <button class="action-btn" onclick="confirmRanking(event)">[ÏàúÏúÑÎì±Î°ù]</button>
    </div>
  </div>
  
  <div id="loadingQuiz">‚è≥ ÏÑ±Í≤Ω Î¨∏Ï†úÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
  
  <script>
    // [Ï§ëÏöî] Ïä§ÏºÄÏùºÎßÅ Ìï®Ïàò
    let resizeTimeout;

    function resizeGame() {
        const gameArea = document.getElementById('gameArea');
        const width = window.innerWidth;
        const height = window.innerHeight;

        // PC ÌôòÍ≤Ω (ÎÑàÎπÑ 600px Ïù¥ÏÉÅ)
        if (width >= 600) {
            const baseHeight = 800;
            let scale = Math.min(height / baseHeight, 1.2); 
            gameArea.style.transform = `scale(${scale})`;
            window.gameScale = scale; 
        } 
        // Î™®Î∞îÏùº ÌôòÍ≤Ω
        else {
            gameArea.style.transform = 'none';
            gameArea.style.width = '100%';
            gameArea.style.height = '100%';
            window.gameScale = 1; 
        }
    }

    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resizeGame, 50);
    });
    
    setTimeout(resizeGame, 0);
    
  function isColliding(a, b) {
    return (a.x < b.x + b.w && a.x + a.w > b.x &&
            a.y < b.y + b.h && a.y + a.h > b.y);
  }

  const API_URL = "https://script.google.com/macros/s/AKfycbzA10H2TuXRDXBXcttvHHR0Q1sOu8zGpYmrdGhfH-wBsl623k2ydwUkwL7wR8F90mC5Pg/exec";

  const sounds = {};
  ['bgm', 'jump', 'hit', 'item', 'parry', 'clear'].forEach(name => {
    sounds[name] = new Audio(`${name}.mp3`);
    if(name==='bgm') {
        sounds[name].loop = true;
        sounds[name].volume = 0.5; 
    }
  });

  function playSound(name) {
    if(sounds[name]) {
        sounds[name].currentTime = 0;
        sounds[name].play().catch(()=>{});
    }
  }

  let id = localStorage.getItem("run_id") || "test_user";
  let name = localStorage.getItem("run_name") || "Tester";
  let saveData = JSON.parse(localStorage.getItem("run_save") || "{}");

  let missileLevel = saveData.missileLevel || 0;
  let playerDamage = 1 + missileLevel; 

  function hasFullCollection() {
    const hiddenSkins = ["Hidden_Skin1", "Hidden_Skin2", "Hidden_Skin3", "Hidden_Skin4", "Hidden_Skin5"];
    if(!saveData.ownedSkins) return false;
    return hiddenSkins.every(skin => saveData.ownedSkins.includes(skin));
  }
    
  const collectionBuff = hasFullCollection();

  // [ÏàòÏ†ï 1] ÏùºÏùº ÎØ∏ÏÖò Î≥ÄÏàò Î∞è Ìï®Ïàò Ï†úÍ±∞

  let life = 10 + (saveData.extraLife || 0);
  let maxLife = 10 + (saveData.extraLife || 0);

  let faith = saveData.faith || 0;
  let agility = saveData.agility || 0;
  let currentSkin = saveData.equippedSkin || "default";
  let skinLvl = 0;
  if (saveData.skinLevels && saveData.skinLevels[currentSkin] !== undefined) {
      skinLvl = saveData.skinLevels[currentSkin];
  } else {
      if(currentSkin === 'default' || currentSkin.startsWith('Hidden')) skinLvl = 2; 
      else skinLvl = 0; 
  }
  const activeSkillLevel = {
      'noel': 2, 'jeonchan': 2, 'jaeguk': 1, 'hahwi': 2, 'jihye': 2, 
      'jun': 2, 'stephanie': 2, 'yejun': 1, 'ganghui': 2, 'jieun': 1
  };
    
  let hiddenTransformActive = false; // Î≥ÄÏã† ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
  let hiddenAttackCooldown = 0;      // Ïù¥Î™©ÏÇ¨ Í≥µÍ≤© Ïø®ÌÉÄÏûÑ
  let hiddenHealTimer = 0;           // 3Ï¢Ö Í≥µÌÜµ ÌûêÎßÅ ÌÉÄÏù¥Î®∏
  let hiddenReviveUsed = false;      // 3Ï¢Ö Í≥µÌÜµ Î∂ÄÌôú ÏÇ¨Ïö© Ïó¨Î∂Ä
  let aeranFlowerTimer = 0;          // Î∞ïÏ†ÑÎèÑÏÇ¨ ÍΩÉ ÌÉÄÏù¥Î®∏
  let jongrakKids = [];              // Í∂åÏÇ¨Îãò ÏÜåÌôòÏàò
  let jongrakKidFireTimer = 0;       // Í∂åÏÇ¨Îãò ÏÜåÌôòÏàò Í≥µÍ≤© ÌÉÄÏù¥Î®∏
    
  const SKIN_DATA = {
    default: { type: "none" }, 
    noel: { type: "Active", cd: 60 },  
    jeonchan: { type: "Active", cd: 60 },
    haeun: { type: "Passive", cd: 30 }, 
    jaeguk: { type: "Active", cd: 70 }, 
    hahwi: { type: "Active", cd: 60 },
    jihye: { type: "Active", cd: 60 }, 
    jun: { type: "Active", cd: 90 },
    stephanie: { type: "Active", cd: 70 },
    yejun: { type: "Active", cd: 50 },
    ganghui: { type: "Active", cd: 60 },
    jieun: { type: "Active", cd: 60 }
  };

   SKIN_DATA['Hidden_Skin1'] = { type: "Active", cd: 10 }; // Ïù¥Î™©ÏÇ¨
   SKIN_DATA['Hidden_Skin2'] = { type: "Active", cd: 10 }; // Î∞ïÏ†ÑÎèÑÏÇ¨
   SKIN_DATA['Hidden_Skin3'] = { type: "Active", cd: 10 }; // Í∂åÏÇ¨Îãò

  const HIDDEN_SKIN_CODES = ["Hidden_Skin1", "Hidden_Skin2", "Hidden_Skin3"];
      
  const PASSIVE_COOLDOWNS = {
      'jeonchan': 15, 'jieun': 40, 'haeun': 25, 'jihye': 25, 'jun': 30,
      'noel': 30, 'hahwi': 30, 'yejun': 50, 'stephanie': 30, 'ganghui': 10
  };

  const abilityBtn = document.getElementById('abilityBtn');
  if(SKIN_DATA[currentSkin].type === "Active") {
      let reqLvl = activeSkillLevel[currentSkin] || 1;
      if (skinLvl >= reqLvl) abilityBtn.style.display = 'flex';
      else abilityBtn.style.display = 'none';
  }

  document.getElementById("lifeText").innerText = life;
  document.getElementById("faithText").innerText = faith;

  const gameArea = document.getElementById("gameArea");
  const player = document.getElementById("player");
  const bg1 = document.getElementById("bgLayer1"); const bg2 = document.getElementById("bgLayer2"); const bg3 = document.getElementById("bgLayer3");
  const aeranBg = document.createElement('div');
  aeranBg.className = 'aeran-flower-bg';
  gameArea.appendChild(aeranBg);

  if (currentSkin !== 'default') player.style.backgroundImage = `url('skin_${currentSkin}.png')`;
  else player.style.backgroundImage = `url('disciple.png')`;

  let buffArea = document.getElementById("buffArea");
    
  if(collectionBuff) {
    buffArea.innerHTML += `<div class="buff-tag" style="border-color:#e040fb; order:999;">‚ú® Ïª¨Î†âÏÖò Î≥¥ÎÑàÏä§ (Faith +10%)</div>`;
  }

  let speedLines = document.getElementById("speedLines");
  let timeTunnelBg = document.getElementById("timeTunnelBg");

  let playerObj = { x: 50, y: 40, w: 40, h: 50 }; 
  let velocity = 0; 
  let gravity = -0.12; let jumpPower = Math.max(3, 4.2 - agility * 0.05);
    
  let targetY = 0;
  let distance = 0;
  let obstacles = []; let projectiles = []; 
  let enemies = []; let playerMissiles = []; 
  let faithCoins = [];
  let running = false; let invincible = false;

  const BASE_SPEED = 170; let gameSpeed = BASE_SPEED;
  let lastTime = performance.now();
  let nextQuizDistance = 35; 
    
  let obstacleTimer = 0; let nextObstacleTime = 2.0;
  let enemySpawnTimer = 0;
  let itemTimer = 0; let nextItemTime = 15;
  let abilityCD = 0;
    
  let jeonchanTimer = 0;
  let haeunLifeTimer = 0;
  let haeunShieldTimer = 0;
  let haeunShieldActive = false;
  let jaegukRevivedOnce = false; 
  let bobas = []; 
  let jihyeUnits = []; 
  let jihyeMissiles = []; 
  let jihyePassiveTimer = 0; 
    
  let jihyeSphereActive = false;
  let jihyeSphereEl = null;
  let jihyeEndSphereEl = null;

  let junLambTimer = 0;
  let isJunTimeTravel = false;
  let junPortalEntryY = 0; 
    
  let activeLamb = null;

  let noelGiantTimer = 0;
  let hahwiStoneTimer = 0;
  let infinityStones = [];
  let sandstormActive = false;
  let junMiniGameActive = false;
  let junWarpDist = 0;
  let ganghuiPanelTimer = 0;
  let funnels = [];
  let gundamAura = null;
  let yejunCloneTimer = 0;
  let yejunClones = [];
  let stephanieHeartTimer = 0;
  let cakeDropTimer = 0;
  let cakes = [];
  let hammerObj = null;
  let musicNotes = [];
  let musicWaveActive = false;
  let musicNoteTimer = 0;
  let jieunNoelTimer = 0;
    
  let coinCombo = 0;
  let coinComboTimer = 0;

  let bg1X = 0, bg2X = 0, bg3X = 0;
  let sandBgX = 0; 
  const BG1_SPEED = 20; const BG2_SPEED = 40; const BG3_SPEED = 60;

  let items = []; let combo = 0; let obstacleSurviveCount = 0; let rankingSaved = false;
  let activeEffects = { turbo: 0, invincible: 0, slow: 0, fly: 0, revive: 0, summon: 0, magnet: 0, noelLaser: 0, bobaTime: 0, hahwiMode: 0, jihyeSquad: 0, junTravel: 0, giant: 0, sandstorm: 0, gundam: 0, cakeWorld: 0, musicWave: 0 };

  let feverGauge = 0;
  const MAX_FEVER = 100;
  let isFeverTime = false;

  let isBossBattle = false;
  let nextBossTrigger = 500; 
  let bossLevel = 0;
  let boss = { hp: 6, maxHp: 6, x: 0, y: 50, vy: 0.5, state: 'idle', shootTimer: 0, actionTimer: 0 }; 
  let bossContainer = document.getElementById('bossContainer');
  let bossBody = document.getElementById('bossBody');
  let bossHpFill = document.getElementById('bossHpFill');
    
  let subActionBtn = document.getElementById('subActionBtn');
  let shieldCooldown = 0;

  function randBetween(min, max) { return Math.random() * (max - min) + min; }

  function setupActionButtons() {
      const btn = document.getElementById('subActionBtn');
      // Í∏∞Ï°¥ Ïù∏ÎùºÏù∏ Ïù¥Î≤§Ìä∏ Ï†úÍ±∞ ÌõÑ Îì±Î°ù
      btn.onclick = null;
      btn.ontouchstart = null;

      // Î™®Î∞îÏùº: ÌÑ∞Ïπò Ï¶âÏãú Î∞òÏùë
      btn.addEventListener('touchstart', (e) => {
          e.preventDefault(); // Ïä§ÌÅ¨Î°§ Îì± Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ
          e.stopPropagation();
          handleSubAction(); 
      }, { passive: false });

      // PC: ÎßàÏö∞Ïä§ ÌÅ¥Î¶≠
      btn.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          handleSubAction();
      });
  }
  setupActionButtons();

  function spawnParticles(x, y, type) {
    const colors = type==='item' ? ['#ffd700','#fff'] : type==='spark' ? ['#ff4500','#ff8c00'] : ['#8b4513','#a0522d'];
    for(let i=0; i<8; i++) {
        const p = document.createElement('div');
        p.classList.add('particle');
        p.style.background = colors[Math.floor(Math.random()*colors.length)];
        p.style.width = (Math.random()*6+4)+'px'; p.style.height = p.style.width;
        p.style.left = x + 'px'; p.style.top = y + 'px';
        gameArea.appendChild(p);
        const tx = (Math.random()-0.5) * 100;
        const ty = (Math.random()-0.5) * 100;
        p.animate([ { transform: `translate(0,0)` }, { transform: `translate(${tx}px, ${ty}px)` } ], { duration: 600, fill: 'forwards' }).onfinish = () => p.remove();
    }
  }

  function spawnExplosionEffect(x, y) {
      const ex = document.createElement('div');
      ex.classList.add('obstacle-explosion');
      ex.style.left = x + 'px';
      ex.style.top = y + 'px';
      gameArea.appendChild(ex);
      setTimeout(() => ex.remove(), 400);
      playSound('hit');
  }

  function spawnFaithCoins(x, y, count, manualCollection = false, autoCollect = false) {
      for(let i=0; i<count; i++) {
          const coin = document.createElement('div');
          coin.classList.add('faith-coin');
          coin.isManual = manualCollection; 
          coin.isAutoCollect = autoCollect; 
            
          const spreadMult = (!manualCollection && !autoCollect) ? 5 : 1;

          const spreadX = (Math.random() - 0.5) * 100 * spreadMult;
          const spreadY = (Math.random() - 0.5) * 100 * spreadMult;
          coin.style.left = x + 'px'; coin.style.top = y + 'px';
          coin.x = x; coin.y = y;
          coin.vx = spreadX; coin.vy = spreadY; coin.timer = 0;
          gameArea.appendChild(coin); faithCoins.push(coin);
      }
  }

  function createHaeunShield() {
      const shield = document.createElement('div');
      shield.id = 'haeunShield';
      shield.className = 'haeun-shield';
      player.appendChild(shield);
  }

  function removeHaeunShield() {
      const shield = document.getElementById('haeunShield');
      if(shield) shield.remove();
  }

  function showHealEffect() {
      const heal = document.createElement('div');
      heal.className = 'heal-effect-visual';
      heal.style.left = '50%';
      heal.style.top = '50%';
      player.appendChild(heal); 
      setTimeout(()=>heal.remove(), 600);
  }

  function triggerJieunMusicWave() {
      showFloatText("üéµ ÎÆ§ÏßÅ Ïõ®Ïù¥Î∏å!");
      activeEffects.musicWave = 10;
      musicWaveActive = true;
      document.getElementById('jieunWaveBg').style.opacity = '1';
  }

  function activateJieunBuff() {
      const noelFly = document.createElement('div');
      noelFly.className = 'flying-noel';
      noelFly.style.left = (gameArea.offsetWidth + 100) + 'px';
      noelFly.style.top = '-50px';
      gameArea.appendChild(noelFly);

      const pRect = { left: playerObj.x, top: gameArea.offsetHeight - playerObj.y - playerObj.h }; 

      noelFly.animate([
         { left: (gameArea.offsetWidth + 100) + 'px', top: '-50px', transform: 'rotate(20deg)' },
         { left: '120px', top: (gameArea.offsetHeight - playerObj.y - 60) + 'px', transform: 'rotate(0deg)' }
      ], { duration: 800, easing: 'ease-out', fill: 'forwards' }).onfinish = () => {
          noelFly.remove();
            
          const flash = document.getElementById('flashEffect');
          flash.style.opacity = '0.8';
          setTimeout(() => flash.style.opacity = '0', 100);
          playSound('item'); 

          player.style.backgroundImage = `url('Skill_NJ.png')`;
            
          const shield = document.createElement('div');
          shield.id = 'jieunShield';
          shield.className = 'jieun-shield';
          player.appendChild(shield);

          activeEffects.summon = 15;
          showFloatText("üõ°Ô∏è ÎÖ∏Ïóò ÏÜåÌôò!");
      };
  }

  function deactivateJieunBuff() {
      const flash = document.getElementById('flashEffect');
      flash.style.opacity = '0.8';
      setTimeout(() => flash.style.opacity = '0', 100);

      player.style.backgroundImage = `url('skin_jieun.png')`;

      const shield = document.getElementById('jieunShield');
      if(shield) shield.remove();

      const noel = document.createElement('div');
      noel.className = 'flying-noel';
      noel.style.left = '120px';
      noel.style.top = (gameArea.offsetHeight - playerObj.y - 60) + 'px';
      gameArea.appendChild(noel);

      noel.animate([
          { left: '120px', top: (gameArea.offsetHeight - playerObj.y - 60) + 'px' },
          { left: (gameArea.offsetWidth + 200) + 'px', top: '-200px' }
      ], { duration: 800, easing: 'ease-in', fill: 'forwards' }).onfinish = () => noel.remove();
  }

  function jump() {
    if (!running) {
        if (junMiniGameActive) {
            junWarpDist++;
            if(junWarpDist > 50) junWarpDist = 50;
            document.getElementById('warpDistance').innerText = junWarpDist;
            return;
        }
        return;
    }
    if (activeEffects.turbo > 0 || activeEffects.fly > 0) return;
    velocity = jumpPower;
    playSound('jump');
  }

  function junWarpTap(e) {
      if(e) { e.preventDefault(); e.stopPropagation(); }
      if (junMiniGameActive) {
          junWarpDist++;
          if(junWarpDist > 50) junWarpDist = 50;
          document.getElementById('warpDistance').innerText = junWarpDist;
      }
  }

  document.addEventListener("touchstart", (e) => {
      if(junMiniGameActive) { junWarpTap(e); return; }
      if(e.target.closest('.choice-btn') || e.target.closest('#abilityBtn') || e.target.closest('#subActionBtn') || e.target.closest('#pauseBtn') || e.target.closest('.warp-btn')) return;
      if (!running) return;
      e.preventDefault(); jump();
  }, {passive: false});

  document.addEventListener("mousedown", (e) => {
       if(junMiniGameActive) { junWarpTap(e); return; }
       if(e.target.closest('.choice-btn') || e.target.closest('#abilityBtn') || e.target.closest('#subActionBtn') || e.target.closest('#pauseBtn') || e.target.closest('.warp-btn')) return;
       if (!running) return;
       jump();
  });
    
  document.addEventListener("keydown", e => {
    if (e.code === "Space") { 
        e.preventDefault(); 
        if(junMiniGameActive) { if(!e.repeat) junWarpTap(null); return; }
        if(!e.repeat) jump(); 
    }
    if (e.code === "ArrowUp") { e.preventDefault(); jump(); }
    if (e.code === "KeyA") useAbility();
    if (e.code === "KeyS") handleSubAction(); 
  });
    
  function updateInputY(clientY) {
    const gameArea = document.getElementById("gameArea");
    const rect = gameArea.getBoundingClientRect();
    const scale = window.gameScale || 1;
    let relativeY = (clientY - rect.top) / scale;
    targetY = gameArea.offsetHeight - relativeY;
}

window.addEventListener('mousemove', e => updateInputY(e.clientY));
window.addEventListener('touchmove', e => updateInputY(e.touches[0].clientY));
    
  function togglePause(e) {
      if(e) { e.preventDefault(); e.stopPropagation(); }
      if(!running && !junMiniGameActive) return; 
      running = false;
      document.getElementById('pauseModal').style.display = 'flex';
  }

  // [ÏàòÏ†ï 1] ÏùºÏùºÎØ∏ÏÖò ÌÜ†Í∏Ä Ìï®Ïàò ÏÇ≠Ï†ú

  function resumeGame() {
      document.getElementById('pauseModal').style.display = 'none';
      running = true;
      lastTime = performance.now(); 
      requestAnimationFrame(gameLoop);
  }

  function exitToMenu() {
      window.location.href = "/TrapGame/menu.html";
  }

  function handleSubAction() {
      if (!running) return;
      
      // [Ìå®Ïπò] Ïù¥Î™©ÏÇ¨ Î≥ÄÏã† ÏÉÅÌÉúÏùº Îïå ÌäπÏàò Í≥µÍ≤©
      if (currentSkin === 'Hidden_Skin1' && hiddenTransformActive) {
          if (hiddenAttackCooldown <= 0) {
              if (faith >= 10) {
                  triggerJaegwanSword();
              } else {
                  showFloatText("Ïã†ÏïôÏã¨ Î∂ÄÏ°±! (10)");
              }
          }
          return;
      }

      if (isBossBattle) useShield();
      else if (distance >= 200) playerShoot();
  }

  function useShield() {
    if (shieldCooldown > 0) return;
    shieldCooldown = 0.5;
    subActionBtn.classList.add('cooldown');
    let reflected = false;
    let blackHoleDefused = false;

    projectiles.forEach(p => {
        if(p.isBlackHole && p.state === 'absorbing') {
            neutralizeBlackHole(p);
            blackHoleDefused = true;
        }
    });

    if (blackHoleDefused) {
        showFloatText("üåå Î∏îÎûôÌôÄ ÏÜåÎ©∏!");
        playSound('parry');
        return;
    }

    projectiles.forEach(p => {
        if (p.isBossMissile && !p.isReflected && !p.isBlackHole) {
            const dist = Math.hypot(p.x - playerObj.x, p.y - (gameArea.offsetHeight - playerObj.y - 30));
            if (dist < 150) {
                p.isReflected = true;
                p.classList.remove('boss-missile');
                p.classList.add('reflected-missile');
                p.vx = Math.abs(p.vx) * 1.5; p.vy = -p.vy * 0.5; 
                reflected = true;
                spawnParticles(p.x, p.y, 'spark');
            }
        }
    });
    if (reflected) { showFloatText("‚öîÔ∏è Î∞òÏÇ¨ ÏÑ±Í≥µ!"); playSound('parry'); }
    else showFloatText("üõ°Ô∏è Î∞©Ïñ¥!");
  }

  function neutralizeBlackHole(p) {
      p.state = 'fading';
      p.classList.remove('black-hole-active');
      p.animate([{transform: 'scale(1.5)'}, {transform: 'scale(0)'}], {duration: 500}).onfinish = () => {
          p.remove();
      };
      p.isFading = true; 
  }

  function playerShoot() {
      const m = document.createElement("div"); m.classList.add("player-missile");
      const startX = playerObj.x + 50;
      const startY = (gameArea.offsetHeight - playerObj.y - 40);
      m.style.left = startX + "px"; m.style.top = startY + "px"; 
      gameArea.appendChild(m); playerMissiles.push(m);
      playSound('jump');
  }

  function triggerJaegukBobas() {
      showFloatText("üßã Î≤ÑÎ∏îÌã∞ ÌååÏõå!");
      activeEffects.bobaTime = 20; 
      activeEffects.invincible = 20; 
        
      for(let i=0; i<5; i++) {
          const b = document.createElement('div');
          b.className = 'boba-unit';
          b.angle = (i / 5) * Math.PI * 2; 
          b.radius = 60;
          b.state = 'orbit'; 
          b.target = null;
          gameArea.appendChild(b);
          bobas.push(b);
      }
      playSound('item');
  }

  function triggerHahwiSkill() {
    showFloatText("üå™Ô∏è ÏÇ¨ÎßâÏùò Ìè≠Ìíç!");
    activeEffects.sandstorm = 15;
    document.getElementById('sandstormOverlay').style.opacity = '1';
    gameArea.classList.add('sandstorm-mode');
    gameArea.classList.add('sand-bg');
    playSound('clear');
  }

  function triggerJihyeSkill() {
      showFloatText("‚ú® Î∞úÌÇ§Î¶¨ Î≥ÄÏã†!");
        
      const sphere = document.createElement('div');
      sphere.className = 'jihye-transform-sphere';
      gameArea.appendChild(sphere);

      jihyeSphereEl = sphere;
      jihyeSphereActive = true;

      activeEffects.invincible = 2.5;
        
      setTimeout(() => {
          jihyeSphereActive = false;
          sphere.remove();
          jihyeSphereEl = null;

          player.style.backgroundImage = `url('Skill_JH.png')`;
            
          const flash = document.getElementById('flashEffect');
          flash.style.opacity = '1';
          setTimeout(() => flash.style.opacity = '0', 300);
          playSound('clear');

          activeEffects.jihyeSquad = 20; 

          for(let i=1; i<=5; i++) {
              const unit = document.createElement('div');
              unit.className = 'jihye-unit';
              unit.style.backgroundImage = `url('Skill_JH${i}.png')`;
              unit.x = -100; unit.y = randBetween(50, gameArea.offsetHeight/2);
              unit.style.left = unit.x + 'px';
              unit.style.top = unit.y + 'px';
              unit.tx = (gameArea.offsetWidth / 2) + randBetween(-100, 100);
              unit.ty = (gameArea.offsetHeight / 2) + randBetween(-200, 0);
              unit.moveTimer = 0;
              unit.fireTimer = 0;
              gameArea.appendChild(unit);
              jihyeUnits.push(unit);
          }
      }, 2000);
  }

  function endJihyeSkill() {
      const sphere = document.createElement('div');
      sphere.className = 'jihye-transform-sphere';
      sphere.style.left = (playerObj.x + 30) + 'px';
      sphere.style.top = (gameArea.offsetHeight - playerObj.y - 30) + 'px';
      gameArea.appendChild(sphere);
        
      jihyeEndSphereEl = sphere;

      activeEffects.invincible = 2.0;

      setTimeout(() => {
        jihyeEndSphereEl = null;
        sphere.remove();
        player.style.backgroundImage = `url('skin_jihye.png')`;
        jihyeUnits.forEach(u => {
            u.style.transition = "left 1s ease-in, top 1s ease-in";
            u.style.left = '-200px'; 
            setTimeout(() => u.remove(), 1000);
        });
        jihyeUnits = [];
      }, 2000);
  }

  function triggerJihyeHeal() {
      const healer = document.createElement('div');
      healer.className = 'jihye-healer';
      gameArea.appendChild(healer);
        
      const pillar = document.createElement('div');
      pillar.className = 'holy-light-pillar';
      gameArea.appendChild(pillar);

      healer.style.left = (playerObj.x + 10) + 'px';
      healer.style.top = (gameArea.offsetHeight - playerObj.y - 80) + 'px';
      pillar.style.left = (playerObj.x + 30) + 'px';

      setTimeout(() => {
          life = Math.min(life + 2, maxLife + 5); 
          document.getElementById("lifeText").innerText = life;
          showFloatText("üíñ Ï≤úÏÇ¨Ïùò ÏπòÏú† (+2)");
          playSound('item');
            
          healer.style.left = (gameArea.offsetWidth + 100) + 'px';
          healer.style.top = '-200px';
          setTimeout(() => {
              healer.remove(); 
              pillar.remove();
          }, 1500);
      }, 2000);
  }

function triggerJunSkill() {
      if(isJunTimeTravel) return;
      isJunTimeTravel = true;
      showFloatText("‚è≥ Ï∞®ÏõêÎ¨∏ Í∞úÎ∞©!");

      const portal = document.createElement('div');
      portal.className = 'real-portal portal-opening';
      
      junPortalEntryY = playerObj.y; 

      const visualSize = 60; 
      const playerCenterX = playerObj.x + (visualSize / 2); 
      const playerCenterY = gameArea.offsetHeight - playerObj.y - (visualSize / 2); 

      portal.style.left = playerCenterX + 'px';
      portal.style.top = playerCenterY + 'px';
      gameArea.appendChild(portal);

      setTimeout(() => {
          player.style.transition = "transform 0.5s, top 0.5s, left 0.5s";
          player.style.bottom = "auto"; 
          player.style.left = playerCenterX + 'px';
          player.style.top = playerCenterY + 'px';
          player.style.transform = "translate(-50%, -50%) scale(0)"; 
      }, 50);

      setTimeout(() => {
          timeTunnelBg.style.display = 'block';
          timeTunnelBg.style.opacity = '1';
            
          setTimeout(() => {
              document.getElementById('junMiniGameUI').style.display = 'flex';
              junMiniGameActive = true;
              running = false; 
              junWarpDist = 0;
              document.getElementById('warpDistance').innerText = "0";

              setTimeout(() => {
                    finishJunMiniGame(portal);
              }, 3000);
          }, 500);

      }, 600); 
  }

  function finishJunMiniGame(portal) {
      document.getElementById('junMiniGameUI').style.display = 'none';
      junMiniGameActive = false;
        
      portal.style.left = '50%'; 
      portal.style.top = '50%';
        
      player.style.transition = 'none';
      player.style.left = '50%';
      player.style.top = '50%';
      player.style.transform = 'translate(-50%, -50%) scale(0)';
        
      timeTunnelBg.style.opacity = '0';
      setTimeout(() => timeTunnelBg.style.display = 'none', 500);

      distance += junWarpDist;
      document.getElementById("distanceText").innerText = Math.floor(distance) + "m";
      showFloatText(`üìç +${junWarpDist}m Ïù¥Îèô!`);

      setTimeout(() => {
          player.style.transition = "transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)";
          player.style.transform = 'translate(-50%, -50%) scale(1)';
            
          playerObj.y = (gameArea.offsetHeight / 2) - 30;
          velocity = 0; 

          setTimeout(() => {
               player.style.transition = "left 0.8s ease-out"; 
               player.style.top = ""; 
               player.style.bottom = playerObj.y + "px"; 
               player.style.transform = "none"; 
               
               player.style.left = "50px"; 
               
               running = true; 
               lastTime = performance.now();
               requestAnimationFrame(gameLoop);
               
               portal.classList.remove('portal-opening');
               portal.classList.add('portal-closing');
               setTimeout(() => { portal.remove(); isJunTimeTravel = false; }, 500);
          }, 400); 
      }, 100);
  }

  function spawnLamb() {
      const lamb = document.createElement('div');
      lamb.className = 'lamb-unit';
      lamb.x = gameArea.offsetWidth + 150; 
      lamb.y = 50;
      lamb.style.left = lamb.x + 'px';
      lamb.style.top = lamb.y + 'px'; 
      lamb.style.transform = "scaleX(-1)"; 
      lamb.style.zIndex = "51"; 
      gameArea.appendChild(lamb);
        
      activeLamb = {
          el: lamb,
          state: 'approach',
          waitTimer: 0,
          msgEl: null
      };
        
      activeLamb.el.x = lamb.x;
      activeLamb.el.y = lamb.y;
  }

  function updateLamb(dt) {
      if(!activeLamb) return;
      const lamb = activeLamb;
      const pRect = { x: playerObj.x, y: gameArea.offsetHeight - playerObj.y - 60 };
        
      if(lamb.state === 'approach') {
          const targetX = pRect.x - 50; 
          const targetY = pRect.y - 50;
            
          lamb.el.x += (targetX - lamb.el.x) * 0.08;
          lamb.el.y += (targetY - lamb.el.y) * 0.08;
            
          lamb.el.style.left = lamb.el.x + 'px';
          lamb.el.style.top = lamb.el.y + 'px';
            
          if(Math.abs(lamb.el.x - targetX) < 30 && Math.abs(lamb.el.y - targetY) < 30) {
              lamb.state = 'talk';
              const messages = ["ÌôîÏù¥ÌåÖ!", "ÌûòÎÇ¥ÏÑ∏Ïöî!", "Ï£ºÎãòÏù¥ Ìï®ÍªòÌï¥Ïöî!", "Í∏∞ÏÅ®Ïù¥ Í∞ÄÎìùÌïòÍ∏∏!", "ÌèâÏïàÌïòÏÑ∏Ïöî!"];
              const randomMsg = messages[Math.floor(Math.random() * messages.length)];
                
              const msg = document.createElement('div');
              msg.className = 'lamb-msg';
              msg.innerText = randomMsg;
              msg.style.transform = "scaleX(-1)";
              msg.style.display = "inline-block";
              lamb.el.appendChild(msg);
              lamb.msgEl = msg;
                
              if(life < maxLife + 5) {
                  life++;
                  document.getElementById("lifeText").innerText = life;
                  showHealEffect();
                  showFloatText("üíñ +1 Life");
              }
          }
      } else if(lamb.state === 'talk') {
          lamb.waitTimer += dt;
          if(lamb.waitTimer > 1.5) { 
              lamb.state = 'leave';
              lamb.el.style.transform = "scaleX(1)";
              if(lamb.msgEl) lamb.msgEl.remove();
          }
      } else if(lamb.state === 'leave') {
          lamb.el.x += 400 * dt; 
          lamb.el.style.left = lamb.el.x + 'px';
          if(lamb.el.x > gameArea.offsetWidth + 150) {
              lamb.el.remove();
              activeLamb = null;
          }
      }
  }
    
  function triggerJeonchanHammer() {
      showFloatText("üî® Ïã¨ÌåêÏùò ÎßùÏπò!");
      gameArea.classList.add('gentle-shake');
      hammerObj = document.createElement('div');
      hammerObj.className = 'hammer-skill';
      hammerObj.x = -400; 
      hammerObj.y = 50;   
      const totalDist = gameArea.offsetWidth + 800; 
      hammerObj.vx = totalDist / 20; 
      hammerObj.style.left = hammerObj.x + 'px';
      hammerObj.style.top = hammerObj.y + 'px';
      gameArea.appendChild(hammerObj);
  }

  function triggerJeonchanLightning() {
      const flash = document.getElementById('flashEffect');
      flash.style.opacity = '0.8';
      setTimeout(() => flash.style.opacity = '0', 100);
      playSound('clear');

      for(let i=0; i<5; i++) {
          const svgNS = "http://www.w3.org/2000/svg";
          const svg = document.createElementNS(svgNS, "svg");
          svg.classList.add('zigzag-lightning');
          svg.setAttribute("width", gameArea.offsetWidth);
          svg.setAttribute("height", gameArea.offsetHeight);
          svg.style.left = '0';
          svg.style.top = '0';

          const startX = randBetween(0, gameArea.offsetWidth);
          const startY = 0;
          let points = `${startX},${startY}`;
            
          let currentX = startX;
          let currentY = startY;
            
          while(currentY < gameArea.offsetHeight) {
              currentY += randBetween(20, 50);
              currentX += randBetween(-40, 40);
              points += ` ${currentX},${currentY}`;
          }

          const polyline = document.createElementNS(svgNS, "polyline");
          polyline.setAttribute("points", points);
          polyline.style.stroke = "white";
          polyline.style.strokeWidth = "3";
          polyline.style.fill = "none";
          polyline.style.filter = "drop-shadow(0 0 8px yellow)";
            
          svg.appendChild(polyline);
          gameArea.appendChild(svg);
            
          setTimeout(() => svg.remove(), 400); 
      }

      obstacles.forEach(o => {
          if(!o.destroyed && o.x < gameArea.offsetWidth) {
              o.destroyed = true;
              spawnExplosionEffect(o.x, gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - 50);
              spawnFaithCoins(o.x, gameArea.offsetHeight - 150, 3, false, true);
              o.remove();
          }
      });
      enemies.forEach(e => {
          if(!e.isDead && e.x < gameArea.offsetWidth) {
              e.isDead = true;
              spawnExplosionEffect(e.x, e.y);
              spawnFaithCoins(e.x, e.y, 5, false, true);
              e.remove();
          }
      });
  }

  function triggerStephanieSkill() {
      showFloatText("üç∞ ÏºÄÏù¥ÌÅ¨ ÏõîÎìú!");
      activeEffects.cakeWorld = 20;
      document.getElementById('cakeBg').style.opacity = '1';
      cakeDropTimer = 0;
  }
    
  function triggerYejunClones() {
      showFloatText("üí® ÎèÑÌîåÍ∞±Ïñ¥ ÏÜåÌôò!");
      activeEffects.invincible = 15;

      for(let i=0; i<5; i++) {
          const clone = document.createElement('div');
          clone.className = 'yejun-clone';
          clone.x = playerObj.x + randBetween(-50, 50);
          clone.y = playerObj.y + randBetween(20, 100);
          clone.style.left = clone.x + 'px';
          clone.style.bottom = clone.y + 'px';
            
          clone.vx = randBetween(-3, 3);
          clone.vy = randBetween(-3, 3);
            
          gameArea.appendChild(clone);
          yejunClones.push({ el: clone, fireTimer: Math.random(), vx: clone.vx, vy: clone.vy });
      }
        
      setTimeout(() => {
          yejunClones.forEach(c => {
              spawnParticles(c.el.x, c.el.y, 'dust');
              c.el.remove();
          });
          yejunClones = [];
      }, 15000); 
  }

  function triggerGanghuiGundam() {
      showFloatText("ü§ñ Í±¥Îã¥ Î™®Îìú Í∞ÄÎèô!");
      player.style.backgroundImage = `url('Gundam.png')`;
        
      const flash = document.getElementById('flashEffect');
      flash.style.background = "rgba(0, 100, 255, 0.5)";
      flash.style.opacity = '1';
      setTimeout(() => flash.style.opacity = '0', 300);

      gundamAura = document.createElement('div');
      gundamAura.className = 'gundam-aura';
      gameArea.appendChild(gundamAura);
        
      activeEffects.gundam = 15;
        
      for(let i=0; i<6; i++) {
          spawnFunnel();
      }
  }
    
  function spawnFunnel() {
      if(funnels.length >= 8) return;
      const f = document.createElement('div');
      f.className = 'funnel-unit';
      f.x = -50; f.y = randBetween(50, gameArea.offsetHeight-100);
      f.style.left = f.x + 'px';
      f.style.top = f.y + 'px';
      f.tx = randBetween(100, gameArea.offsetWidth-100);
      f.ty = randBetween(50, gameArea.offsetHeight-100);
      f.timer = 0;
      f.fireCD = Math.random() * 4;
      gameArea.appendChild(f);
      funnels.push(f);
  }

  function useAbility(e) {
    if(e) e.stopPropagation();
    if(!running) return;

    // [Ìå®Ïπò] ÌûàÎì† Ïä§ÌÇ® Î≥ÄÏã† ÌÜ†Í∏Ä Î°úÏßÅ
    if (HIDDEN_SKIN_CODES.includes(currentSkin)) {
        if (abilityCD > 0 && !hiddenTransformActive) {
             showFloatText("‚è≥ Ïø®ÌÉÄÏûÑ Ï§ë");
             return;
        }
        toggleHiddenTransform();
        return;
    }

    if(abilityCD > 0) return;
    let reqLvl = activeSkillLevel[currentSkin] || 1;
    if (skinLvl < reqLvl) { showFloatText("üîí Ïä§ÌÇ¨ ÎØ∏Í∞úÎ∞© (Lv." + reqLvl + ")"); return; }
    
    const s = SKIN_DATA[currentSkin];
    // Í∏∞Ï°¥ Ïä§ÌÇ® Î°úÏßÅÎì§
    if(currentSkin === 'noel') { activeEffects.noelLaser = 10; showFloatText("üåä ÏóêÎÑàÏßÄ Ìåå!"); playSound('clear'); } 
    else if(currentSkin === 'jaeguk') { triggerJaegukBobas(); }
    else if(currentSkin === 'hahwi') { triggerHahwiSkill(); }
    else if(currentSkin === 'jihye') { triggerJihyeSkill(); }
    else if(currentSkin === 'jun') { triggerJunSkill(); }
    else if(currentSkin === 'yejun') { activeEffects.fly = 20; targetY = playerObj.y; const w = document.createElement('div'); w.className = 'yejun-wing'; player.appendChild(w); showFloatText("‚úàÔ∏è Î¨¥Ï§ëÎ†• Ï†úÏñ¥"); } 
    else if(currentSkin === 'jieun') { triggerJieunMusicWave(); }
    else if(currentSkin === 'jeonchan') { triggerJeonchanHammer(); }
    else if(currentSkin === 'ganghui') { triggerGanghuiGundam(); }
    else if(currentSkin === 'stephanie') { triggerStephanieSkill(); }

    abilityCD = s.cd;
  }
    
  function updateBuffUI(delta) {
    const buffContainer = document.getElementById("buffArea"); 
    let html = "";
    if(collectionBuff) html += `<div class="buff-tag" style="border-color:#e040fb; order:999;">‚ú® Ïª¨Î†âÏÖò Î≥¥ÎÑàÏä§ (Faith +10%)</div>`;

    // 1. ÌîºÎ≤Ñ ÌÉÄÏûÑ Î°úÏßÅ
    if (!isFeverTime) {
        document.getElementById("feverFill").style.width = feverGauge + "%";
        if(feverGauge >= MAX_FEVER) startFeverTime();
    } else {
        feverGauge -= (delta * 20);
        document.getElementById("feverFill").style.width = feverGauge + "%";
        if(feverGauge <= 0) endFeverTime();
    }

    // 2. [Ìå®Ïπò] ÌûàÎì† Ïä§ÌÇ® 3Ï¢Ö Ï†ÑÏö© Î°úÏßÅ (Ìå®ÏãúÎ∏å ÌûêÎßÅ + Î≥ÄÏã† Í¥ÄÎ¶¨)
    if (HIDDEN_SKIN_CODES.includes(currentSkin) && running) {
        hiddenHealTimer += delta;
        if (hiddenHealTimer >= 40.0) {
            triggerHiddenHeal();
            hiddenHealTimer = 0;
        }
        if (hiddenTransformActive) {
            consumeFaithPerSec(5, delta); 
            
            if (currentSkin === 'Hidden_Skin1') {
                if(hiddenAttackCooldown > 0) hiddenAttackCooldown -= delta;
                updateSubActionBtnForHidden1();
            } else if (currentSkin === 'Hidden_Skin2') {
                spawnAeranFlowers(delta);
            } else if (currentSkin === 'Hidden_Skin3') {
                updateJongrakSquad(delta);
            }
        }
    }

    // 3. ÌôúÏÑ±ÌôîÎêú Î≤ÑÌîÑ(ÏïÑÏù¥ÌÖú/Ïä§ÌÇ¨) ÌëúÏãú Î°úÏßÅ
    for(let k in activeEffects) {
        if(activeEffects[k] > 0) {
            activeEffects[k] -= delta;
            
            // Î≤ÑÌîÑ Ï¢ÖÎ£å Ïãú Ï≤òÎ¶¨
            if(k === 'summon' && currentSkin === 'jieun' && activeEffects[k] <= 0) deactivateJieunBuff();
            if(k === 'noelLaser' && activeEffects[k] <= 0) {
                const beam = document.getElementById('noelBeam');
                if(beam) beam.remove();
                gameArea.classList.remove('shake-screen');
            }
            if(k === 'sandstorm' && activeEffects[k] <= 0) {
                document.getElementById('sandstormOverlay').style.opacity = '0';
                gameArea.classList.remove('sandstorm-mode'); gameArea.classList.remove('sand-bg');
            }
            if(k === 'jihyeSquad' && activeEffects[k] <= 0) endJihyeSkill();
            if(k === 'bobaTime' && activeEffects[k] <= 0) { bobas.forEach(b => b.remove()); bobas = []; activeEffects.invincible = 0; }
            if(k === 'gundam' && activeEffects[k] <= 0) { 
                player.style.backgroundImage = `url('skin_ganghui.png')`; 
                if(gundamAura) { gundamAura.remove(); gundamAura = null; }
            }
            if(k === 'fly' && currentSkin === 'yejun' && activeEffects[k] <= 0) {
                const w = player.querySelector('.yejun-wing'); if(w) w.remove();
            }
            if(k === 'cakeWorld' && activeEffects[k] <= 0) {
                document.getElementById('cakeBg').style.opacity = '0'; cakes.forEach(c => c.remove()); cakes = [];
            }
            if(k === 'musicWave' && activeEffects[k] <= 0) {
                musicWaveActive = false; document.getElementById('jieunWaveBg').style.opacity = '0'; musicNotes.forEach(n => n.remove()); musicNotes = [];
            }
            if(k === 'giant' && activeEffects[k] <= 0) {
                player.style.transform = "scale(1)"; const aura = player.querySelector('.noel-aura'); if(aura) aura.remove();
            }

            // Î≤ÑÌîÑ ÌÉúÍ∑∏ ÏÉùÏÑ±
            if(activeEffects[k] > 0) {
                let color = "#fff"; let icon = ""; let label = k;
                if(k === 'invincible') { color = "#ffd700"; icon = "üõ°Ô∏è"; label = "Î¨¥Ï†Å"; }
                else if(k === 'turbo') { color = "#00e5ff"; icon = "üöÄ"; label = "ÌÑ∞Î≥¥"; }
                else if(k === 'slow') { color = "#90ee90"; icon = "üçÉ"; label = "Í∞êÏÜç"; }
                else if(k === 'fly') { color = "#87ceeb"; icon = "‚úàÔ∏è"; label = "ÎπÑÌñâ"; }
                else if(k === 'revive') { color = "#ff69b4"; icon = "üëº"; label = "Î∂ÄÌôú"; }
                else if(k === 'noelLaser') { color = "#00ffff"; icon = "üåä"; label = "ÏóêÎÑàÏßÄÌåå"; }
                else if(k === 'summon') { color = "#e040fb"; icon = "‚ú®"; label = "ÎÖ∏Ïóò ÏÜåÌôò"; }
                else if(k === 'bobaTime') { color = "#795548"; icon = "üßã"; label = "Î≥¥Î∞î ÌÉÄÏûÑ"; }
                else if(k === 'sandstorm') { color = "#d2b48c"; icon = "üå™Ô∏è"; label = "Î™®ÎûòÌè≠Ìíç"; }
                else if(k === 'jihyeSquad') { color = "#ff9100"; icon = "‚öîÔ∏è"; label = "Î∞úÌÇ§Î¶¨"; }
                else if(k === 'gundam') { color = "#0000ff"; icon = "ü§ñ"; label = "Í±¥Îã¥"; }
                else if(k === 'cakeWorld') { color = "#ff69b4"; icon = "üç∞"; label = "ÏºÄÏù¥ÌÅ¨"; }
                else if(k === 'musicWave') { color = "#ff00ff"; icon = "üéµ"; label = "ÏùåÍ≥ÑÌååÎèÑ"; }
                
                if(k !== 'magnet') html += `<div class="buff-tag" style="border-color:${color}">${icon} ${label} ${Math.ceil(activeEffects[k])}s</div>`;
            }
        } else { activeEffects[k] = 0; }
    }
    
    // 4. [Î≥µÍµ¨Îê®] Í∏∞Ï°¥ ÏùºÎ∞ò Ïä§ÌÇ® Ìå®ÏãúÎ∏å Ïø®ÌÉÄÏûÑ ÌëúÏãú UI
    const passiveSkins = ['jeonchan', 'noel', 'haeun', 'hahwi', 'jihye', 'jun', 'stephanie', 'ganghui', 'jieun', 'yejun'];
    if(SKIN_DATA[currentSkin].type === "Passive" || passiveSkins.includes(currentSkin)) {
        let limit = PASSIVE_COOLDOWNS[currentSkin] || 30;
        let label = "Ìå®ÏãúÎ∏å";
        let timerVal = 0;

        if (currentSkin === 'haeun') {
            if(haeunShieldTimer > 0 && haeunShieldTimer < 10) {
                 html += `<div class="buff-tag passive-cd">üõ°Ô∏è Ïâ¥Îìú ${Math.ceil(haeunShieldTimer - 10)}s</div>`;
            }
            if(haeunLifeTimer > 0 && haeunLifeTimer < 25) {
                 html += `<div class="buff-tag passive-cd">üíñ Ï≤¥Î†•ÌöåÎ≥µ ${Math.ceil(haeunLifeTimer - 25)}s</div>`;
            }
        } else {
            if(currentSkin === 'jeonchan') { timerVal = jeonchanTimer; label = "‚ö° Î≤àÍ∞úÏÜåÌôò"; }
            else if(currentSkin === 'jieun') { timerVal = jieunNoelTimer; label = "üõ°Ô∏è ÏÜåÌôò"; }
            else if(currentSkin === 'jihye') { timerVal = jihyePassiveTimer; label = "üíñ Î†àÏä§ÌÅê"; }
            else if(currentSkin === 'jun') { timerVal = junLambTimer; label = "üêë ÏñëÏÜåÌôò"; }
            else if(currentSkin === 'noel') { timerVal = noelGiantTimer; label = "ü¶∂ Í±∞ÎåÄÌôî"; }
            else if(currentSkin === 'hahwi') { timerVal = hahwiStoneTimer; label = "üíé Ïù∏ÌîºÎãàÌã∞Ïä§ÌÜ§"; }
            else if(currentSkin === 'yejun') { timerVal = yejunCloneTimer; label = "üí® Î∂ÑÏã†Ïà†"; }
            else if(currentSkin === 'stephanie') { timerVal = stephanieHeartTimer; label = "‚ù§Ô∏è Ï≤¥Î†•ÌöåÎ≥µ"; }
            else if(currentSkin === 'ganghui') { timerVal = ganghuiPanelTimer; label = "üõ∞Ô∏è ÌåêÎÑ¨ÏÜåÌôò"; }

            if(timerVal > 0 && timerVal < limit) {
                 let remain = Math.ceil(timerVal - limit); 
                 html += `<div class="buff-tag passive-cd">${label} ${remain}s</div>`;
            }
        }
    }

    // 5. ÏµúÏ¢Ö HTML Ï†ÅÏö©
    buffContainer.innerHTML = html;

    // 6. Ïâ¥Îìú Î∞è Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    if(shieldCooldown > 0) { shieldCooldown -= delta; if(shieldCooldown <= 0) subActionBtn.classList.remove('cooldown'); }
    updateAbilityBtn(delta); 
    
    // [Ìå®Ïπò] ÌûàÎì†1Î≤à Î≥ÄÏã† ÏÉÅÌÉúÍ∞Ä ÏïÑÎãê ÎïåÎßå ÏùºÎ∞ò Î≤ÑÌäº ÏóÖÎç∞Ïù¥Ìä∏
    if (!(currentSkin === 'Hidden_Skin1' && hiddenTransformActive)) {
        updateSubActionButtonUI();
    }
  }

  function startFeverTime() {
      isFeverTime = true; feverGauge = 100;
      activeEffects.invincible = 5; activeEffects.turbo = 5; activeEffects.magnet = 5;
      gameArea.classList.add("fever-mode"); player.classList.add("fever-active");
      showFloatText("üî• ÏÑ±Î†π Ï∂©Îßå! (FEVER)"); playSound('clear');
  }

  function endFeverTime() {
      isFeverTime = false; feverGauge = 0;
      activeEffects.invincible = 0; activeEffects.turbo = 0; activeEffects.magnet = 0;
      gameArea.classList.remove("fever-mode"); player.classList.remove("fever-active");
  }

  function updateSubActionButtonUI() {
      if (isBossBattle) {
          subActionBtn.style.display = 'flex'; subActionBtn.className = 'btn-defence'; subActionBtn.innerText = "Defence"; 
      } else if (distance >= 200) {
          subActionBtn.style.display = 'flex'; subActionBtn.className = 'btn-attack'; subActionBtn.innerText = "Attack";
      } else { subActionBtn.style.display = 'none'; }
  }

  function updateAbilityBtn(dt) {
    if(abilityCD > 0) { abilityCD -= dt; abilityBtn.classList.add('cooldown'); abilityBtn.innerHTML = Math.ceil(abilityCD); } 
    else { abilityBtn.classList.remove('cooldown'); abilityBtn.innerHTML = "SKILL"; }
  }

  // [ÏàòÏ†ï 1] ÏùºÏùº ÎØ∏ÏÖò UI ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò ÏÇ≠Ï†ú Î∞è Ï≤¥ÌÅ¨ Ìï®Ïàò ÏÇ≠Ï†ú

  function gameLoop(now) {
    if (!running) return;
    const delta = (now - lastTime) / 1000; lastTime = now;
    const safeDelta = Math.min(delta, 0.05);

    try {
        updateBuffUI(safeDelta);
        // [ÏàòÏ†ï 1] ÎØ∏ÏÖò Ï≤¥ÌÅ¨ Î°úÏßÅ ÏÇ≠Ï†ú
        
        if(coinCombo > 0) {
            coinComboTimer += safeDelta;
            if(coinComboTimer > 0.5) { 
                coinCombo = 0;
                coinComboTimer = 0;
            }
        }

        if(jihyeSphereActive && jihyeSphereEl) {
            jihyeSphereEl.style.left = (playerObj.x + 30) + 'px';
            jihyeSphereEl.style.top = (gameArea.offsetHeight - playerObj.y - 30) + 'px';
        }
        if(jihyeEndSphereEl) {
            jihyeEndSphereEl.style.left = (playerObj.x + 30) + 'px';
            jihyeEndSphereEl.style.top = (gameArea.offsetHeight - playerObj.y - 30) + 'px';
        }

        if(gundamAura) {
             gundamAura.style.left = (playerObj.x + 30) + 'px';
             gundamAura.style.top = (gameArea.offsetHeight - playerObj.y - 30) + 'px';
        }

        updateLamb(safeDelta);
        
        if(hammerObj) {
            hammerObj.x += hammerObj.vx * safeDelta;
            hammerObj.style.left = hammerObj.x + 'px';
            
            if(Math.random() < 0.3) {
                 const spark = document.createElement('div');
                 spark.className = 'hammer-lightning';
                 spark.style.left = (hammerObj.x + 200) + 'px'; 
                 spark.style.top = (hammerObj.y + 200) + 'px';
                 spark.style.transform = `rotate(${randBetween(-180, 180)}deg)`;
                 gameArea.appendChild(spark);
                 setTimeout(() => spark.remove(), 300);
            }

            if(hammerObj.x > gameArea.offsetWidth + 400) { 
                hammerObj.remove();
                hammerObj = null;
                gameArea.classList.remove('gentle-shake');
            } else {
                const hRect = { left: hammerObj.x + 50, right: hammerObj.x + 350, top: hammerObj.y + 50, bottom: hammerObj.y + 350 };
                obstacles.forEach(o => {
                    if(!o.destroyed && o.x < gameArea.offsetWidth) {
                        const oRect = o.getBoundingClientRect();
                        if(hRect.right > oRect.left && hRect.left < oRect.right) {
                            o.destroyed = true;
                            spawnExplosionEffect(o.x, gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - 50);
                            o.remove();
                        }
                    }
                });
                enemies.forEach(e => {
                    if(!e.isDead && e.x < gameArea.offsetWidth) {
                        const eRect = e.getBoundingClientRect();
                        if(hRect.right > eRect.left && hRect.left < eRect.right) {
                            e.isDead = true;
                            spawnExplosionEffect(e.x, e.y);
                            e.remove();
                        }
                    }
                });
            }
        }

        if(currentSkin === 'jeonchan' && running) {
          if (skinLvl >= 1) {  
          jeonchanTimer += safeDelta;
            if(jeonchanTimer >= 15.0) {
                triggerJeonchanLightning();
                jeonchanTimer = 0;
            }
        }
          }

        if(currentSkin === 'jieun' && running) {
          if (skinLvl >= 2) {  
          if(activeEffects.summon <= 0) { 
                jieunNoelTimer += safeDelta;
                if(jieunNoelTimer >= 40.0) {
                    activateJieunBuff(); 
                    jieunNoelTimer = 0;
                }
            }
        }
          }

        if(currentSkin === 'haeun' && running && !isBossBattle) {
          if (skinLvl >= 1) {  
          if(!haeunShieldActive) {
                haeunShieldTimer += safeDelta;
                if(haeunShieldTimer >= 10.0) {
                    haeunShieldActive = true;
                    haeunShieldTimer = 0;
                    createHaeunShield();
                    showFloatText("üõ°Ô∏è Î≥¥Ìò∏Îßâ ÏÉùÏÑ±");
                }
            }
            haeunLifeTimer += safeDelta;
            if(haeunLifeTimer >= 25.0) {
                haeunLifeTimer = 0;
                if(life < maxLife) {
                    life++;
                    document.getElementById("lifeText").innerText = life;
                    showHealEffect();
                    showFloatText("üíñ ÏÉùÎ™ÖÎ†• ÌöåÎ≥µ");
                }
            }
        }
          }

        if(currentSkin === 'jihye' && running) {
          if (skinLvl >= 1) {  
          jihyePassiveTimer += safeDelta;
            if(jihyePassiveTimer >= 25.0) {
                triggerJihyeHeal();
                jihyePassiveTimer = 0;
            }
        }
          }

        if(currentSkin === 'jun' && running && !isJunTimeTravel) {
          if (skinLvl >= 1) {
            junLambTimer += safeDelta;
            if(junLambTimer >= 30.0) {
                spawnLamb();
                junLambTimer = 0;
            }
        }
          }

        if(currentSkin === 'noel' && running) {
          if (skinLvl >= 1) {
            noelGiantTimer += safeDelta;
            if(noelGiantTimer >= 30.0) {
                showFloatText("‚ö° Ï¥à Í±∞ÎåÄÌôî!");
                activeEffects.giant = 10; 
                player.style.transform = "scale(2)";
                
                const aura = document.createElement('div'); aura.className = 'noel-aura';
                player.appendChild(aura);
                noelGiantTimer = 0;
            }
        }
          }

        if(currentSkin === 'hahwi' && running) {
          if (skinLvl >= 1) {
            hahwiStoneTimer += safeDelta;
            if(hahwiStoneTimer >= 30.0) {
                showFloatText("üíé Ïù∏ÌîºÎãàÌã∞ Ïä§ÌÜ§!");
                for(let i=0; i<6; i++) {
                    const stone = document.createElement('div');
                    stone.className = 'infinity-stone';
                    const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
                    stone.style.color = colors[i%6];
                    stone.style.background = colors[i%6];
                    stone.angle = (i/6)*Math.PI*2;
                    stone.radius = 80;
                    stone.state = 'orbit'; 
                    
                    stone.lifeTime = 10.0;
                    
                    const px = playerObj.x + 30; const py = gameArea.offsetHeight - playerObj.y - 30;
                    stone.style.left = px + 'px';
                    stone.style.top = py + 'px';
                    gameArea.appendChild(stone);
                    infinityStones.push(stone);
                }
                hahwiStoneTimer = 0;
            }
        }
          }
          
        
        if(currentSkin === 'ganghui' && running) {
          if (skinLvl >= 1) {  
          if(funnels.length === 0 && ganghuiPanelTimer === 0) spawnFunnel();
            ganghuiPanelTimer += safeDelta;
            if(ganghuiPanelTimer >= 10.0) {
                spawnFunnel();
                ganghuiPanelTimer = 0;
            }
        }
          }
        
        if(currentSkin === 'yejun' && running) {
          if (skinLvl >= 2) {
            yejunCloneTimer += safeDelta;
            if(yejunCloneTimer >= 50.0) {
                triggerYejunClones();
                yejunCloneTimer = 0;
            }
        }
          }
        
        if(currentSkin === 'stephanie' && running) {
          if (skinLvl >= 1) {
            stephanieHeartTimer += safeDelta;
            if(stephanieHeartTimer >= 30.0) {
                if(life < maxLife) {
                    life++;
                    document.getElementById("lifeText").innerText = life;
                    showFloatText("üíñ +1 Life");
                }
                const heart = document.createElement('div');
                heart.className = 'heart-emit'; heart.innerText = "‚ù§Ô∏èÌûêÎßÅ";
                heart.style.left = (playerObj.x+15)+'px'; heart.style.top = (gameArea.offsetHeight - playerObj.y - 40)+'px';
                gameArea.appendChild(heart);
                setTimeout(()=>heart.remove(), 1000);
                stephanieHeartTimer = 0;
            }
        }
          }
        
        if(activeEffects.noelLaser > 0) {
            const beam = document.getElementById('noelBeam');
            if(beam) { beam.style.bottom = (playerObj.y - 20) + "px"; }
        }

        if(activeEffects.jihyeSquad > 0) {
            jihyeUnits.forEach(u => {
                u.moveTimer += safeDelta;
                if(u.moveTimer > 1.0) {
                    u.tx = (gameArea.offsetWidth / 2) + randBetween(-200, 200);
                    u.ty = (gameArea.offsetHeight / 2) + randBetween(-200, 200);
                    u.moveTimer = 0;
                }
                u.x += (u.tx - u.x) * 0.05;
                u.y += (u.ty - u.y) * 0.05;
                u.style.left = u.x + 'px';
                u.style.top = u.y + 'px';
                
                u.fireTimer += safeDelta;
                if(u.fireTimer > 0.6) { 
                      const m = document.createElement('div'); m.className = 'jihye-missile';
                      m.x = u.x + 25; m.y = u.y + 25; m.w=24; m.h=24;
                      m.style.left = m.x + 'px'; m.style.top = m.y + 'px';
                      m.vx = 700; m.vy = 0; 
                      gameArea.appendChild(m); jihyeMissiles.push(m);
                      u.fireTimer = 0;
                }
            });
        }
        
        if(infinityStones.length > 0) {
            const px = playerObj.x + 30; const py = gameArea.offsetHeight - playerObj.y - 30;
            for(let i=infinityStones.length-1; i>=0; i--) {
                const s = infinityStones[i];

                s.lifeTime -= safeDelta;
                if (s.lifeTime <= 0) {
                    spawnParticles(parseFloat(s.style.left), parseFloat(s.style.top), 'dust');
                    s.remove();
                    infinityStones.splice(i, 1);
                    continue; 
                }

                let sx = parseFloat(s.style.left);
                let sy = parseFloat(s.style.top);

                if(s.state === 'orbit') {
                    s.angle += 3 * safeDelta;
                    const tx = px + Math.cos(s.angle) * s.radius - 12;
                    const ty = py + Math.sin(s.angle) * s.radius - 12;
                    sx += (tx-sx)*0.1;
                    sy += (ty-sy)*0.1;

                    let found = null;
                    for(let k=0; k<obstacles.length; k++){
                        if(!obstacles[k].destroyed && obstacles[k].x < gameArea.offsetWidth && !obstacles[k].isTargeted){
                            found = obstacles[k]; break;
                        }
                    }
                    if(!found){
                        for(let k=0; k<enemies.length; k++){
                            if(!enemies[k].isDead && !enemies[k].isTargeted){
                                found = enemies[k]; break;
                            }
                        }
                    }
                    if(found) { s.target = found; found.isTargeted = true; s.state = 'attack'; }
                } 
                else if(s.state === 'attack') {
                    if(!s.target || s.target.destroyed || s.target.isDead) { s.state = 'return'; }
                    else {
                        const tx = s.target.x + 30;
                        const ty = s.target.y || (gameArea.offsetHeight - parseFloat(s.target.style.bottom || 0) - 50);
                        
                        sx += (tx - sx) * 0.08; 
                        sy += (ty - sy) * 0.08;
                        
                        if(Math.hypot(tx-sx, ty-sy) < 40) {
                            spawnExplosionEffect(tx, ty);
                            spawnFaithCoins(tx, ty, 5, false, false);
                            if(s.target.classList.contains('obstacle')) { s.target.destroyed = true; s.target.remove(); }
                            else { s.target.isDead = true; s.target.remove(); }
                            s.state = 'return';
                        }
                    }
                }
                else if(s.state === 'return') {
                      sx += (px - sx) * 0.1;
                      sy += (py - sy) * 0.1;
                      if(Math.hypot(px-sx, py-sy) < 50) s.state = 'orbit';
                }
                s.style.left = sx + 'px'; s.style.top = sy + 'px';
            }
        }
        
        if(activeEffects.bobaTime > 0 && bobas.length > 0) {
            const px = playerObj.x + 30; const py = gameArea.offsetHeight - playerObj.y - 30;
            
            bobas.forEach(b => {
                let bx = parseFloat(b.style.left) || px;
                let by = parseFloat(b.style.top) || py;

                if(b.state === 'orbit') {
                    b.angle += 3 * safeDelta;
                    const tx = px + Math.cos(b.angle) * b.radius - 9;
                    const ty = py + Math.sin(b.angle) * b.radius - 9;
                    bx += (tx-bx)*0.1;
                    by += (ty-by)*0.1;
                    
                    let found = null;
                      for(let k=0; k<obstacles.length; k++){
                        if(!obstacles[k].destroyed && obstacles[k].x < gameArea.offsetWidth && !obstacles[k].isTargeted){
                            found = obstacles[k]; break;
                        }
                    }
                    if(!found){
                        for(let k=0; k<enemies.length; k++){
                            if(!enemies[k].isDead && !enemies[k].isTargeted){
                                found = enemies[k]; break;
                            }
                        }
                    }
                    if(found) { b.target = found; found.isTargeted = true; b.state = 'attack'; }
                } 
                else if(b.state === 'attack') {
                    if(!b.target || b.target.destroyed || b.target.isDead) { b.state = 'return'; }
                    else {
                        const tx = b.target.x + 30;
                        const ty = b.target.y || (gameArea.offsetHeight - parseFloat(b.target.style.bottom || 0) - 50);
                        
                        bx += (tx - bx) * 0.08;
                        by += (ty - by) * 0.08;
                        
                        if(Math.hypot(tx-bx, ty-by) < 40) {
                            spawnExplosionEffect(tx, ty);
                            spawnFaithCoins(tx, ty, 5, false, false);
                            if(b.target.classList.contains('obstacle')) { b.target.destroyed = true; b.target.remove(); }
                            else { b.target.isDead = true; b.target.remove(); }
                            b.state = 'return';
                        }
                    }
                }
                else if(b.state === 'return') {
                      bx += (px - bx) * 0.1;
                      by += (py - by) * 0.1;
                      if(Math.hypot(px-bx, py-by) < 50) b.state = 'orbit';
                }
                b.style.left = bx + 'px'; b.style.top = by + 'px';
            });
        }

        funnels.forEach(f => {
            f.x += (f.tx - f.x)*0.02;
            f.y += (f.ty - f.y)*0.02;
            f.style.left = f.x + 'px';
            f.style.top = f.y + 'px';

            if(Math.abs(f.tx - f.x) < 20) {
                f.tx = randBetween(50, gameArea.offsetWidth-50);
                f.ty = randBetween(50, gameArea.offsetHeight-50);
            }
            
            let crashed = false;
            const fRect = {x: f.x, y: f.y, w: 40, h: 40};
            
            for(let i=obstacles.length-1; i>=0; i--) {
                if(crashed) break;
                const o = obstacles[i];
                const oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - (parseFloat(o.style.height));
                const oRect = {x: o.x, y: oY, w: 60, h: parseFloat(o.style.height)};
                
                if(!o.destroyed && isColliding(fRect, oRect)) {
                      o.destroyed = true; o.remove(); obstacles.splice(i,1);
                      spawnExplosionEffect(f.x, f.y);
                      crashed = true;
                }
            }
            if(!crashed) {
                for(let i=enemies.length-1; i>=0; i--) {
                    const e = enemies[i];
                    const eRect = {x: e.x, y: e.y, w: 60, h: 60};
                    if(!e.isDead && isColliding(fRect, eRect)) {
                        e.isDead = true; e.remove(); enemies.splice(i,1);
                        spawnExplosionEffect(f.x, f.y);
                        crashed = true;
                        break;
                    }
                }
            }
            if(crashed) { 
                f.remove(); 
                funnels.splice(funnels.indexOf(f), 1); 
                return; 
            }

            f.timer += safeDelta;
            if(f.timer > f.fireCD) {
                const l = document.createElement('div'); l.className = 'funnel-laser';
                l.style.left = (f.x + 20) + 'px'; l.style.top = (f.y+20) + 'px';
                l.style.width = '100vw'; 
                gameArea.appendChild(l);
                l.animate([{opacity:1}, {opacity:0}], {duration:300}).onfinish = () => l.remove();
                
                let hit = false;
                obstacles.forEach(o => {
                    const oTop = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
                    const oBottom = gameArea.offsetHeight - parseFloat(o.style.bottom || 0);
                    if(!hit && oTop < f.y+60 && oBottom > f.y-20 && !o.destroyed && o.x < gameArea.offsetWidth) {
                        o.destroyed = true;
                        spawnExplosionEffect(o.x, oTop);
                        o.remove();
                        hit = true;
                    }
                });
                enemies.forEach(e => {
                      if(!hit && e.y < f.y+60 && e.y+60 > f.y-20 && !e.isDead) {
                          e.isDead = true;
                          spawnExplosionEffect(e.x, e.y);
                          e.remove();
                          hit = true;
                      }
                });
                
                f.timer = 0; f.fireCD = 4.0;
            }
        });
        
        yejunClones.forEach(c => {
            c.el.x += c.vx; 
            c.el.y += c.vy;

            if(c.el.x < 0 || c.el.x > gameArea.offsetWidth) c.vx *= -1;
            if(c.el.y < 20 || c.el.y > gameArea.offsetHeight) c.vy *= -1;

            c.el.style.left = c.el.x + 'px';
            c.el.style.bottom = c.el.y + 'px';
            
            const cRect = {x: c.el.x, y: gameArea.offsetHeight - c.el.y - 50, w: 50, h: 50};
            obstacles.forEach(o => {
                if(!o.destroyed) {
                    const oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
                    const oRect = {x: o.x, y: oY, w: 60, h: parseFloat(o.style.height)};
                    if(isColliding(cRect, oRect)) {
                        o.destroyed = true;
                        spawnExplosionEffect(o.x, oY);
                        o.remove();
                    }
                }
            });
            enemies.forEach(e => {
                if(!e.isDead) {
                    const eRect = {x: e.x, y: e.y, w: 60, h: 60};
                    if(isColliding(cRect, eRect)) {
                        e.isDead = true;
                        spawnExplosionEffect(e.x, e.y);
                        e.remove();
                    }
                }
            });
            
            c.fireTimer += safeDelta;
            if(c.fireTimer > 0.8) {
                const m = document.createElement("div"); m.classList.add("player-missile");
                m.style.left = (c.el.x + 50) + 'px'; 
                m.style.top = (gameArea.offsetHeight - c.el.y - 20) + 'px';
                gameArea.appendChild(m); playerMissiles.push(m);
                c.fireTimer = 0;
            }
        });
        
        if(activeEffects.cakeWorld > 0) {
            cakeDropTimer += safeDelta;
            if(cakeDropTimer > 0.3) {
                const c = document.createElement('div');
                c.className = 'cake-item';
                c.style.backgroundImage = `url('Cake${Math.ceil(Math.random()*3)}.png')`;
                c.y = -60;
                c.x = randBetween(50, gameArea.offsetWidth-50);
                c.style.left = c.x + 'px';
                c.style.top = c.y + 'px';
                c.w = 60; c.h = 60;
                gameArea.appendChild(c);
                cakes.push(c);
                cakeDropTimer = 0;
            }
        }
        for(let i=cakes.length-1; i>=0; i--) {
            const c = cakes[i];
            c.y += 300 * safeDelta;
            c.style.top = c.y + 'px';
            if(c.y > gameArea.offsetHeight) { c.remove(); cakes.splice(i,1); continue; }
            
            const cRect = {x: c.x, y: c.y, w: 60, h: 60};
            let hit = false;
            for(let j=obstacles.length-1; j>=0; j--) {
                const o = obstacles[j];
                const oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
                const oRect = {x: o.x, y: oY, w: 60, h: parseFloat(o.style.height)};
                
                if(!o.destroyed && isColliding(cRect, oRect)) {
                    o.destroyed = true;
                    spawnExplosionEffect(o.x, oY);
                    spawnFaithCoins(o.x, oY, Math.floor(randBetween(1,6)), false, false);
                    o.remove(); obstacles.splice(j,1);
                    hit = true;
                    break;
                }
            }
            if(hit) { c.remove(); cakes.splice(i,1); }
        }
        
        if(musicWaveActive) {
            musicNoteTimer += safeDelta;
            if(musicNoteTimer > 0.2) {
                const n = document.createElement('div');
                n.className = 'music-note';
                n.innerText = ['‚ô™', '‚ô´', '‚ô¨', '‚ô©'][Math.floor(Math.random()*4)];
                n.style.color = `hsl(${Math.random()*360}, 100%, 50%)`;
                n.x = -30; n.y = randBetween(50, gameArea.offsetHeight-100);
                n.w = 40; n.h = 40;
                n.style.left = n.x + 'px';
                n.style.top = n.y + 'px';
                gameArea.appendChild(n);
                musicNotes.push(n);
                musicNoteTimer = 0;
            }
        }
        for(let i=musicNotes.length-1; i>=0; i--) {
            const n = musicNotes[i];
            n.x += 400 * safeDelta;
            n.style.left = n.x + 'px';
            if(n.x > gameArea.offsetWidth) { n.remove(); musicNotes.splice(i,1); continue; }
            
            const nRect = {x: n.x, y: n.y, w: 40, h: 40};
            let hit = false;
            for(let j=obstacles.length-1; j>=0; j--) {
                const o = obstacles[j];
                const oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
                const oRect = {x: o.x, y: oY, w: 60, h: parseFloat(o.style.height)};
                if(!o.destroyed && isColliding(nRect, oRect)) {
                    o.destroyed = true;
                    spawnExplosionEffect(o.x, oY);
                    spawnFaithCoins(o.x, oY, Math.floor(randBetween(1,6)), false, false); 
                    o.remove(); obstacles.splice(j,1);
                    hit = true;
                    break;
                }
            }
            if(!hit) {
                for(let k=enemies.length-1; k>=0; k--) {
                    const e = enemies[k];
                    const eRect = {x: e.x, y: e.y, w: 60, h: 60};
                    if(!e.isDead && isColliding(nRect, eRect)) {
                        e.isDead = true;
                        spawnExplosionEffect(e.x, e.y);
                        spawnFaithCoins(e.x, e.y, Math.floor(randBetween(1,6)), false, false); 
                        e.remove(); enemies.splice(k,1);
                        hit = true;
                        break;
                    }
                }
            }
            if(hit) { n.remove(); musicNotes.splice(i,1); }
        }

        if(jihyeMissiles.length > 0) {
            for(let i=jihyeMissiles.length-1; i>=0; i--) {
                const m = jihyeMissiles[i];
                m.x += m.vx * safeDelta;
                m.y += m.vy * safeDelta;
                m.style.left = m.x + 'px';
                m.style.top = m.y + 'px';
                
                if(m.x > gameArea.offsetWidth || m.x < -50 || m.y < -50 || m.y > gameArea.offsetHeight + 50) {
                    m.remove();
                    jihyeMissiles.splice(i, 1);
                    continue;
                }
                
                let hit = false;
                const mRect = {x: m.x, y: m.y, w: 24, h: 24};
                
                for(let j=obstacles.length-1; j>=0; j--) {
                    const o = obstacles[j];
                    const oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
                    const oRect = {x: o.x, y: oY, w: 60, h: parseFloat(o.style.height)};
                    
                    if(!o.destroyed && isColliding(mRect, oRect)) {
                        o.destroyed = true;
                        spawnExplosionEffect(o.x+30, oY+30);
                        spawnFaithCoins(o.x, oY, 5, false, true);
                        o.remove(); obstacles.splice(j, 1);
                        hit = true;
                        break;
                    }
                }
                if(hit) { m.remove(); jihyeMissiles.splice(i, 1); }
            }
        }
        
        if(activeEffects.sandstorm > 0) {
             const sandBg = document.getElementById('gameArea');
             if(sandBg.classList.contains('sand-bg')) {
                 sandBgX -= gameSpeed * safeDelta * 0.5;
                 sandBg.style.backgroundPosition = `${sandBgX}px 0`;
             }

             const pX = playerObj.x; const pY = gameArea.offsetHeight - playerObj.y - playerObj.h;
             obstacles.forEach(o => {
                const oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
                const dist = Math.hypot(o.x - pX, oY - pY);
                if(!o.destroyed && dist < 250) {
                    o.destroyed = true;
                    const dust = document.createElement('div'); dust.className = 'dust-effect';
                    dust.style.left = o.x+'px'; dust.style.top = oY+'px';
                    gameArea.appendChild(dust); setTimeout(()=>dust.remove(), 600);
                    spawnFaithCoins(o.x, oY, Math.floor(randBetween(1,6)), false, false);
                    o.remove();
                }
             });
        }

        if (!isBossBattle && !isJunTimeTravel && !junMiniGameActive) { 
            let distMultiplier = (activeEffects.turbo > 0) ? 4 : 1;
            distance += safeDelta * 1 * distMultiplier;
            document.getElementById("distanceText").innerText = Math.floor(distance) + "m";
            let progress = Math.min(distance / 10000, 1); 
            let speedMultiplier = 1 + (progress * 14);
            let currentSpeed = BASE_SPEED * speedMultiplier;
            if (activeEffects.slow > 0) currentSpeed *= 0.5;
            if (activeEffects.turbo > 0) currentSpeed *= 2.0; 
            gameSpeed = currentSpeed;
        } else if (isJunTimeTravel) {
            gameSpeed = BASE_SPEED * 10;
        } else { gameSpeed = BASE_SPEED * 0.5; }

        if (!isBossBattle && distance >= nextBossTrigger) { startBossBattle(); }
        if (!isBossBattle && distance >= nextQuizDistance) { nextQuizDistance += 35; pauseForQuiz(); return; }

        if (isBossBattle) { updateBoss(safeDelta); }
        else if (!isJunTimeTravel && !junMiniGameActive) { 
            obstacleTimer += safeDelta;
            if (obstacleTimer >= nextObstacleTime && (nextQuizDistance - distance > 2)) {
                spawnObstacle(); obstacleTimer = 0; 
                let sm = gameSpeed / BASE_SPEED;
                nextObstacleTime = randBetween(1.8, 2.6) / (1 + (sm - 1) * 0.6); 
                if (nextObstacleTime < 0.2) nextObstacleTime = 0.2;
            }
            enemySpawnTimer += safeDelta;
            if(enemySpawnTimer > 2.5 && !isBossBattle) { spawnEnemyLogic(); enemySpawnTimer = 0; }
        }

        updateEnemies(safeDelta); 
        updatePhysics(safeDelta);
        updateFaithCoinsLogic(safeDelta);
        
        itemTimer += safeDelta;
        if (itemTimer >= nextItemTime && !isJunTimeTravel) { spawnItem(); itemTimer = 0; nextItemTime = 15 + Math.random() * 5; }

        for (let i = items.length - 1; i >= 0; i--) {
            let it = items[i];
            if (activeEffects.magnet > 0) {
                const px = playerObj.x + 30; const py = gameArea.offsetHeight - playerObj.y - 30;
                const ix = it.x + 24; const iy = it.y + 24;
                const dx = px - ix; const dy = py - iy; const dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < 400) {
                    it.x += (dx/dist)*12;
                    it.y += (dy/dist)*12;
                    it.style.left = it.x + "px";
                    it.style.top = it.y + "px";
                }
            }
            it.x -= gameSpeed * safeDelta;
            it.style.left = it.x + "px";
            if (it.x < -60) { it.remove(); items.splice(i, 1); continue; }
            
            const iRect = {x: it.x, y: it.y, w: 48, h: 48};
            const pRect = {x: playerObj.x, y: gameArea.offsetHeight - playerObj.y - playerObj.h, w: playerObj.w, h: playerObj.h};

            if (isColliding(pRect, iRect)) {
                activateItem(it.dataset.type); it.remove(); items.splice(i, 1);
                spawnParticles(it.x, it.y, 'item'); playSound('item');
                if(!isFeverTime) feverGauge = Math.min(feverGauge + 10, MAX_FEVER);
                saveProgress();
            }
        }
        
        let speedMult = (gameSpeed / BASE_SPEED); 
        bg1X -= BG1_SPEED * speedMult * safeDelta;
        bg2X -= BG2_SPEED * speedMult * safeDelta;
        bg3X -= BG3_SPEED * speedMult * safeDelta;
        bg1.style.backgroundPosition = `${bg1X}px 0`;
        bg2.style.backgroundPosition = `${bg2X}px bottom`;
        bg3.style.backgroundPosition = `${bg3X}px bottom`;
    } catch(e) { console.error(e); }
    requestAnimationFrame(gameLoop);
  }

   function updateFaithCoinsLogic(dt) {
      for(let i = faithCoins.length - 1; i >= 0; i--) {
          const coin = faithCoins[i]; coin.timer += dt;
          
          if (coin.timer < 0.3) { 
              coin.x += coin.vx * dt * 2; 
              coin.y += coin.vy * dt * 2; 
          } 
          else {
              const targetX = playerObj.x + 30; const targetY = gameArea.offsetHeight - playerObj.y - 30;
              const dx = targetX - coin.x; const dy = targetY - coin.y;

              if (coin.isAutoCollect || !coin.isManual) {
                  if(coin.isAutoCollect) {
                        coin.x += dx * 8 * dt; 
                        coin.y += dy * 8 * dt;
                  } else {
                        coin.x -= gameSpeed * dt;
                  }
              } else {
                    coin.x -= gameSpeed * dt;
              }
              
              if (Math.abs(dx) < 40 && Math.abs(dy) < 40) { 
                  let gain = 1;
                  if(collectionBuff && Math.random() < 0.1) gain = 2;

                  faith += gain; 
                  document.getElementById("faithText").innerText = faith;
                  playSound('item'); 
                  
                  showFloatText("+1 Ïã†ÏïôÏã¨");
                  
                  coinCombo++;
                  coinComboTimer = 0;
                  if(coinCombo >= 5) {
                      showFloatText("ÎåÄÎ∞ï!");
                      coinCombo = 0; 
                  }

                  coin.remove(); faithCoins.splice(i, 1); continue;
              }
          }
          
          if(coin.x < -50) {
              coin.remove(); faithCoins.splice(i, 1); continue;
          }

          coin.style.left = coin.x + "px"; coin.style.top = coin.y + "px";
      }
  }

  function spawnEnemyLogic() {
      if(isBossBattle) return; 

      let availableTypes = [];
      // 1~5: Í∏∞Î≥∏ Ï†Å
      if (distance >= 200) availableTypes.push(1);
      if (distance >= 300) availableTypes.push(2);
      if (distance >= 400) availableTypes.push(3);
      if (distance >= 450) availableTypes.push(4);
      if (distance >= 500) availableTypes.push(5);

      // 11~15: B_Enemy (Ï§ëÌòï Ï†Å)
      if (distance >= 600) availableTypes.push(11); 
      if (distance >= 800) availableTypes.push(12); 
      if (distance >= 1000) availableTypes.push(13); 
      if (distance >= 1200) availableTypes.push(14); 
      if (distance >= 1500) availableTypes.push(15); 

      if (availableTypes.length > 0 && Math.random() < 0.6) {
          const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
          spawnEnemy(type);
      }
  }

  function spawnEnemy(type) {
    const e = document.createElement("div"); e.classList.add("enemy");

    // Ïù¥ÎØ∏ÏßÄ Î∞è ÌÅ¨Í∏∞ ÏÑ§Ï†ï
    if (type >= 11 && type <= 15) {
        e.style.backgroundImage = `url('B_Enemy0${type - 10}.png')`;
        e.style.width = "90px"; e.style.height = "90px";
        e.hp = 15 + (type - 11) * 3; 
    } else {
        e.style.backgroundImage = `url('enemy${type}.png')`; 
        e.style.width = "60px"; e.style.height = "60px";
        e.hp = 1;
    }

    e.style.backgroundColor = 'transparent'; 
    e.type = type; 
    e.timer = 0; 
    
    // [Ï§ëÏöî] ÏÉÅÌÉú Í¥ÄÎ¶¨Ïö© Î≥ÄÏàò Ï∂îÍ∞Ä
    e.state = 'enter'; // Ï¥àÍ∏∞ ÏÉÅÌÉú: Îì±Ïû•
    
    // ÏãúÏûë ÏúÑÏπò (ÌôîÎ©¥ Î∞îÍπ• Ïò§Î•∏Ï™Ω)
    e.x = gameArea.offsetWidth + 50; 
    
    // [Ï§ëÏöî] Î®∏Î¨ºÎü¨Ïïº Ìï† Î™©Ìëú X Ï¢åÌëú (ÌôîÎ©¥ Ïò§Î•∏Ï™Ω 100~250px ÏïàÏ™Ω ÎûúÎç§)
    e.targetX = gameArea.offsetWidth - randBetween(100, 250);

    // Y Ï¢åÌëú ÏÑ§Ï†ï
    if (type === 13) e.y = 60; 
    else e.y = randBetween(50, gameArea.offsetHeight - 150);
    
    // [Ï§ëÏöî] Í∏∞Ï§Ä Y Ï¢åÌëú (ÏúÑÏïÑÎûò ÏõÄÏßÅÏûÑÏùò Ï§ëÏã¨Ï†ê)
    e.baseY = e.y;
    e.oscillationSpeed = randBetween(300, 600); // ÏúÑÏïÑÎûò ÏõÄÏßÅÏûÑ ÏÜçÎèÑ ÎûúÎç§
    e.oscillationRange = randBetween(50, 100);  // ÏúÑÏïÑÎûò ÏõÄÏßÅÏûÑ Ìè≠ ÎûúÎç§

    e.style.left = e.x + "px"; e.style.top = e.y + "px";
    gameArea.appendChild(e); enemies.push(e);
  }

  function updateEnemies(dt) {
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i]; e.timer += dt;

        // Î†àÏù¥Ï†Ä/Ïä§ÎÇòÏù¥Ìçº Îì± UI ÏúÑÏπò ÎèôÍ∏∞Ìôî
        if(e.laserWarning) { e.laserWarning.style.width = e.x + "px"; e.laserWarning.style.top = (e.y + 45) + "px"; }
        if(e.laserBeam) { e.laserBeam.style.width = e.x + "px"; e.laserBeam.style.top = (e.y + 15) + "px"; }
        if(e.sniperLine) { 
            e.sniperLine.style.width = (e.x - playerObj.x) + "px";
            e.sniperLine.style.left = playerObj.x + "px";
            e.sniperLine.style.top = (e.y + 45) + "px";
        }

        // Ïä§ÌÇ¨ Ï≤òÏπò Î°úÏßÅ
        if (activeEffects.noelLaser > 0 && e.x < gameArea.offsetWidth) {
            destroyEnemy(e, i); continue;
        }
        if (isFeverTime) {
           if (!e.feverTimer) e.feverTimer = 0;
           if (e.x < gameArea.offsetWidth) e.feverTimer += dt;
           if (e.feverTimer > 1.0) { destroyEnemy(e, i); continue; }
        }

        // ====================================================
        // [ÏàòÏ†ïÎêú Ï†Å AI ÎèôÏûë Î°úÏßÅ]
        // ====================================================

        // 1. Îì±Ïû• (Enter): ÌôîÎ©¥ Î∞ñÏóêÏÑú Î™©Ìëú ÏßÄÏ†ê(targetX)ÍπåÏßÄ Ïù¥Îèô
        if(e.state === 'enter') {
            e.x -= 200 * dt; // Îì±Ïû• ÏÜçÎèÑ
            // Î™©Ìëú ÏßÄÏ†êÏóê ÎèÑÎã¨ÌïòÎ©¥ 'idle' ÏÉÅÌÉúÎ°ú Ï†ÑÌôò
            if (e.x <= e.targetX) {
                e.x = e.targetX;
                e.state = 'idle';
                e.timer = 0;
            }
        }
        
        // 2. Ï†ÑÌà¨ ÎåÄÍ∏∞ (Idle): ÏúÑÏïÑÎûòÎ°ú ÏõÄÏßÅÏù¥Î©∞ Í≥µÍ≤©
        else if (e.state === 'idle') {
            // [ÏÑ∏Î°ú Ïù¥Îèô] Í∏∞Ï§ÄÏ†ê(baseY)ÏùÑ Ï§ëÏã¨ÏúºÎ°ú ÏúÑÏïÑÎûò ÏÇ¨Ïù∏Ìåå Ïù¥Îèô
            // Type 13(Ìè≠Í≤©Í∏∞)ÎÇò Type 11(Ï∂îÏ†ÅÏûê)ÏùÄ Í≥†Ïú† Ìå®ÌÑ¥ Ïú†ÏßÄ, ÎÇòÎ®∏ÏßÄÎäî ÏúÑÏïÑÎûò Î¨¥Îπô
            if (e.type !== 11 && e.type !== 13) {
                e.y = e.baseY + Math.sin(Date.now() / e.oscillationSpeed) * e.oscillationRange;
                
                // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÏßÄ ÏïäÍ≤å Î≥¥Ï†ï
                if(e.y < 20) e.y = 20;
                if(e.y > gameArea.offsetHeight - 80) e.y = gameArea.offsetHeight - 80;
            }

            // [Í≥µÍ≤© Ìå®ÌÑ¥]
            // Type 1: Î™∏ÌÜµÎ∞ïÏπòÍ∏∞ (ÏùºÏ†ï ÏãúÍ∞ÑÎßàÎã§ ÎèåÏßÑ)
            if (e.type === 1) {
                if (e.timer > 3.0) { // 3Ï¥àÎßàÎã§ ÎèåÏßÑ ÏãúÎèÑ
                    e.state = 'dash_warn'; // Í≤ΩÍ≥† ÏÉÅÌÉúÎ°ú Ï†ÑÌôò
                    e.timer = 0;
                }
            }
            // Type 2~5: ÏõêÍ±∞Î¶¨ Í≥µÍ≤© (Ï†úÏûêÎ¶¨ÏóêÏÑú Ïè®)
            else if (e.type <= 10) {
                 if (e.type === 2 && e.timer > 2.0) { spawnEnemyProjectile(e.x, e.y + 30, 'single', e); e.timer = 0; }
                 else if (e.type === 3 && e.timer > 2.0) { spawnEnemyProjectile(e.x, e.y + 30, 'fan', e); e.timer = 0; }
                 else if (e.type === 4 && e.timer > 2.0) { spawnEnemyProjectile(e.x, e.y + 30, 'explode', e); e.timer = 0; }
                 else if (e.type === 5 && e.timer > 3.0 && !e.isFiring) { fireEnemyLaser(e); e.timer = 0; }
            }
            // Elite Mobs (Type 11~) Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ
            else {
                handleEliteLogic(e, dt);
            }
        }

        // 3. [Type 1 Ï†ÑÏö©] ÎèåÏßÑ Í≤ΩÍ≥† (Îí§Î°ú ÏÇ¥Ïßù Î∫å)
        else if (e.state === 'dash_warn') {
            e.x += 100 * dt; // Îí§Î°ú ÏõÄÏ∞î
            if (e.timer > 0.5) {
                e.state = 'dashing';
                e.timer = 0;
                playSound('jump'); // ÎèåÏßÑ Ìö®Í≥ºÏùå(Ï†êÌîÑÏùå Ïû¨ÌôúÏö©)
            }
        }

        // 4. [Type 1 Ï†ÑÏö©] ÎèåÏßÑ (ÏôºÏ™ΩÏúºÎ°ú Îπ†Î•¥Í≤å)
        else if (e.state === 'dashing') {
            e.x -= 800 * dt; // Îß§Ïö∞ Îπ†Î•¥Í≤å ÎèåÏßÑ
            
            // ÌôîÎ©¥ ÏôºÏ™Ω ÎÅù Í∑ºÏ≤ò(50px)ÍπåÏßÄ Ïò§Í±∞ÎÇò 1.5Ï¥à ÏßÄÎÇòÎ©¥ Î≥µÍ∑Ä
            if (e.x < 50 || e.timer > 1.5) {
                e.state = 'return';
                e.timer = 0;
            }
        }

        // 5. [Type 1 Ï†ÑÏö©] Î≥µÍ∑Ä (ÏõêÎûò ÏûêÎ¶¨Î°ú ÎèåÏïÑÍ∞ê)
        else if (e.state === 'return') {
            const dx = e.targetX - e.x;
            const dy = e.baseY - e.y;
            
            e.x += dx * 0.05; // Î∂ÄÎìúÎü¨Ïö¥ Í∞êÏÜç Ïù¥Îèô (Lerp)
            e.y += dy * 0.05;

            // Í±∞Ïùò ÎèÑÏ∞©ÌñàÏúºÎ©¥ Îã§Ïãú idle
            if (Math.abs(dx) < 10) {
                e.state = 'idle';
                e.timer = 0;
            }
        }

        // Ï¢åÌëú Ï†ÅÏö©
        e.style.left = e.x + "px"; e.style.top = e.y + "px";
        
        // Î≤ÑÍ∑∏ Î∞©ÏßÄ: ÌòπÏãúÎùºÎèÑ ÎÑàÎ¨¥ Î©ÄÎ¶¨ Î≤óÏñ¥ÎÇòÎ©¥ ÏÇ≠Ï†ú
        if (e.x < -300) { 
            e.isDead = true; 
            if(e.laserWarning) e.laserWarning.remove();
            if(e.laserBeam) e.laserBeam.remove();
            e.remove(); enemies.splice(i, 1); 
        }
    }
  }

  // Ï§ëÌòï Ï†Å(Elite) Ìå®ÌÑ¥ Ï≤òÎ¶¨Ïö© Î≥¥Ï°∞ Ìï®Ïàò
  function handleEliteLogic(e, dt) {
        const pY = gameArea.offsetHeight - playerObj.y - 50; 

        // Type 11: Ï∂îÏ†ÅÏûê (YÏ∂ïÎßå ÌîåÎ†àÏù¥Ïñ¥ Îî∞ÎùºÎã§Îãò)
        if (e.type === 11) {
            e.y += (pY - e.y) * 2.0 * dt; 
            if(e.timer > 1.5) { spawnEnemyProjectile(e.x, e.y+45, 'single', e); e.timer = 0; }
        }
        // Type 12: Ïä§ÎÇòÏù¥Ìçº
        else if (e.type === 12) {
             e.y = e.baseY + Math.sin(Date.now() / 300) * 30; // Ï†úÏûêÎ¶¨ Î¨¥Îπô
             if (!e.subState) e.subState = 'move';
             if (e.subState === 'move') {
                 if(e.timer > 2.0) { e.subState = 'lock'; e.timer = 0; }
             } else if (e.subState === 'lock') {
                 if(!e.sniperLine) {
                     const line = document.createElement('div'); line.className = 'sniper-line';
                     gameArea.appendChild(line); e.sniperLine = line;
                 }
                 if(e.timer > 0.8) {
                     const p = createProj(e.x, e.y+45, -900, 0, e); p.style.backgroundColor = "purple";
                     if(e.sniperLine){ e.sniperLine.remove(); e.sniperLine = null; }
                     e.subState = 'move'; e.timer = 0;
                 }
             }
        }
        // Type 13: Ìè≠Í≤©Í∏∞ (ÏÉÅÎã®ÏóêÏÑú Ï¢åÏö∞ Ïù¥Îèô)
        else if (e.type === 13) {
             e.x = e.targetX + Math.sin(Date.now()/500) * 50; 
             if (e.timer > 2.0) {
                 const p = createProj(e.x + 30, e.y+80, -100, 400, e); p.isBomb = true;
                 e.timer = 0;
             }
        }
        // Type 14: Í∏∞Í¥ÄÌè¨
        else if (e.type === 14) {
             e.y = e.baseY + Math.sin(Date.now()/150) * 5; 
             if(e.timer > 2.0) {
                 spawnEnemyProjectile(e.x, e.y+45, 'fan', e);
                 setTimeout(()=>spawnEnemyProjectile(e.x, e.y+45, 'fan', e), 200);
                 setTimeout(()=>spawnEnemyProjectile(e.x, e.y+45, 'fan', e), 400);
                 e.timer = 0;
             }
        }
        // Type 15: Ïª§Îß®Îçî
        else if (e.type === 15) {
             e.y = e.baseY + Math.cos(Date.now()/1000) * 20; 
             if(e.timer > 3.0) {
                 spawnEnemyProjectile(e.x, e.y+45, 'explode', e);
                 e.timer = 0;
             }
        }
  }

  function destroyEnemy(e, index) {
      spawnExplosionEffect(e.x + (e.type>10?45:30), e.y + (e.type>10?45:30));
      let count = (e.type > 10) ? 8 : (4 + e.type); 
      spawnFaithCoins(e.x, e.y, count, true, false); 
      showFloatText("üí• Ï†ÅÍµ∞ ÏÑ¨Î©∏!");
      e.isDead = true;
      if(e.laserWarning) e.laserWarning.remove();
      if(e.laserBeam) e.laserBeam.remove();
      if(e.sniperLine) e.sniperLine.remove();
      e.remove(); 
      if(index !== undefined) enemies.splice(index, 1);
  }

  function spawnEnemyProjectile(x, y, pattern, ownerEnemy) {
      if(pattern === 'single') createProj(x, y, -200, 0, ownerEnemy); 
      else if (pattern === 'fan') { createProj(x, y, -300, 0, ownerEnemy); createProj(x, y, -280, 100, ownerEnemy); createProj(x, y, -280, -100, ownerEnemy); }
      else if (pattern === 'explode') { let p = createProj(x, y, -250, 0, ownerEnemy); p.isExplosive = true; }
  }

  function createProj(x, y, vx, vy, owner) {
      const p = document.createElement("div"); p.classList.add("projectile", "enemy-missile");
      p.style.left = x + "px"; p.style.top = y + "px"; p.x = x; p.y = y; p.vx = vx; p.vy = vy;
      if(owner) p.owner = owner; 
      gameArea.appendChild(p); projectiles.push(p); return p;
  }

  function fireEnemyLaser(e) {
      e.isFiring = true; 
      const warning = document.createElement("div"); warning.className = "enemy-laser-warning";
      warning.style.left = "0px"; warning.style.width = e.x + "px"; warning.style.top = (e.y + 30) + "px";
      gameArea.appendChild(warning);
      e.laserWarning = warning; 

      setTimeout(() => {
          if(e.isDead) { warning.remove(); return; } 
          warning.remove(); e.laserWarning = null;
          const laser = document.createElement("div"); laser.className = "enemy-laser-beam";
          laser.style.left = "0px"; laser.style.width = e.x + "px"; laser.style.top = (e.y + 15) + "px";
          gameArea.appendChild(laser);
          e.laserBeam = laser; 
          
          let duration = 0;
          let check = setInterval(() => {
              if(e.isDead) { clearInterval(check); laser.remove(); return; }

              duration += 0.1; let laserY = parseFloat(laser.style.top);
              if(Math.abs((gameArea.offsetHeight - playerObj.y) - laserY) < 30 && !invincible) damageLife();
              if(duration > 5.0) { 
                  clearInterval(check); 
                  laser.remove(); 
                  e.laserBeam = null; 
                  
                  setTimeout(() => {
                      e.isFiring = false; 
                      e.timer = 0;
                  }, 2000); 
              }
          }, 100);
      }, 1000); 
  }

  function spawnItem() {
    const types = ['invincible', 'turbo', 'slow', 'faith'];
    const images = { 'invincible': 'url("item_cross.png")', 'turbo': 'url("item_wings.png")', 'slow': 'url("item_wind.png")', 'faith': 'url("item_bible.png")' };
    const item = document.createElement("div"); const type = types[Math.floor(Math.random() * types.length)];
    item.classList.add("item"); item.dataset.type = type; item.style.backgroundImage = images[type]; 

    item.x = gameArea.offsetWidth + 50; 

    item.y = randBetween(100, gameArea.offsetHeight - 150);
    item.style.left = item.x + "px"; item.style.top = item.y + "px";
    document.getElementById("gameArea").appendChild(item); items.push(item);
}

  function activateItem(type) {
    if(type === 'invincible') { activeEffects.invincible = 10; showFloatText("üõ°Ô∏è Î¨¥Ï†Å!"); }
    else if(type === 'turbo') { activeEffects.turbo = 5; showFloatText("üöÄ ÌÑ∞Î≥¥!"); }
    else if(type === 'slow') { activeEffects.slow = 10; showFloatText("üçÉ Í∞êÏÜç"); }
    else if(type === 'faith') { 
        let gain = 10;
        if(collectionBuff) gain = 11;
        faith += gain;
        showFloatText(`üìò Faith +${gain}`); 
    }
    document.getElementById("faithText").innerText = faith;
  }

  function startBossBattle() {
    isBossBattle = true; bossLevel++; 
    
    boss.y = 50;
    boss.vy = 0.5;
    bossContainer.style.top = "50%";
    
    if(bossLevel <= 4) {
        boss.maxHp = 5;
        bossBody.style.backgroundImage = "url('boss.png')";
    } else if(bossLevel <= 9) {
        boss.maxHp = 7;
        bossBody.style.backgroundImage = "url('Devil2.png')";
    } else if(bossLevel <= 15) {
        boss.maxHp = 9;
        bossBody.style.backgroundImage = "url('Devil3.png')";
    } else if(bossLevel <= 20) {
        boss.maxHp = 10;
        bossBody.style.backgroundImage = "url('Devil4.png')";
    } else if(bossLevel <= 30) {
        boss.maxHp = 15;
        bossBody.style.backgroundImage = "url('Devil5.png')";
    } else {
        boss.maxHp = 20 + (bossLevel - 30);
        bossBody.style.backgroundImage = "url('Devil6.png')";
    }
    
    boss.hp = boss.maxHp;
    invincible = false;
    if(isFeverTime) endFeverTime();
    
    player.style.left = "50px"; 

    showFloatText(`‚ö†Ô∏è BOSS LV.${bossLevel} WARNING!`);
    const warning = document.getElementById('bossWarning'); 
    warning.innerText = `‚ö†Ô∏è BOSS LV.${bossLevel}!!`;
    warning.style.display = 'block'; 
    setTimeout(() => warning.style.display = 'none', 3000);
    
    obstacles.forEach(o => o.remove()); obstacles = []; 
    enemies.forEach(e => e.remove()); enemies = []; 
    
    bossContainer.style.display = 'block'; 
    bossBody.classList.remove('boss-rage'); 
    
    setTimeout(() => { bossContainer.style.right = '20px'; }, 100);
    saveProgress();
  }

  function updateBoss(delta) {
    if (boss.hp <= 0) return;
    boss.actionTimer += delta;
    boss.shootTimer += delta;

    if (boss.state === 'idle') { 
        boss.y += boss.vy; 
        if (boss.y > 80 || boss.y < 20) boss.vy *= -1; 
        bossContainer.style.top = boss.y + "%"; 
    }

    if (bossLevel >= 10 && boss.state === 'idle') {
        let rageInterval = 20; 

        if (bossLevel <= 15) { 
            rageInterval = 20 - (bossLevel - 10) * 1.5; 
        } else if (bossLevel <= 20) { 
            rageInterval = 12 - (bossLevel - 15) * 1.0; 
        } else { 
            rageInterval = 7;
        }
        if (rageInterval < 5) rageInterval = 5; 

        if (boss.actionTimer > rageInterval) {
            startBossRage();
            boss.actionTimer = 0;
        }
    }

    let shootInterval = 2.0;
    if (bossLevel >= 4) shootInterval = 1.5;
    if (bossLevel >= 10) shootInterval = 1.2;
    if (bossLevel >= 15) shootInterval = 0.8;
    if (bossLevel >= 21) shootInterval = 0.6;

    if (boss.state === 'idle' && boss.shootTimer > shootInterval) { 
        determineBossAttack();
        boss.shootTimer = 0; 
    }
  }

  function determineBossAttack() {
      let pattern = 'single';
      
      if (bossLevel >= 31) {
          const r = Math.random();
          if (r < 0.25) pattern = 'single';
          else if (r < 0.5) pattern = 'fan';
          else if (r < 0.75) pattern = '360';
          else pattern = 'blackhole';
      } 
      else if (bossLevel >= 21) pattern = 'blackhole'; // Devil5
      else if (bossLevel >= 15) pattern = '360'; // Devil4
      else if (bossLevel >= 4) pattern = 'fan'; // Devil2, Devil3
      else pattern = 'single'; // Devil1 (Lv1~3)

      if (pattern === 'single') bossShootSingle();
      else if (pattern === 'fan') bossShootFan();
      else if (pattern === '360') bossShoot360();
      else if (pattern === 'blackhole') bossShootBlackHole();
  }

  function bossShootSingle() {
      createBossMissile(1.0 + (bossLevel * 0.1));
  }

  function bossShootFan() {
      let count = 4 + (bossLevel - 4);
      if (count > 12) count = 12;
      
      const startAngle = -45; 
      const endAngle = 45;    
      const step = (endAngle - startAngle) / (count - 1);

      for(let i=0; i<count; i++) {
          const angleDeg = startAngle + (step * i);
          createBossMissile(1.2, angleDeg);
      }
  }

  function bossShoot360() {
      const count = 12 + (bossLevel - 15); 
      for(let i=0; i<count; i++) {
          const angle = (360 / count) * i;
          createBossMissile(0.8, angle, true); 
      }
  }

  function bossShootBlackHole() {
      const m = document.createElement("div"); 
      m.classList.add("projectile", "black-hole-missile");
      
      m.x = gameArea.offsetWidth - 80; 
      m.y = (boss.y / 100 * gameArea.offsetHeight) + 40;

      m.style.left = m.x + "px"; 
      m.style.top = m.y + "px";
      
      const pX = playerObj.x + 20; 
      const pY = gameArea.offsetHeight - playerObj.y - 20;
      const dx = pX - m.x; 
      const dy = pY - m.y;
      const dist = Math.hypot(dx, dy);
      
      const speed = 600 + (bossLevel - 20) * 20;
      m.vx = (dx / dist) * speed;
      m.vy = (dy / dist) * speed;
      
      m.isBlackHole = true;
      m.state = 'travel'; 
      m.timer = 0;

      gameArea.appendChild(m); 
      projectiles.push(m);
  }

  function createBossMissile(speedMult, angleOffset = 0, isAbsAngle = false) {
      const m = document.createElement("div"); 
      m.classList.add("projectile", "boss-missile");
      
      const startX = gameArea.offsetWidth - 80; 
      const startY = (boss.y / 100 * gameArea.offsetHeight) + 40;
      
      m.x = startX; m.y = startY; 
      m.style.left = startX + "px"; m.style.top = startY + "px";

      let vx, vy;
      const speed = 350 * speedMult;

      if (isAbsAngle) {
          const rad = angleOffset * (Math.PI / 180);
          vx = Math.cos(rad) * speed;
          vy = Math.sin(rad) * speed;
      } else {
          const pX = playerObj.x + 20; 
          const pY = gameArea.offsetHeight - playerObj.y - 20;
          const dx = pX - startX; 
          const dy = pY - startY; 
          const baseAngle = Math.atan2(dy, dx);
          const finalAngle = baseAngle + (angleOffset * (Math.PI / 180));
          
          vx = Math.cos(finalAngle) * speed;
          vy = Math.sin(finalAngle) * speed;
      }

      m.vx = vx; m.vy = vy; 
      m.isBossMissile = true; 
      gameArea.appendChild(m); 
      projectiles.push(m);
  }

  function startBossRage() {
    boss.state = 'rage'; 
    bossBody.classList.add('boss-rage'); 
    bossBody.classList.add('boss-charging');
    showFloatText("üëø Ìè≠Ï£º Î™®Îìú ÎèåÏßÑ!");
    
    setTimeout(() => {
        bossBody.classList.remove('boss-charging'); 
        bossBody.classList.add('boss-dashing');
        
        bossContainer.style.transition = "right 0.3s ease-in"; 
        bossContainer.style.right = (gameArea.offsetWidth - 50) + "px"; 
        
        setTimeout(() => { 
            const bossYPx = (100 - boss.y) / 100 * gameArea.offsetHeight;
            if(playerObj.y > bossYPx - 100 && playerObj.y < bossYPx + 100) {
                if(!invincible && activeEffects.invincible <= 0) damageLife(); 
            }
        }, 150);

        setTimeout(() => { 
            bossContainer.style.transition = "right 0.8s ease-out"; 
            bossContainer.style.right = "20px"; 
            bossBody.classList.remove('boss-dashing'); 
            bossBody.classList.remove('boss-rage');
            boss.state = 'idle'; 
        }, 600);
    }, 1000);
  }

  function damageBoss() {
    boss.hp--; 
    bossHpFill.style.width = (boss.hp / boss.maxHp * 100) + "%"; 
    showFloatText("üí• Î≥¥Ïä§ ÌÉÄÍ≤©!");
    
    if (boss.hp <= 0) {
        bossContainer.style.transition = "top 1s ease-in"; 
        bossContainer.style.top = "120%"; 
        spawnParticles(gameArea.offsetWidth-100, gameArea.offsetHeight-100, 'dust');
        
        setTimeout(() => { 
            bossContainer.style.display = 'none'; 
            isBossBattle = false; 
            invincible = false; 
            activeEffects.invincible = 0; 
            
            const reward = 100 + (bossLevel * 20);
            faith += reward;
            
            showFloatText(`üéâ Î≥¥Ïä§ Ï≤òÏπò! (+${reward} Faith)`); 
            playSound('clear');
            
            nextBossTrigger = distance + 500; 
            saveProgress(); 
        }, 1000);
    }
  }

  function updatePhysics(delta) {
    if(isJunTimeTravel || junMiniGameActive) return; 

    if (activeEffects.fly > 0) { 
        playerObj.y += (targetY - playerObj.y) * 0.1; 
        velocity = 0; 
        if(speedLines) speedLines.style.display = "none"; 
    } 
    else if (activeEffects.turbo > 0) { 
        velocity = 0; 
        if(speedLines) speedLines.style.display = "block"; 
    } 
    else { 
        velocity += gravity; 
        playerObj.y += velocity; 
        if(speedLines) speedLines.style.display = "none"; 
    }

    if (playerObj.y < 0) playerObj.y = 0;
    if (playerObj.y > gameArea.offsetHeight - 110) playerObj.y = gameArea.offsetHeight - 110;
    player.style.bottom = playerObj.y + "px";

    const safeActive = (val) => (val && val > 0);

    for (let i = playerMissiles.length - 1; i >= 0; i--) {
    let m = playerMissiles[i];
    let mx = parseFloat(m.style.left);
    mx += 600 * delta; 
    m.style.left = mx + "px";
        if (mx > gameArea.offsetWidth) { m.remove(); playerMissiles.splice(i, 1); continue; }
        
        const mRect = {x: mx, y: parseFloat(m.style.top), w: 50, h: 24};
        
        let hitObs = false;
        for (let k = obstacles.length - 1; k >= 0; k--) {
             let o = obstacles[k];
             let oY;
             if (o.classList.contains('obs-ceil')) {
                 oY = parseFloat(o.style.top) || 0;
             } else {
                 oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
             }
             
             const oRect = {x: o.x, y: oY, w: 60, h: parseFloat(o.style.height)};
             
             if(!o.destroyed && isColliding(mRect, oRect)) {
                 o.hp = (o.hp || 11) - playerDamage;
                 if (o.hp <= 0) {
                     o.destroyed = true; 
                     spawnExplosionEffect(o.x, oY);
                     o.remove(); obstacles.splice(k, 1);
                 } else {
                     spawnParticles(o.x, oY, 'spark');
                 }
                 
                 m.remove(); playerMissiles.splice(i, 1);
                 hitObs = true;
                 break;
             }
        }
        if(hitObs) continue;

        for (let j = enemies.length - 1; j >= 0; j--) {
            let e = enemies[j];
            const eRect = {x: e.x, y: e.y, w: (e.type>10?90:60), h: (e.type>10?90:60)};
            
            if (isColliding(mRect, eRect)) {
                e.hp -= playerDamage;
                m.remove(); playerMissiles.splice(i, 1);
                const ex = document.createElement('div'); ex.className = 'explosion-area';
                ex.style.left = eRect.x + 'px'; ex.style.top = eRect.y + 'px'; ex.style.width='60px'; ex.style.height='60px';
                gameArea.appendChild(ex); setTimeout(()=>ex.remove(), 500);

                if (e.hp <= 0) destroyEnemy(e, j);
                break; 
            }
        }
    }

    for (let i = projectiles.length - 1; i >= 0; i--) {
    let p = projectiles[i];
        
        if (p.owner && p.owner.isDead) {
            p.style.opacity = (parseFloat(p.style.opacity) || 1) - 0.05; 
            p.isFading = true; 
            if (p.style.opacity <= 0) { p.remove(); projectiles.splice(i, 1); continue; }
        }

        if (p.isBlackHole && !p.isFading) {
            if (p.state === 'travel') {
                p.x += p.vx * delta; p.y += p.vy * delta;
                p.style.left = p.x + "px"; p.style.top = p.y + "px";
                
                if (p.x < playerObj.x + 100) {
                    p.state = 'absorbing';
                    p.classList.add('black-hole-active');
                    p.explodeTimer = 2.0; 
                }
            } else if (p.state === 'absorbing') {
                p.explodeTimer -= delta;
                if (p.explodeTimer <= 0) {
                    spawnExplosionEffect(p.x, p.y);
                    showFloatText("üåå Î∏îÎûôÌôÄ Ìè≠Î∞ú!");
                    if(!invincible && activeEffects.invincible <= 0) damageLife();
                    p.remove(); projectiles.splice(i, 1);
                    continue;
                }
            }
        } else {
            p.x += p.vx * delta; 
            if (p.isBomb) {
                p.vy += 800 * delta; // Ï§ëÎ†• Í∞ÄÏÜçÎèÑ
            }
            p.y += p.vy * delta;
            p.style.left = p.x + "px"; p.style.top = p.y + "px";
        }

        if (p.x < -100 || p.x > gameArea.offsetWidth + 100 || p.y < -100 || p.y > gameArea.offsetHeight + 100) { 
            p.remove(); projectiles.splice(i, 1); continue; 
        }
        
        if (p.isExplosive && !p.exploded && p.x <= 120) { 
             p.exploded = true;
             const boom = document.createElement("div"); boom.className = "explosion-area";
             boom.style.width = "260px"; boom.style.height = "260px"; 
             boom.style.left = (p.x - 100) + "px"; boom.style.top = (p.y - 100) + "px";
             gameArea.appendChild(boom); setTimeout(() => boom.remove(), 500);
             
             const pRect = {x: playerObj.x, y: gameArea.offsetHeight - playerObj.y - playerObj.h, w: playerObj.w, h: playerObj.h};
             const bRect = {x: p.x - 100, y: p.y - 100, w: 260, h: 260};

             if (isColliding(pRect, bRect)) {
                 if(!invincible && !safeActive(activeEffects.invincible)) damageLife();
             }
             p.remove(); projectiles.splice(i, 1); continue;
        }

        if (!p.isReflected && !p.isFading && !p.isBlackHole) {
            const pRect = {x: playerObj.x, y: gameArea.offsetHeight - playerObj.y - playerObj.h, w: playerObj.w, h: playerObj.h};
            const mRect = {x: p.x, y: p.y, w: 30, h: 30};
            
            if (isColliding(pRect, mRect)) {
                if (isFeverTime) { 
                    p.remove(); projectiles.splice(i, 1); faith += 5; showFloatText("üí• ÎèåÌåå!"); continue; 
                } 
                else if (!invincible && !safeActive(activeEffects.invincible) && !safeActive(activeEffects.summon)) {
                      damageLife(); p.remove(); projectiles.splice(i, 1); continue; 
                }
            }
        }

        if (isBossBattle && p.isReflected) {
            const bRect = bossContainer.getBoundingClientRect(); 
            const pRect = p.getBoundingClientRect();
            if (pRect.right > bRect.left && pRect.left < bRect.right && pRect.bottom > bRect.top && pRect.top < bRect.bottom) { 
                damageBoss(); p.remove(); projectiles.splice(i, 1); continue; 
            }
        }
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        if (!safeActive(activeEffects.invincible) && !invincible) {
            const pRect = {x: playerObj.x, y: gameArea.offsetHeight - playerObj.y - playerObj.h, w: playerObj.w, h: playerObj.h};
            const eRect = {x: e.x, y: e.y, w: (e.type>10?90:60), h: (e.type>10?90:60)};
            
            if (isColliding(pRect, eRect)) {
                if(activeEffects.giant > 0) {
                    destroyEnemy(e, i); showFloatText("üí• Í±∞ÎåÄÌôî Í≤©Ìåå!"); continue;
                }
                if (isFeverTime) { 
                    destroyEnemy(e, i); showFloatText("üí• Ï†ÅÍµ∞ Î∂ÑÏáÑ! (+5)"); continue; 
                } 
                else { damageLife(); destroyEnemy(e, i); continue; }
            }
        }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let o = obstacles[i];
        
        let moveSpeed = gameSpeed;
        if (o.classList.contains('obs-trap')) moveSpeed *= 2.0;
        
        o.x -= moveSpeed * delta;
        o.style.left = o.x + "px";
        
        let rw = 60; if(o.classList.contains('obs-long')) rw = 240;
        
        let oY;
        if (o.classList.contains('obs-ceil')) {
             oY = parseFloat(o.style.top) || 0;
        } else {
             oY = gameArea.offsetHeight - parseFloat(o.style.bottom || 0) - parseFloat(o.style.height);
        }
        const oRect = {x: o.x, y: oY, w: rw, h: parseFloat(o.style.height)};
        
        if (activeEffects.noelLaser > 0 && !o.destroyed) {
            const beam = document.getElementById('noelBeam');
            if (beam) {
                const bRect = {x: 170, y: gameArea.offsetHeight - playerObj.y - 120, w: gameArea.offsetWidth, h: 100};
                if (isColliding(bRect, oRect)) {
                    o.destroyed = true;
                    spawnExplosionEffect(o.x + 30, oY);
                    spawnFaithCoins(o.x, gameArea.offsetHeight - 150, Math.floor(randBetween(10, 31)));
                    o.remove(); obstacles.splice(i, 1);
                    showFloatText("üí∞ ÎåÄÎ∞ï!");
                    continue;
                }
            }
        }
        
        if(activeEffects.giant > 0 && !o.destroyed) {
             const pRect = {x: playerObj.x, y: gameArea.offsetHeight - playerObj.y - playerObj.h, w: playerObj.w, h: playerObj.h};
             if (isColliding(pRect, oRect)) {
                 o.destroyed = true;
                 spawnExplosionEffect(o.x + 30, oY);
                 spawnFaithCoins(o.x, gameArea.offsetHeight - 150, Math.floor(randBetween(1, 6)), false, false);
                 o.remove(); obstacles.splice(i, 1);
                 showFloatText("ü¶∂ Î∞üÏïòÎã§!");
                 continue;
             }
        }

        if (isFeverTime && o.x < 180 && !o.destroyed) {
            o.destroyed = true; 
            spawnExplosionEffect(o.x + 30, oY);
            spawnFaithCoins(o.x, gameArea.offsetHeight - 150, Math.floor(randBetween(2, 6)));
            o.remove(); obstacles.splice(i, 1);
            showFloatText("üí∞ Í≤©Ìåå!");
            continue;
        }

        if (o.x + rw < 0) {
            o.remove(); obstacles.splice(i, 1); obstacleSurviveCount++;
            if(!isFeverTime) feverGauge = Math.min(feverGauge + 5, MAX_FEVER);
            if (obstacleSurviveCount >= 5) {
                combo++; faith++; document.getElementById("faithText").innerText = faith;
                const ce = document.getElementById("comboEffect"); ce.style.display = "block"; ce.innerText = `COMBO +${combo}!`; setTimeout(() => ce.style.display = "none", 1000);
                obstacleSurviveCount = 0; saveProgress();
            }
            continue;
        }
        
        if (currentSkin === 'jieun' && activeEffects.summon > 0 && !o.destroyed) {
            const sRect = {x: playerObj.x - 20, y: gameArea.offsetHeight - playerObj.y - playerObj.h - 20, w: playerObj.w + 40, h: playerObj.h + 40};
            if (isColliding(sRect, oRect)) {
                o.destroyed = true; spawnExplosionEffect(o.x + 30, oY); spawnFaithCoins(o.x, gameArea.offsetHeight - 150, 3, false, true);
                o.remove(); obstacles.splice(i, 1); showFloatText("üí• ÌååÍ¥¥!"); continue;
            }
        }
        if (currentSkin === 'haeun' && haeunShieldActive && !o.destroyed) {
            const sRect = {x: playerObj.x - 10, y: gameArea.offsetHeight - playerObj.y - playerObj.h - 10, w: playerObj.w + 20, h: playerObj.h + 20};
            if (isColliding(sRect, oRect)) {
                o.destroyed = true; haeunShieldActive = false; removeHaeunShield();
                spawnExplosionEffect(o.x + 30, oY); let coins = Math.floor(randBetween(5, 11));
                spawnFaithCoins(o.x, gameArea.offsetHeight - 150, coins, false, true);
                o.remove(); obstacles.splice(i, 1); showFloatText("üõ°Ô∏è Î∞©Ïñ¥ & ÌååÍ¥¥!"); playSound('clear'); continue;
            }
        }

        if (!isFeverTime && !safeActive(activeEffects.invincible) && !invincible && !safeActive(activeEffects.summon) && !safeActive(activeEffects.turbo) && !(currentSkin === 'haeun' && haeunShieldActive)) {
            const pRect = {x: playerObj.x, y: gameArea.offsetHeight - playerObj.y - playerObj.h, w: playerObj.w, h: playerObj.h};
            if (isColliding(pRect, oRect)) {
                damageLife(); break;
            }
        }
        if(currentSkin === 'stephanie' && o.x < 50 && !o.passed) { faith++; document.getElementById("faithText").innerText = faith; o.passed = true; }
    }
  }

  function spawnObstacle() { 
    if(!running) return;
    if(activeEffects.turbo > 0 && !isFeverTime) return;

    const randi = (min,max)=>Math.floor(Math.random()*(max-min))+min;
    const gameWidth = gameArea.offsetWidth; 

    const OBS_HP = 11;

    // [ÏàòÏ†ï 3] Ìä∏Îû© Í∏∞Îë•: ÎÜíÏù¥ Ï¶ùÍ∞Ä(ÌôîÎ©¥ Ï§ëÍ∞Ñ ÎÑòÍ≤å), ÏúÑ/ÏïÑÎûò ÎûúÎç§
    if (distance > 300 && Math.random() < 0.15) {
        const b = document.createElement("div"); 
        b.classList.add("obstacle", "obs-cap", "obs-trap");
        
        // ÎÜíÏù¥Î•º ÌôîÎ©¥Ïùò 60% ~ 85% Ï†ïÎèÑÎ°ú ÏÑ§Ï†ï
        const h = randi(gameArea.offsetHeight * 0.6, gameArea.offsetHeight * 0.85);
        b.style.height = h + "px"; 
        
        b.x = gameWidth + 80; 
        b.style.left = b.x + "px"; 
        b.hp = OBS_HP;

        // ÏúÑ ÎòêÎäî ÏïÑÎûò ÎûúÎç§ Îì±Ïû•
        if (Math.random() < 0.5) {
            b.classList.add("obs-ground");
            b.style.bottom = "0";
        } else {
            b.classList.add("obs-ceil");
            b.style.top = "0";
        }

        gameArea.appendChild(b);
        obstacles.push(b);
        return;
    }

    if (distance < 50) {
        const type = (Math.random() < 0.5) ? 'obs-log' : 'obs-rock';
        const sx = gameWidth + 80; 
        const b = document.createElement("div");
        b.classList.add("obstacle", "obs-cap", "obs-ground", type);
        b.style.height = randi(130, 360) + "px"; 
        b.x = sx; b.style.left = sx + "px"; b.style.bottom = "0";
        b.hp = OBS_HP;
        gameArea.appendChild(b);
        obstacles.push(b);
        return; 
    }

    if(distance > 50 && Math.random() < 0.65) {
        let cnt = (Math.random()<0.3)?2:1;
        for(let k=0; k<cnt; k++) {
            const b = document.createElement("div"); b.classList.add("obstacle", "obs-long");
            b.x = gameWidth + 80; 
            b.style.left = b.x+"px";
            b.style.height = "35px";
            b.hp = OBS_HP;

            let sh = gameArea.offsetHeight;
            if(cnt===2) { if(k===0) b.style.bottom=randBetween(30, sh*0.35)+"px"; else b.style.bottom=randBetween(sh*0.55, sh*0.85)+"px"; }
            else { let r=Math.random(); if(r<0.2) b.style.bottom="0px"; else if(r<0.4) b.style.top="0px"; else b.style.bottom=randBetween(50, sh-120)+"px"; }
            gameArea.appendChild(b); obstacles.push(b);
        }
        return;
    }

    const type = (Math.random()<0.5)?'obs-log':'obs-rock';
    const sx = gameWidth + 80; 

    if(Math.random()<0.5) {
        const b = document.createElement("div"); b.classList.add("obstacle", "obs-cap", "obs-ground", type);
        b.style.height=randi(90,220)+"px"; b.x=sx; b.style.left=sx+"px"; b.style.bottom="0";
        b.hp = OBS_HP;
        gameArea.appendChild(b); obstacles.push(b);
    } else {
        let th=randi(120,260); let gap=randi(160,220); let bh=Math.max(80, gameArea.offsetHeight-th-gap);
        const t = document.createElement("div"); t.classList.add("obstacle", "obs-cap", "obs-ceil", type);
        t.style.height=th+"px"; t.x=sx; t.style.left=sx+"px"; t.style.top="0";
        t.hp = OBS_HP;
        const b = document.createElement("div"); b.classList.add("obstacle", "obs-cap", "obs-ground", type);
        b.style.height=bh+"px"; b.x=sx; b.style.left=sx+"px"; b.style.bottom="0";
        b.hp = OBS_HP;

        gameArea.appendChild(t); obstacles.push(t); 
        gameArea.appendChild(b); obstacles.push(b);
    }
}

  function damageLife() {
    // [Ìå®Ïπò] ÌûàÎì† Ïä§ÌÇ® 3Ï¢Ö Í≥µÌÜµ Î∂ÄÌôú Î°úÏßÅ
    if (HIDDEN_SKIN_CODES.includes(currentSkin) && life <= 1 && !hiddenReviveUsed) {
        triggerHiddenRevive();
        return;
    }

    if(life <= 1 && currentSkin === 'jaeguk' && !jaegukRevivedOnce) {
      if (skinLvl >= 2) {
        jaegukRevivedOnce = true; life = maxLife; document.getElementById("lifeText").innerText = life;
        const w = document.createElement('div'); w.className = 'angel-wing-effect'; gameArea.appendChild(w); setTimeout(()=>w.remove(), 2000);
        showFloatText("ü™Ω Î∂ÄÌôú!"); playSound('item'); activeEffects.invincible = 3; return;
      }
    }

    if(activeEffects.revive > 0) { life=3; document.getElementById("lifeText").innerText=life; activeEffects.revive=0; activeEffects.invincible=3; showFloatText("üëº Î∂ÄÌôú!"); return; }
    if(activeEffects.turbo>0 && !isFeverTime) return; 
    if(activeEffects.invincible>0 || invincible || !running) return;
    
    if(currentSkin === 'haeun' && haeunShieldActive) {
        haeunShieldActive = false; removeHaeunShield(); showFloatText("üõ°Ô∏è Î∞©Ïñ¥ ÏÑ±Í≥µ!"); playSound('parry'); return;
    }

    life--; document.getElementById("lifeText").innerText=life;
    invincible=true; player.style.opacity="0.4"; 
    setTimeout(()=>{invincible=false; player.style.opacity="1";}, 2000);
    playSound('hit');
    if(life<=0) gameOver();
  }

  function showFloatText(text) { const r=player.getBoundingClientRect(); const e=document.createElement("div"); e.classList.add("float-text"); e.innerText=text; e.style.left=(r.left+10)+"px"; e.style.top=(r.top-20)+"px"; document.body.appendChild(e); setTimeout(()=>e.remove(),1000); }
  function startGameNow() { 
      document.getElementById("startGuide").style.display="none"; 
      running=true; 
      lastTime=performance.now(); 
      if(sounds['bgm']) sounds['bgm'].play().catch(e=>console.log("BGM Error:", e));
      requestAnimationFrame(gameLoop); 
  }
    
  async function saveProgress() { 
    saveData.faith = faith; 
    try{
        await fetch(API_URL,{
            method:"POST",
            headers: { "Content-Type": "text/plain" },
            redirect: 'follow',
            body:JSON.stringify({type:"save",id,saveData})
        });
    }catch(e){} 
    localStorage.setItem("run_save",JSON.stringify(saveData)); 
  }

  async function gameOver() { 
      if(rankingSaved)return; 
      running=false; invincible=true; player.style.opacity="0.4"; 
      document.getElementById("finalDist").innerText=Math.floor(distance); 
      document.getElementById("gameOverModal").style.display="flex"; 
      try{
          await fetch(API_URL,{
              method:"POST",
              headers: { "Content-Type": "text/plain" },
              redirect: 'follow',
              body:JSON.stringify({type:"updateRanking",id,name,distance:Math.floor(distance),message:""})
          });
      }catch(e){} 
      rankingSaved=true; 
  }

  async function confirmRanking(e) {
      if(e && e.stopPropagation) e.stopPropagation();

      const btn = document.querySelector("#gameOverModal .action-btn:last-child");
      const originalText = btn.innerText;
      const msg = document.getElementById("rankMsg").value.trim();

      btn.innerText = "‚è≥ Îì±Î°ù Ï§ë...";
      btn.disabled = true;
      btn.style.opacity = "0.7";

      try{
          await fetch(API_URL,{
              method:"POST",
              headers: { "Content-Type": "text/plain" },
              redirect: 'follow',
              body:JSON.stringify({type:"updateComment", id, message:msg})
          }); 
          
          btn.innerText = "‚úÖ Îì±Î°ù ÏôÑÎ£å!";
          
          document.getElementById("gameOverModal").style.display = "none";
          showFloatText("üèÜ ÏàúÏúÑ Îì±Î°ù ÏôÑÎ£å!");
          playSound('clear');

          setTimeout(() => {
              window.location.href="/TrapGame/menu.html";
          }, 1500);

      } catch(e){
          alert("ÏÑúÎ≤Ñ ÌÜµÏã† Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
          btn.innerText = originalText;
          btn.disabled = false;
          btn.style.opacity = "1";
      } 
  }
    
  async function pauseForQuiz() {
    if (!running) return;
    running = false; document.getElementById("loadingQuiz").style.display = "flex";
    try {
      const res = await fetch(API_URL, { 
          method: "POST", 
          headers: { "Content-Type": "text/plain" },
          redirect: 'follow',
          body: JSON.stringify({ type: "getQuiz" }) 
      });
      const txt = await res.text();
      document.getElementById("loadingQuiz").style.display = "none";
      if (txt === "noquiz") { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); return; }
      const quiz = JSON.parse(txt);
      document.getElementById("quizQuestion").innerText = quiz.question;
      document.getElementById("btnA").innerText = "A) " + quiz.A;
      document.getElementById("btnB").innerText = "B) " + quiz.B;
      document.getElementById("btnC").innerText = "C) " + quiz.C;
      window.correctAnswer = quiz.answer;
      document.getElementById("quizModal").style.display = "flex";
    } catch (err) {
      alert("ÌÄ¥Ï¶à Î°úÎî© Ïã§Ìå®. Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.");
    }
  }

  function answerQuiz(sel) {
    document.getElementById("quizModal").style.display = "none";
    
    if (sel === window.correctAnswer) {
      const ef = document.getElementById("correctEffect");
      ef.innerText = "üöÄ +30m Ï†ÑÏßÑ!";
      ef.style.color = "#00ffcc"; 
      ef.style.display = "block"; 
      setTimeout(() => (ef.style.display = "none"), 800);
      
      distance += 30; 
      document.getElementById("distanceText").innerText = Math.floor(distance) + "m";
      showFloatText("üöÄ ÏõåÌîÑ ÏÑ±Í≥µ!");
      
      saveProgress();
      
    } else { 
      const ef = document.getElementById("correctEffect");
      ef.innerText = "üìâ Ïã†ÏïôÏã¨ -30";
      ef.style.color = "#ff0000"; 
      ef.style.display = "block";
      setTimeout(() => (ef.style.display = "none"), 800);

      faith = Math.max(0, faith - 30); 
      document.getElementById("faithText").innerText = faith;
      saveData.faith = faith;
      showFloatText("üíî Ïò§ÎãµÏûÖÎãàÎã§...");
      saveProgress();
    }
    
    if (life > 0) { 
        running = true; 
        lastTime = performance.now(); 
        requestAnimationFrame(gameLoop); 
    }
  }
  
  let lastT=0; document.addEventListener("touchend",e=>{const n=Date.now();if(n-lastT<300)e.preventDefault();lastT=n;},{passive:false});

    // ==========================================
  // [Ìå®Ïπò] ÌûàÎì† Ï∫êÎ¶≠ÌÑ∞ Í∏∞Îä• Íµ¨ÌòÑÎ∂Ä
  // ==========================================

  function toggleHiddenTransform() {
      hiddenTransformActive = !hiddenTransformActive;

      if (hiddenTransformActive) {
          // Î≥ÄÏã† ON
          showFloatText("‚ú® TRANSFORMATION!");
          playSound('clear');
          const flash = document.getElementById('flashEffect');
          flash.style.opacity = '1'; setTimeout(() => flash.style.opacity = '0', 300);

          if (currentSkin === 'Hidden_Skin1') {
              player.style.backgroundImage = `url('skin_Hidden_Skin1_1.png')`;
              showFloatText("‚öîÔ∏è Ï†ÑÏã†Í∞ëÏ£º Ïû•Ï∞©!");
              subActionBtn.style.display = 'flex';
              subActionBtn.className = 'btn-attack';
              subActionBtn.style.background = "gold";
              subActionBtn.style.color = "black";
              subActionBtn.style.border = "4px solid #fff";
          }
          else if (currentSkin === 'Hidden_Skin2') {
              player.style.backgroundImage = `url('skin_Hidden_Skin2_1.png')`;
              document.querySelector('.aeran-flower-bg').style.opacity = '1';
              showFloatText("üå∏ ÎßêÏîÄÏùÄ ÏÇ¨Îûë!");
          }
          else if (currentSkin === 'Hidden_Skin3') {
              player.style.backgroundImage = `url('skin_Hidden_Skin3_1.png')`;
              spawnJongrakSquad();
              showFloatText("üé≤ Ï†ÑÏÑ§Ïùò ÏãúÏûë!");
          }
      } else {
          // Î≥ÄÏã† OFF
          showFloatText("Î≥ÄÏã† Ìï¥Ï†ú");
          player.style.backgroundImage = `url('skin_${currentSkin}.png')`;
          abilityCD = 10; // Ïø®ÌÉÄÏûÑ 10Ï¥à

          if (currentSkin === 'Hidden_Skin1') {
              subActionBtn.style.background = ""; 
              subActionBtn.style.color = "";
              updateSubActionButtonUI();
          }
          else if (currentSkin === 'Hidden_Skin2') {
              document.querySelector('.aeran-flower-bg').style.opacity = '0';
          }
          else if (currentSkin === 'Hidden_Skin3') {
              clearJongrakSquad();
          }
      }
  }

  function consumeFaithPerSec(amount, dt) {
      // 1Ï¥àÎãπ amountÎßåÌÅº Í∞êÏÜå (ÌôïÎ•†Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨ÌïòÏó¨ Ï†ïÏàò Í∞êÏÜå ÌëúÌòÑ)
      if (faith > 0) {
          if(Math.random() < amount * dt) {
             faith--; 
             document.getElementById("faithText").innerText = faith;
          }
          if (faith <= 0) toggleHiddenTransform(); 
      } else {
          toggleHiddenTransform();
      }
  }

  function updateSubActionBtnForHidden1() {
      if (hiddenAttackCooldown > 0) {
          subActionBtn.classList.add('cooldown');
          subActionBtn.innerText = Math.ceil(hiddenAttackCooldown);
      } else {
          subActionBtn.classList.remove('cooldown');
          subActionBtn.innerText = "HOLY SWORD";
      }
  }

  function triggerJaegwanSword() {
      faith -= 10; 
      document.getElementById("faithText").innerText = faith;
      hiddenAttackCooldown = 2.0; 
      showFloatText("üó°Ô∏è ÎπõÏùò Í≤Ä!");
      playSound('item');

      for(let i=0; i<8; i++) {
          const sword = document.createElement('div');
          sword.className = 'light-sword';
          sword.style.left = randBetween(0, gameArea.offsetWidth) + 'px';
          sword.style.top = '-100px';
          gameArea.appendChild(sword);
          
          setTimeout(() => {
              checkSwordCollision(sword);
              setTimeout(() => sword.remove(), 200); 
          }, 400);
      }
  }

  function checkSwordCollision(swordEl) {
      const sx = parseFloat(swordEl.style.left);
      const range = 60; 
      obstacles.forEach(o => {
          if (!o.destroyed && Math.abs(o.x - sx) < range) {
              o.destroyed = true; spawnExplosionEffect(o.x, gameArea.offsetHeight - 100); o.remove();
          }
      });
      enemies.forEach(e => {
          if (!e.isDead && Math.abs(e.x - sx) < range) {
              e.isDead = true; spawnExplosionEffect(e.x, e.y); e.remove();
          }
      });
  }

  function spawnAeranFlowers(dt) {
      aeranFlowerTimer += dt;
      if (aeranFlowerTimer > 0.2) { 
          const f = document.createElement('div');
          f.className = 'flower-missile';
          f.style.left = randBetween(0, gameArea.offsetWidth) + 'px';
          f.style.top = '-50px';
          gameArea.appendChild(f);
          
          let fallInterval = setInterval(() => {
              let top = parseFloat(f.style.top);
              top += 10; f.style.top = top + 'px';
              
              let hit = false;
              const fRect = f.getBoundingClientRect();
              
              obstacles.forEach(o => {
                  if(!o.destroyed && !hit) {
                      const oRect = o.getBoundingClientRect();
                      if(!(fRect.right < oRect.left || fRect.left > oRect.right || fRect.bottom < oRect.top || fRect.top > oRect.bottom)) {
                          o.destroyed = true; o.remove(); hit = true;
                      }
                  }
              });
              if(!hit) {
                  enemies.forEach(e => {
                      if(!e.isDead && !hit) {
                          const eRect = e.getBoundingClientRect();
                          if(!(fRect.right < eRect.left || fRect.left > eRect.right || fRect.bottom < eRect.top || fRect.top > eRect.bottom)) {
                              e.isDead = true; e.remove(); hit = true;
                          }
                      }
                  });
              }

              if (hit || top > gameArea.offsetHeight) {
                  clearInterval(fallInterval);
                  f.remove();
                  if(hit) spawnExplosionEffect(parseFloat(f.style.left), top);
              }
          }, 30);
          aeranFlowerTimer = 0;
      }
  }

  function spawnJongrakSquad() {
      const skins = ['ganghui', 'jaeguk', 'jeonchan', 'jieun', 'jihye', 'jun', 'noel', 'stephanie', 'yejun', 'haeun', 'hahwi'];
      for(let i=0; i<5; i++) {
          const kid = document.createElement('div');
          kid.className = 'jongrak-kid';
          const rSkin = skins[Math.floor(Math.random() * skins.length)];
          kid.style.backgroundImage = `url('skin_${rSkin}.png')`;
          kid.x = playerObj.x + randBetween(-50, 50);
          kid.y = playerObj.y + randBetween(50, 150);
          kid.vx = randBetween(-2, 2); kid.vy = randBetween(-2, 2);
          gameArea.appendChild(kid);
          jongrakKids.push(kid);
      }
  }

  function clearJongrakSquad() {
      jongrakKids.forEach(k => {
          spawnParticles(parseFloat(k.style.left), parseFloat(k.style.top), 'dust'); k.remove();
      });
      jongrakKids = [];
  }

  function updateJongrakSquad(dt) {
      jongrakKidFireTimer += dt;
      let fire = false;
      if (jongrakKidFireTimer > 0.5) { fire = true; jongrakKidFireTimer = 0; }

      jongrakKids.forEach(k => {
          k.x += k.vx; k.y += k.vy;
          if(k.x < playerObj.x - 100 || k.x > playerObj.x + 100) k.vx *= -1;
          if(k.y < playerObj.y + 50 || k.y > playerObj.y + 200) k.vy *= -1;
          k.style.left = k.x + 'px'; k.style.bottom = k.y + 'px';

          if (fire) {
              const heart = document.createElement('div');
              heart.className = 'heart-missile';
              heart.innerText = ['‚ù§Ô∏è','üß°','üíõ','üíö','üíô','üíú'][Math.floor(Math.random()*6)];
              heart.style.left = k.x + 'px'; heart.style.bottom = k.y + 'px';
              gameArea.appendChild(heart);
              
              let hx = k.x; let hy = k.y;
              let hInterval = setInterval(() => {
                  hx += 10; heart.style.left = hx + 'px';
                  let hit = false;
                  obstacles.forEach(o => {
                      if (!o.destroyed && !hit && Math.abs(o.x - hx) < 30) {
                          o.destroyed = true; o.remove(); hit = true;
                      }
                  });
                  enemies.forEach(e => {
                      if (!e.isDead && !hit && Math.abs(e.x - hx) < 30) {
                          e.isDead = true; e.remove(); hit = true;
                      }
                  });
                  if (hit || hx > gameArea.offsetWidth) {
                      clearInterval(hInterval); heart.remove();
                      if(hit) spawnExplosionEffect(hx, gameArea.offsetHeight - hy);
                  }
              }, 20);
          }
      });
  }

  function triggerHiddenHeal() {
      if (life < maxLife) {
          life = Math.min(life + 5, maxLife + 10);
          document.getElementById("lifeText").innerText = life;
          showFloatText("üíñ +5 Holy Heal");
          playSound('item');
      }
      if (currentSkin === 'Hidden_Skin1') {
          const angel = document.createElement('div'); angel.className = 'angel-heal-unit';
          angel.style.left = (playerObj.x + 20) + 'px'; angel.style.top = (gameArea.offsetHeight - playerObj.y - 120) + 'px';
          gameArea.appendChild(angel); setTimeout(() => angel.remove(), 3000);
      }
      else if (currentSkin === 'Hidden_Skin2') {
          const halo = document.createElement('div'); halo.className = 'aeran-halo';
          gameArea.appendChild(halo); setTimeout(() => halo.remove(), 2000);
      }
      else if (currentSkin === 'Hidden_Skin3') {
          const light = document.createElement('div'); light.className = 'jongrak-light';
          gameArea.appendChild(light); setTimeout(() => light.remove(), 2000);
      }
  }

  function triggerHiddenRevive() {
      hiddenReviveUsed = true;
      life = maxLife; document.getElementById("lifeText").innerText = life;
      gameArea.classList.add('revive-quake');
      
      const layer = document.createElement('div');
      layer.className = 'holy-resurrection';
      layer.innerHTML = `<div class="resurrection-text">ÏòàÏàòÏùò Îä•Î†•Ïù¥<br>ÎÇòÎ•º ÏùºÏúºÌÇ®Îã§!</div>`;
      document.body.appendChild(layer);
      setTimeout(() => layer.style.opacity = '1', 10);
      
      player.style.filter = "brightness(10) drop-shadow(0 0 20px white)";
      activeEffects.invincible = 5; playSound('clear');

      setTimeout(() => {
          layer.style.opacity = '0'; gameArea.classList.remove('revive-quake');
          player.style.filter = "none";
          setTimeout(() => layer.remove(), 1000);
      }, 3000);
  }
    
</script>
</body>
</html>
