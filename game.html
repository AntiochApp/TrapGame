<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Disciple Run â€“ Game</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    :root {
      --hud-bg: rgba(255, 248, 235, 0.9);
      --hud-border: #3a2513;
      --accent: #c47a3f;
      --accent-dark: #8b4f26;
      --panel-bg: #fdfaf2;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; overscroll-behavior: none; touch-action: none;
      font-family: "Pretendard", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    #gameArea {
      position: relative; width: 100vw; height: 100vh; overflow: hidden;
      background: linear-gradient(#88c6ff 0%, #b7e3ff 45%, #f7f0d9 45%, #f0e0b0 100%);
    }

    #bgLayer1, #bgLayer2, #bgLayer3 {
      position: absolute; left: 0; top: 0; width: 200%; height: 100%;
      background-repeat: repeat-x; image-rendering: pixelated; pointer-events: none;
      will-change: background-position;
    }
    #bgLayer1 { background-image: url("https://antiochapp.github.io/TrapGame/bg_sky.png"); z-index: 1; background-size: auto 100%; background-position: 0 bottom; }
    #bgLayer2 { background-image: url("https://antiochapp.github.io/TrapGame/bg_mountain.png"); z-index: 2; background-size: auto 100%; background-position: 0 bottom; }
    #bgLayer3 { background-image: url("https://antiochapp.github.io/TrapGame/bg_forest.png"); z-index: 3; background-size: auto 60%; background-position: 0 bottom; }

    #ground { display: none; }

    #player {
      position: absolute; 
      z-index: 50; 
      left: 120px; bottom: 40px; 
      width: 60px; height: 60px;
      
      background-image: url("disciple.png");
      background-position: center;
      background-size: contain;
      background-repeat: no-repeat;
      
      image-rendering: pixelated;
      transition: opacity 0.2s, filter 0.3s; 
      filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.2)); 
    }

    .obstacle {
      position: absolute; z-index: 40; background-size: 8px 8px; box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
    }
    .obs-cap::after {
        content: ''; position: absolute; left: -10%; width: 120%; height: 24px; box-sizing: border-box; border-radius: 4px;
    }
    .obs-ground.obs-cap::after { top: -12px; }
    .obs-ceil.obs-cap::after { bottom: -12px; }

    .obs-log { width: 60px; background-color: #8D6E63; border-left: 4px solid #5D4037; border-right: 4px solid #5D4037; background-image: linear-gradient(90deg, rgba(0,0,0,0.05) 50%, transparent 50%), linear-gradient(rgba(0,0,0,0.05) 50%, transparent 50%); }
    .obs-log.obs-cap::after { background-color: #66BB6A; border: 4px solid #1B5E20; background-image: linear-gradient(45deg, transparent 80%, rgba(255,255,255,0.3) 80%); }

    .obs-rock { width: 60px; background-color: #9E9E9E; border-left: 4px solid #616161; border-right: 4px solid #616161; background-image: radial-gradient(circle, rgba(0,0,0,0.1) 20%, transparent 20%), radial-gradient(circle, rgba(255,255,255,0.1) 20%, transparent 20%); background-size: 16px 16px; }
    .obs-rock.obs-cap::after { background-color: #BDBDBD; border: 4px solid #424242; }

    .obs-long { width: 240px; height: 35px; background-color: #5D4037; background-image: linear-gradient(0deg, rgba(0,0,0,0.2) 50%, transparent 50%); background-size: 100% 10px; border: 3px solid #3E2723; border-radius: 8px; box-shadow: 0 5px 5px rgba(0,0,0,0.3); }

    .projectile { 
      position: absolute; z-index: 60; width: 40px; height: 40px; 
      border-radius: 50%; 
      background: radial-gradient(circle at 30% 30%, #ffeb3b, #ff5722); 
      box-shadow: 0 0 10px #ff9800; 
      animation: spinMeteor 1s linear infinite; 
    }
    .projectile::before { 
      content: ''; position: absolute; top: -30px; right: -30px; width: 80px; height: 80px; 
      background: linear-gradient(45deg, transparent 60%, rgba(255,87,34,0.8)); 
      transform: rotate(45deg); z-index: -1; border-radius: 50%; filter: blur(4px); 
    }
    
    .missile-style {
      filter: hue-rotate(220deg) brightness(1.2); 
    }

    @keyframes spinMeteor { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    .item { position: absolute; z-index: 45; width: 48px; height: 48px; image-rendering: pixelated; background-position: center; background-repeat: no-repeat; background-size: contain; animation: itemFloat 1.5s ease-in-out infinite alternate; }
    @keyframes itemFloat { from { transform: translateY(0); } to { transform: translateY(-8px); } }

    #hud { position: fixed; z-index: 900; top: 12px; left: 12px; color: #3a2513; font-size: 18px; font-weight: 700; background: var(--hud-bg); border-radius: 10px; padding: 8px 12px; border: 3px solid var(--hud-border); }
    #hud span { display: inline-block; min-width: 60px; }

    #buffArea { position: fixed; z-index: 2147483647; bottom: 20px; right: 15px; display: flex; flex-direction: column-reverse; align-items: flex-end; gap: 8px; pointer-events: none; transform: translateZ(0); -webkit-transform: translateZ(0); }
    .buff-tag { background: rgba(0, 0, 0, 0.85); color: #fff; padding: 8px 14px; border-radius: 8px; font-size: 16px; font-weight: 700; box-shadow: 0 4px 8px rgba(0,0,0,0.5); border-left: 5px solid; }

    #abilityBtn {
      position: fixed; bottom: 20px; right: 20px; width: 80px; height: 80px;
      background: #ff5722; color: white; border-radius: 50%; border: 4px solid #fff;
      font-weight: bold; font-size: 24px; display: none;
      justify-content: center; align-items: center; cursor: pointer; z-index: 1000;
      box-shadow: 0 6px 12px rgba(0,0,0,0.6); user-select: none;
      flex-direction: column; text-align: center; line-height: 1.1;
    }
    #abilityBtn.cooldown { filter: grayscale(1); opacity: 0.7; cursor: not-allowed; background: #555; }
    #abilityBtn span { font-size: 12px; display: block; margin-top: 2px; }

    #speedLines { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 80; background: radial-gradient(circle, transparent 40%, rgba(255, 255, 255, 0.8) 90%); mix-blend-mode: overlay; pointer-events: none; animation: speedShake 0.1s infinite; }
    @keyframes speedShake { 0% { transform: translate(0, 0); } 25% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 75% { transform: translate(-2px, -2px); } 100% { transform: translate(0, 0); } }

    .float-text { position: absolute; color: #ffe24f; font-weight: 900; font-size: 20px; text-shadow: 2px 2px 0 #3a2513; z-index: 1000; pointer-events: none; animation: floatUp 1s ease-out forwards; }
    @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-60px) scale(1.2); opacity: 0; } }

    #comboEffect, #correctEffect { position: fixed; left: 50%; transform: translateX(-50%); z-index: 1000; display: none; pointer-events: none; }
    #comboEffect { top: 20%; font-size: 40px; font-weight: 900; color: #ffe24f; text-shadow: 3px 3px #8b4f26; }
    #correctEffect { top: 40%; font-size: 48px; font-weight: 900; color: #00ffcc; text-shadow: 3px 3px #006644; }

    .modal-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.55); display: none; justify-content: center; align-items: center; padding: 16px; z-index: 20000; }
    .modal-box { width: 90%; max-width: 420px; background: var(--panel-bg); border-radius: 14px; border: 4px solid #3a2513; padding: 28px 24px; box-shadow: 0 0 0 4px #fff, 0 10px 0 #b79b76; text-align: center; }
    .modal-title { font-size: 28px; font-weight: 800; margin-bottom: 18px; }
    .modal-desc { font-size: 17px; margin-bottom: 22px; line-height: 1.45; white-space: pre-line; }
    
    .choice-btn, .action-btn, .start-btn { width: 100%; padding: 14px; margin: 8px 0; background: var(--accent); border: 0; border-radius: 10px; color: #fff; font-size: 18px; font-weight: 700; box-shadow: 0 4px 0 var(--accent-dark); cursor: pointer; }
    .choice-btn:active, .action-btn:active, .start-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--accent-dark); }
    .action-btn:disabled { background: #999; cursor: not-allowed; box-shadow: none; }
    
    .modal-input { width: 85%; max-width: 320px; padding: 12px; font-size: 16px; border-radius: 8px; border: 2px solid #b8a792; margin: 8px auto 18px; display: block; }
    #loadingQuiz { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); justify-content: center; align-items: center; color: #fff; font-size: 22px; font-weight: 700; backdrop-filter: blur(2px); z-index: 20001; }
  </style>
</head>

<body>
<div id="gameArea">
  <div id="startGuide" class="modal-bg" style="display:flex;">
    <div class="modal-box">
      <div class="modal-title">ê²Œì„ ë°©ë²• / How to Play</div>
      <div class="modal-desc" style="text-align:left; font-size:15px;">
â€¢ <b>Space</b> / <b>í„°ì¹˜</b>: ì í”„
â€¢ <b>Aí‚¤</b> / <b>ë²„íŠ¼</b>: íŠ¹ìˆ˜ëŠ¥ë ¥ (ìŠ¤í‚¨ ë³´ìœ ì‹œ)
â€¢ ì¥ì• ë¬¼ì„ í”¼í•´ <b>ì‹ ì•™ ì ìˆ˜(Faith)</b> íšë“

[ì•„ì´í…œ íš¨ê³¼]
âœï¸ <b>ì‹­ìê°€:</b> ë¬´ì  (ê¸°ë³¸ 10ì´ˆ + ê°•í™”)
ğŸ•Šï¸ <b>ë‚ ê°œ:</b> í„°ë³´ ëª¨ë“œ (ê¸°ë³¸ 5ì´ˆ + ê°•í™”)
ğŸƒ <b>ë°”ëŒ:</b> ì†ë„ ê°ì†Œ (ê¸°ë³¸ 10ì´ˆ + ê°•í™”)
ğŸ“˜ <b>ì„±ê²½:</b> Faith +10
      </div>
      <button class="start-btn" onclick="startGameNow()">â–¶ ì‹œì‘í•˜ê¸° / Start</button>
    </div>
  </div>

  <div id="bgLayer1"></div>
  <div id="bgLayer2"></div>
  <div id="bgLayer3"></div>

  <div id="speedLines"></div>

  <div id="ground"></div>
  <div id="player"></div>

  <div id="hud">
    â¤ï¸ <span id="lifeText"></span> 
    ğŸ“ <span id="distanceText">0m</span> 
    âœ <span id="faithText"></span>
  </div>
  
  <div id="abilityBtn" onclick="useAbility()">A<br><span>Ready</span></div>
</div>

<div id="buffArea"></div>

<div id="comboEffect">COMBO +1!</div>
<div id="correctEffect">+5 Faith!</div>

<div id="quizModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">ì„±ê²½ í€´ì¦ˆ</div>
    <div class="modal-desc" id="quizQuestion"></div>
    <button class="choice-btn" onclick="answerQuiz('A')" id="btnA"></button>
    <button class="choice-btn" onclick="answerQuiz('B')" id="btnB"></button>
    <button class="choice-btn" onclick="answerQuiz('C')" id="btnC"></button>
  </div>
</div>

<div id="gameOverModal" class="modal-bg">
  <div class="modal-box">
    <div class="modal-title">GAME OVER</div>
    <div class="modal-desc">
      <b><span id="finalDist"></span>m</b> ë‹¬ë ¸ìŠµë‹ˆë‹¤!
    </div>
    <input id="rankMsg" class="modal-input" type="text" placeholder="ì†Œê° ì…ë ¥(ì„ íƒ)" />
    <button class="action-btn" style="background:#5d4037;" onclick="location.reload()">ğŸ”„ ë‹¤ì‹œí•˜ê¸°</button>
    <button class="action-btn" onclick="confirmRanking()">[ìˆœìœ„ë“±ë¡]</button>
  </div>
</div>

<div id="loadingQuiz">â³ ì„±ê²½ ë¬¸ì œë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...</div>

<script>
  const API_URL = "https://script.google.com/macros/s/AKfycbzA10H2TuXRDXBXcttvHHR0Q1sOu8zGpYmrdGhfH-wBsl623k2ydwUkwL7wR8F90mC5Pg/exec";

  let id = localStorage.getItem("run_id");
  let name = localStorage.getItem("run_name");
  let saveData = JSON.parse(localStorage.getItem("run_save") || "{}");

  if (!id) {
    alert("ë¡œê·¸ì¸ í•„ìš”");
    window.location.href = "/TrapGame/index.html";
  }

  let daily = JSON.parse(localStorage.getItem("dailyMission") || "{}");
  function initDailyMission() {
    return { date: new Date().toDateString(), run200: false, quiz3: 0, faith20: 0 };
  }
  if (!daily.date || daily.date !== new Date().toDateString()) {
    daily = initDailyMission();
    localStorage.setItem("dailyMission", JSON.stringify(daily));
  }

  // --- ì´ˆê¸°í™” ---
  let life  = 3 + (saveData.extraLife || 0);
  let faith = saveData.faith || 0;
  let agility = saveData.agility || 0;
  
  let lvlInvincible = saveData.up_invincible || 0;
  let lvlTurbo      = saveData.up_turbo || 0;
  let lvlSlow       = saveData.up_slow || 0;
  
  let currentSkin   = saveData.equippedSkin || "default";

  const SKIN_DATA = {
    default: { type: "none" },
    noel: { type: "Active", cd: 60, name: "ë…¸ì—˜" },
    jeonchan: { type: "Passive", cd: 40, name: "ì „ì°¬" },
    haeun: { type: "Passive", cd: 30, name: "í•˜ì€" },
    jaeguk: { type: "Active", cd: 120, name: "ì¬êµ­" },
    hahwi: { type: "Passive", cd: 20, name: "í•˜íœ˜" },
    jihye: { type: "Passive", name: "ì§€í˜œ" },
    jun: { type: "Passive", name: "ì¤€" },
    stephanie: { type: "Passive", name: "ìŠ¤í…ŒíŒŒë‹ˆ" },
    yejun: { type: "Active", cd: 180, name: "ì˜ˆì¤€" },
    ganghui: { type: "Passive", cd: 20, name: "ê°•í¬" },
    jieun: { type: "Active", cd: 120, name: "ì§€ì€" }
  };

  const abilityBtn = document.getElementById('abilityBtn');
  if(SKIN_DATA[currentSkin].type === "Active") {
    abilityBtn.style.display = 'flex';
  }

  document.getElementById("lifeText").innerText  = life;
  document.getElementById("faithText").innerText = faith;

  const gameArea = document.getElementById("gameArea");
  const player   = document.getElementById("player");
  
  const bg1 = document.getElementById("bgLayer1");
  const bg2 = document.getElementById("bgLayer2");
  const bg3 = document.getElementById("bgLayer3");

  // ìŠ¤í‚¨ ì ìš©
  if (currentSkin !== 'default') {
      player.style.backgroundImage = `url('skin_${currentSkin}.png')`;
  } else {
      player.style.backgroundImage = `url('disciple.png')`;
  }

  let buffArea = document.getElementById("buffArea");
  if (!buffArea) {
    buffArea = document.createElement("div");
    buffArea.id = "buffArea";
    document.body.appendChild(buffArea);
  }
  let speedLines = document.getElementById("speedLines");
  if (!speedLines) {
    speedLines = document.createElement("div");
    speedLines.id = "speedLines";
    gameArea.insertBefore(speedLines, document.getElementById("player"));
  }

  let playerY  = 40;
  let velocity = 0;
  let gravity  = -0.25; 
  let jumpPower = 6.5 - agility * 0.05;
  jumpPower     = Math.max(3, jumpPower);

  let targetY = 0;

  let distance  = 0;
  let obstacles = [];
  let projectiles = []; // ìš´ì„+ë¯¸ì‚¬ì¼
  let running   = false;
  let invincible = false;

  const BASE_SPEED = 170; 
  let gameSpeed    = BASE_SPEED;

  let lastTime = performance.now();
  let quizTimer = 0;
  let nextFaithMilestone = 100;
  
  let obstacleTimer = 0;
  let nextObstacleTime = 2.0;
  
  let meteorTimer = 0; 
  let missileTimer = 0;

  let itemTimer = 0;
  let nextItemTime = 8;
  let skinTimer = 0;
  let abilityCD = 0;

  let bg1X = 0, bg2X = 0, bg3X = 0;
  const BG1_SPEED = 20; const BG2_SPEED = 40; const BG3_SPEED = 60;

  let items = [];
  let combo = 0;
  let obstacleSurviveCount = 0;
  let rankingSaved = false;

  let activeEffects = { 
    turbo: 0, invincible: 0, slow: 0, 
    fly: 0, revive: 0, summon: 0 
  };

  function randBetween(min, max) { return Math.random() * (max - min) + min; }

  function jump() {
    if (!running) return;
    if (activeEffects.turbo > 0 || activeEffects.fly > 0) return;
    velocity = jumpPower;
  }
  
  document.body.addEventListener("keydown", e => {
    if (e.code === "Space" || e.code === "ArrowUp") { e.preventDefault(); jump(); }
    if (e.code === "KeyA") useAbility(); 
  });
  document.body.addEventListener("touchstart", jump);
  
  window.addEventListener('mousemove', e => targetY = window.innerHeight - e.clientY);
  window.addEventListener('touchmove', e => targetY = window.innerHeight - e.touches[0].clientY);

  function useAbility() {
    if(!running || abilityCD > 0) return;
    const s = SKIN_DATA[currentSkin];
    
    if(currentSkin === 'noel') {
      showFloatText("ğŸŒŠ ê¸¸ ì—´ë¦¼!");
      document.querySelectorAll('.obstacle').forEach(el => {
        if(el.style.bottom === '0px') el.style.bottom = '-150px'; 
        else el.style.top = '-150px';
      });
    }
    else if(currentSkin === 'jaeguk') {
      activeEffects.revive = 30;
      showFloatText("ğŸ‘¼ ìë™ ë¶€í™œ On");
    }
    else if(currentSkin === 'yejun') {
      activeEffects.fly = 30;
      showFloatText("âœˆï¸ ììœ  ë¹„í–‰");
    }
    else if(currentSkin === 'jieun') {
      activeEffects.summon = 20;
      showFloatText("ğŸ›¡ï¸ ë…¸ì—˜ ì†Œí™˜!");
    }
    abilityCD = s.cd;
  }

  function handleSkinPassive(dt) {
    skinTimer += dt;
    if(currentSkin === 'jeonchan' && skinTimer >= 40) { 
      const rand = Math.floor(Math.random()*4);
      if(rand==0) { activeEffects.slow = 15; showFloatText("ëœë¤: ê°ì†"); }
      else if(rand==1) { activeEffects.fly = 15; showFloatText("ëœë¤: ë¬´ì¤‘ë ¥"); }
      else if(rand==2) { showFloatText("ëœë¤: Faith X2"); }
      else { spawnItem(); showFloatText("ëœë¤: ì•„ì´í…œ"); }
      skinTimer = 0;
    }
    else if(currentSkin === 'haeun' && skinTimer >= 30) { 
      document.querySelectorAll('.obstacle').forEach(e => e.remove());
      obstacles = [];
      showFloatText("âœ¨ ì •í™”!");
      skinTimer = 0;
    }
    else if(currentSkin === 'hahwi' && skinTimer >= 20) { 
      activeEffects.invincible = 5;
      showFloatText("ğŸ›¡ï¸ ìë™ ë¬´ì ");
      skinTimer = 0;
    }
    else if(currentSkin === 'ganghui' && skinTimer >= 20) { 
      if(obstacles.length > 0) {
        obstacles[0].remove(); obstacles.shift(); showFloatText("ğŸ”¥ íŒŒê´´!");
      }
      skinTimer = 0;
    }
  }

  function updateAbilityBtn(dt) {
    if(abilityCD > 0) {
      abilityCD -= dt;
      abilityBtn.classList.add('cooldown');
      abilityBtn.innerHTML = Math.ceil(abilityCD);
    } else {
      abilityBtn.classList.remove('cooldown');
      abilityBtn.innerHTML = "A<br><span>Ready</span>";
    }
  }

  function scheduleNextObstacle(speedMultiplier) {
    if (activeEffects.turbo > 0) return;
    let baseTime = randBetween(1.8, 2.6);
    nextObstacleTime = baseTime / (1 + (speedMultiplier - 1) * 0.6); 
    if (nextObstacleTime < 0.2) nextObstacleTime = 0.2;
  }

  function spawnObstacle() {
    if (!running) return;
    if (activeEffects.turbo > 0) return;

    const randi = (min, max) => Math.floor(Math.random() * (max - min)) + min;
    let spawnHorizontal = (distance > 50) && (Math.random() < 0.65);

    if (spawnHorizontal) {
        let count = (Math.random() < 0.3) ? 2 : 1;
        for(let k=0; k<count; k++) {
            const box = document.createElement("div");
            box.classList.add("obstacle", "obs-long");
            box.style.left = (window.innerWidth + 80) + "px";
            let safeH = window.innerHeight;
            if(count === 2) {
                if(k===0) box.style.bottom = randBetween(30, safeH * 0.35) + "px";
                else      box.style.bottom = randBetween(safeH * 0.55, safeH * 0.85) + "px";
            } else {
                let r = Math.random();
                if(r < 0.2) box.style.bottom = "0px";
                else if(r < 0.4) box.style.top = "0px"; 
                else box.style.bottom = randBetween(50, safeH - 120) + "px";
            }
            gameArea.appendChild(box);
            obstacles.push(box);
        }
        return;
    }

    const useGroundBox = Math.random() < 0.5;
    const obsTypeClass = (Math.random() < 0.5) ? 'obs-log' : 'obs-rock';
    const startX = window.innerWidth + 80;

    if (useGroundBox) {
      const box = document.createElement("div");
      box.classList.add("obstacle", "obs-cap", "obs-ground", obsTypeClass);
      box.style.height = randi(90, 220) + "px";
      box.style.left = startX + "px";
      box.style.bottom = "0";
      gameArea.appendChild(box);
      obstacles.push(box);
    } else {
      let topH = randi(120, 260);
      let gap = randi(160, 220);
      let bottomH = Math.max(80, window.innerHeight - topH - gap);
      const topObs = document.createElement("div");
      topObs.classList.add("obstacle", "obs-cap", "obs-ceil", obsTypeClass);
      topObs.style.height = topH + "px";
      topObs.style.left = startX + "px";
      topObs.style.top = "0";
      gameArea.appendChild(topObs);
      const bottomObs = document.createElement("div");
      bottomObs.classList.add("obstacle", "obs-cap", "obs-ground", obsTypeClass);
      bottomObs.style.height = bottomH + "px";
      bottomObs.style.left = startX + "px";
      bottomObs.style.bottom = "0";
      gameArea.appendChild(bottomObs);
      obstacles.push(topObs, bottomObs);
    }
  }

  // [ìˆ˜ì •] ìš´ì„ ìƒì„± (150m~) - ë…ë¦½ ì†ë„ ì ìš©
  function spawnMeteor(currentProgress) {
    const meteor = document.createElement("div");
    meteor.classList.add("projectile"); 

    const startX = window.innerWidth + Math.random() * 200;
    const startY = -100;
    
    // ë…ë¦½ ì†ë„ ê³„ì‚°: ê¸°ë³¸ 150 + ì§„í–‰ë„ì— ë”°ë¼ ì•½ê°„ ì¦ê°€ (ìµœëŒ€ 2.5ë°° ì •ë„)
    // ê²Œì„ ì „ì²´ ì†ë„(15ë°°)ë¥¼ ë”°ë¼ê°€ì§€ ì•ŠìŒ
    let speed = 150 + (currentProgress * 200); 
    
    const vx = -speed * 0.8;
    const vy = speed * 1.0;

    meteor.style.left = startX + "px";
    meteor.style.top = startY + "px";
    
    meteor.x = startX; meteor.y = startY;
    meteor.vx = vx; meteor.vy = vy;

    gameArea.appendChild(meteor);
    projectiles.push(meteor);
  }

  // [ìˆ˜ì •] ë¯¸ì‚¬ì¼ ìƒì„± (200m~) - ë…ë¦½ ì†ë„ ì ìš©
  function spawnMissile(currentProgress) {
    const missile = document.createElement("div");
    missile.classList.add("projectile", "missile-style"); 

    const startX = window.innerWidth + 50;
    const startY = Math.random() * (window.innerHeight - 100);

    const pX = 120 + 30; 
    const pY = window.innerHeight - playerY - 30;

    const dx = pX - startX;
    const dy = pY - startY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    // ë…ë¦½ ì†ë„: ë¯¸ì‚¬ì¼ì€ ìš´ì„ë³´ë‹¤ ë¹ ë¦„
    let speed = 250 + (currentProgress * 250); 
    const vx = (dx / dist) * speed;
    const vy = (dy / dist) * speed;

    missile.style.left = startX + "px";
    missile.style.top = startY + "px";
    
    missile.x = startX; missile.y = startY;
    missile.vx = vx; missile.vy = vy;

    gameArea.appendChild(missile);
    projectiles.push(missile);
  }

  function spawnItem() {
    const types = ["cross", "wings", "wind", "bible"];
    const type  = types[Math.floor(Math.random() * types.length)];
    const item  = document.createElement("div");
    item.classList.add("item");
    item.dataset.type = type;
    item.style.left   = window.innerWidth + "px";
    item.style.bottom = (Math.random() * 250 + 120) + "px";
    item.style.backgroundImage = `url('https://antiochapp.github.io/TrapGame/item_${type}.png')`;
    gameArea.appendChild(item);
    items.push(item);
  }

  function showFloatText(text) {
    const rect = player.getBoundingClientRect();
    const el = document.createElement("div");
    el.classList.add("float-text");
    el.innerText = text;
    el.style.left = (rect.left + 10) + "px";
    el.style.top  = (rect.top - 20) + "px";
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1000);
  }

  function activateItem(type) {
    if (type === "cross") {
      let duration = 10 + lvlInvincible;
      if(currentSkin==='hahwi') duration *= 2; 
      activeEffects.invincible = duration; 
      showFloatText(`ğŸ›¡ï¸ ë¬´ì ! (${duration}s)`);
    } else if (type === "wings") {
      let duration = 5 + lvlTurbo;
      activeEffects.turbo = duration; 
      showFloatText(`ğŸš€ í„°ë³´ ëª¨ë“œ! (${duration}s)`);
    } else if (type === "wind") {
      let duration = 10 + lvlSlow;
      activeEffects.slow = duration; 
      showFloatText(`ğŸƒ ì†ë„ ê°ì†Œ (${duration}s)`);
    } else if (type === "bible") {
      faith += 10; saveData.faith = faith; document.getElementById("faithText").innerText = faith;
      showFloatText("âœ Faith +10"); saveProgress();
    }
  }

  function updateBuffUI(delta) {
    if (activeEffects.turbo > 0) activeEffects.turbo -= delta;
    if (activeEffects.invincible > 0) activeEffects.invincible -= delta;
    if (activeEffects.slow > 0) activeEffects.slow -= delta;
    if (activeEffects.fly > 0) activeEffects.fly -= delta;
    if (activeEffects.summon > 0) activeEffects.summon -= delta;

    let html = "";
    if (activeEffects.turbo > 0) html += `<div class="buff-tag" style="color:#00ffff; border-color:#00ffff">ğŸš€ í„°ë³´ ëª¨ë“œ: ${Math.ceil(activeEffects.turbo)}s</div>`;
    if (activeEffects.invincible > 0) html += `<div class="buff-tag" style="color:#ffe24f; border-color:#ffe24f">ğŸ›¡ï¸ ë¬´ì  ìƒíƒœ: ${Math.ceil(activeEffects.invincible)}s</div>`;
    if (activeEffects.slow > 0) html += `<div class="buff-tag" style="color:#aaffaa; border-color:#aaffaa">ğŸƒ ì†ë„ ê°ì†Œ: ${Math.ceil(activeEffects.slow)}s</div>`;
    if (activeEffects.fly > 0) html += `<div class="buff-tag" style="color:#ffccff; border-color:#ffccff">âœˆï¸ ë¹„í–‰ ëª¨ë“œ: ${Math.ceil(activeEffects.fly)}s</div>`;
    if (activeEffects.summon > 0) html += `<div class="buff-tag" style="color:#ff9900; border-color:#ff9900">ğŸ›¡ï¸ ì†Œí™˜ìˆ˜ íƒ±í‚¹: ${Math.ceil(activeEffects.summon)}s</div>`;
    if (activeEffects.revive > 0) html += `<div class="buff-tag" style="color:#ffffff; border-color:#ffffff">ğŸ‘¼ ìë™ ë¶€í™œ ëŒ€ê¸°</div>`;
    
    if(buffArea) buffArea.innerHTML = html;
  }

  function gameLoop(now) {
    if (!running) return;
    const delta = (now - lastTime) / 1000;
    lastTime = now;

    try { 
      updateBuffUI(delta);
      updateAbilityBtn(delta);
      handleSkinPassive(delta); 
    } catch(e) {}

    if (!daily.run200 && distance >= 200) daily.run200 = true;
    daily.faith20 = faith;
    localStorage.setItem("dailyMission", JSON.stringify(daily));

    let distMultiplier = (activeEffects.turbo > 0) ? 4 : 1;
    distance += delta * 1 * distMultiplier;
    document.getElementById("distanceText").innerText = Math.floor(distance) + "m";

    /* [ìˆ˜ì •] ê²Œì„ ì†ë„ 15ë°°ì† ë¡œì§ ë³µêµ¬ */
    let progress = Math.min(distance / 3000, 1);
    let speedMultiplier = 1 + (progress * 14); // 3000m ë„ë‹¬ ì‹œ 15ë°°ì†
    
    let currentSpeed = BASE_SPEED * speedMultiplier;

    if (activeEffects.slow > 0) currentSpeed *= 0.5;
    if (activeEffects.turbo > 0) currentSpeed *= 2.0; 
    gameSpeed = currentSpeed;

    if (distance >= nextFaithMilestone) {
      faith++; saveData.faith = faith; nextFaithMilestone += 100;
      document.getElementById("faithText").innerText = faith; saveProgress();
    }

    quizTimer += delta;
    const quizSoon = (quizTimer >= 27 && quizTimer < 30);
    if (!quizSoon) {
      obstacleTimer += delta;
      if (obstacleTimer >= nextObstacleTime) {
        spawnObstacle(); obstacleTimer = 0; scheduleNextObstacle(speedMultiplier); 
      }
    }

    /* [ìˆ˜ì •] íˆ¬ì‚¬ì²´ ìƒì„±ì— speedMultiplierë¥¼ ì „ë‹¬í•˜ì§€ ì•Šê³  progressë§Œ ì „ë‹¬ */
    if (distance > 150 && activeEffects.turbo <= 0) {
        meteorTimer += delta;
        // ë¹ˆë„ëŠ” ì—¬ì „íˆ ê²Œì„ ì†ë„ì— ë¹„ë¡€ (í™”ë©´ì´ ë¹¨ë¦¬ ì§€ë‚˜ê°€ë‹ˆê¹Œ)
        let rate = 3.0 / speedMultiplier;
        if (rate < 0.2) rate = 0.2;
        if (meteorTimer > rate) {
            spawnMeteor(progress); // progress ì „ë‹¬
            meteorTimer = 0;
        }
    }

    if (distance > 200 && activeEffects.turbo <= 0) {
        missileTimer += delta;
        let rate = 4.0 / speedMultiplier;
        if (rate < 0.5) rate = 0.5;
        if (missileTimer > rate) {
            spawnMissile(progress); // progress ì „ë‹¬
            missileTimer = 0;
        }
    }

    /* íˆ¬ì‚¬ì²´ ì´ë™ ë° ì¶©ëŒ ë¡œì§ */
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        
        p.x += p.vx * delta;
        p.y += p.vy * delta;

        p.style.left = p.x + "px";
        p.style.top = p.y + "px";

        if (p.x < -100 || p.y > window.innerHeight + 100 || p.x > window.innerWidth + 200) {
            p.remove(); projectiles.splice(i, 1); continue;
        }

        // ì¶©ëŒ ì²´í¬
        if (!activeEffects.invincible && !invincible && activeEffects.summon <= 0 && activeEffects.turbo <= 0) {
            const rectP = player.getBoundingClientRect();
            const rectM = p.getBoundingClientRect();
            
            // [ìˆ˜ì •] ì¶©ëŒ íŒì • ì—¬ìœ ê°’ 10px (ì ë‹¹íˆ ë„ë„í•˜ê²Œ)
            const buffer = 10; 
            if (
                rectP.left + buffer < rectM.right - buffer &&
                rectP.right - buffer > rectM.left + buffer &&
                rectP.top + buffer < rectM.bottom - buffer &&
                rectP.bottom - buffer > rectM.top + buffer
            ) {
                damageLife();
                p.remove(); projectiles.splice(i, 1);
            }
        }
    }

    if (activeEffects.turbo > 0) {
      let targetY = 200; playerY += (targetY - playerY) * 0.1; velocity = 0;
      if(speedLines) speedLines.style.display = "block";
    } else {
      velocity += gravity; playerY += velocity;
      if(speedLines) speedLines.style.display = "none";
    }

    if (playerY < 0) playerY = 0;
    if (playerY > window.innerHeight - 110) playerY = window.innerHeight - 110;
    player.style.bottom = playerY + "px";

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs  = obstacles[i];
      let left   = parseFloat(obs.style.left) || 0;
      left      -= gameSpeed * delta;
      obs.style.left = left + "px";

      const realWidth = obs.offsetWidth > 0 ? obs.offsetWidth : 60;

      if (left + realWidth < 0) {
        obs.remove(); obstacles.splice(i, 1);
        obstacleSurviveCount++;
        if (obstacleSurviveCount >= 5) {
          combo++; faith++; saveData.faith = faith;
          document.getElementById("faithText").innerText = faith;
          const ce = document.getElementById("comboEffect");
          ce.style.display = "block"; ce.innerText = `COMBO +${combo}!`;
          setTimeout(() => ce.style.display = "none", 1000);
          obstacleSurviveCount = 0; saveProgress();
        }
        continue;
      }

      if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible || activeEffects.summon > 0 || activeEffects.revive > 0) {} else {
        const rectP = player.getBoundingClientRect();
        const rectO = obs.getBoundingClientRect();
        const buffer = 10;
        if (rectP.left + buffer < rectO.right - buffer &&
            rectP.right - buffer > rectO.left + buffer &&
            rectP.top + buffer < rectO.bottom - buffer &&
            rectP.bottom - buffer > rectO.top + buffer) {
            damageLife(); break;
        }
      }
      
      if(currentSkin === 'stephanie' && left < 50 && !obs.passed) {
         faith++; document.getElementById("faithText").innerText = faith;
         obs.passed = true;
      }
    }

    itemTimer += delta;
    if (itemTimer >= nextItemTime) {
      let limit = (currentSkin==='jihye') ? 4 : 8; 
      if(itemTimer > limit) {
          spawnItem(); nextItemTime = Math.random() * 6 + 6; itemTimer = 0;
      }
    }

    for (let i = items.length - 1; i >= 0; i--) {
      let it   = items[i];
      let left = parseFloat(it.style.left) || 0;
      left    -= gameSpeed * delta;
      it.style.left = left + "px";
      if (left < -60) { it.remove(); items.splice(i, 1); continue; }
      const rectP = player.getBoundingClientRect();
      const rectI = it.getBoundingClientRect();
      if (
        rectP.left < rectI.right && rectP.right > rectI.left &&
        rectP.top < rectI.bottom && rectP.bottom > rectI.top
      ) {
        activateItem(it.dataset.type); it.remove(); items.splice(i, 1); continue;
      }
    }

    let speedMult = (gameSpeed / BASE_SPEED); 
    bg1X -= BG1_SPEED * speedMult * delta;
    bg2X -= BG2_SPEED * speedMult * delta;
    bg3X -= BG3_SPEED * speedMult * delta;

    bg1.style.backgroundPosition = `${bg1X}px 0`;
    bg2.style.backgroundPosition = `${bg2X}px bottom`;
    bg3.style.backgroundPosition = `${bg3X}px bottom`;

    if (quizTimer >= 30) { quizTimer = 0; pauseForQuiz(); return; }
    requestAnimationFrame(gameLoop);
  }

  function damageLife() {
    if(activeEffects.revive > 0) {
        life = 3; document.getElementById("lifeText").innerText = life;
        activeEffects.revive = 0; activeEffects.invincible = 3; 
        showFloatText("ğŸ‘¼ ë¶€í™œ ë°œë™!");
        return;
    }
    if (activeEffects.turbo > 0 || activeEffects.invincible > 0 || invincible || !running) return;
    life--; document.getElementById("lifeText").innerText = life;
    invincible = true; player.style.opacity = "0.4";
    setTimeout(() => { invincible = false; player.style.opacity = "1"; }, 800);
    if (life <= 0) gameOver();
  }

  async function pauseForQuiz() {
    if (!running) return;
    running = false; document.getElementById("loadingQuiz").style.display = "flex";
    try {
      const res = await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "getQuiz" }) });
      const txt = await res.text();
      document.getElementById("loadingQuiz").style.display = "none";
      if (txt === "noquiz") { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); return; }
      const quiz = JSON.parse(txt);
      document.getElementById("quizQuestion").innerText = quiz.question;
      document.getElementById("btnA").innerText = "A) " + quiz.A;
      document.getElementById("btnB").innerText = "B) " + quiz.B;
      document.getElementById("btnC").innerText = "C) " + quiz.C;
      window.correctAnswer = quiz.answer;
      document.getElementById("quizModal").style.display = "flex";
    } catch (err) {
      document.getElementById("loadingQuiz").style.display = "none";
      running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
    }
  }

  function answerQuiz(sel) {
    document.getElementById("quizModal").style.display = "none";
    if (sel === window.correctAnswer) {
      const ef = document.getElementById("correctEffect");
      ef.style.display = "block"; setTimeout(() => (ef.style.display = "none"), 800);
      faith += 5; saveData.faith = faith; document.getElementById("faithText").innerText = faith;
      daily.quiz3++; localStorage.setItem("dailyMission", JSON.stringify(daily)); saveProgress();
    } else { damageLife(); }
    if (life > 0) { running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop); }
  }

  async function saveProgress() {
    try { await fetch(API_URL, { method: "POST", body: JSON.stringify({ type: "save", id, saveData }) }); } catch (e) {}
    localStorage.setItem("run_save", JSON.stringify(saveData));
  }

  function startGameNow() {
    document.getElementById("startGuide").style.display = "none";
    running = true; lastTime = performance.now(); requestAnimationFrame(gameLoop);
  }

  async function gameOver() {
    if (rankingSaved) return;
    running = false; invincible = true; player.style.opacity = "0.4";
    const dist = Math.floor(distance);
    document.getElementById("finalDist").innerText = dist;
    document.getElementById("gameOverModal").style.display = "flex";
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateRanking", id, name, distance: dist, message: "" })
      });
    } catch (e) {}
    rankingSaved = true;
  }

  async function confirmRanking() {
    const btn = document.querySelector(".action-btn:last-child");
    const msgInput = document.getElementById("rankMsg");
    const msg = msgInput.value.trim();
    if (!msg) { window.location.href = "/TrapGame/menu.html"; return; }
    btn.innerText = "ì „ì†¡ ì¤‘..."; btn.disabled = true;
    try {
      await fetch(API_URL, {
        method: "POST", body: JSON.stringify({ type: "updateComment", id: id, message: msg })
      });
      alert("ì†Œê°ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!"); window.location.href = "/TrapGame/menu.html";
    } catch (e) {
      alert("ì „ì†¡ ì˜¤ë¥˜ê°€ ë‚¬ì§€ë§Œ ë©”ë‰´ë¡œ ì´ë™í•©ë‹ˆë‹¤."); window.location.href = "/TrapGame/menu.html";
    }
  }

  let lastTouch = 0;
  document.addEventListener("touchend", e => {
    const now = Date.now(); if (now - lastTouch < 300) e.preventDefault(); lastTouch = now;
  }, { passive: false });
</script>
</body>
</html>
